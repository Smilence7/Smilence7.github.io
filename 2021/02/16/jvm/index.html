<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-hat.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-hat.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-hat.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab-hat.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CDancing+Script:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.css">
  <script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.js"></script>

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zayeum.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="运行时数据区吴振照的博客 由Java VM管理的内存区域叫运行时数据区(Runtime Data Area)，这个数据区被划分为几个逻辑区域，包括方法区、堆、虚拟机栈、程序计数器、本地方法栈。 其中方法区和堆是线程共享区域，虚拟机栈、程序计数器、本地方法栈是为线程存储运行时数据的独占区域，每个线程都有一份。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java VM 系列">
<meta property="og:url" content="https://zayeum.com/2021/02/16/jvm/index.html">
<meta property="og:site_name" content="Zayeum&#39;s Carriage">
<meta property="og:description" content="运行时数据区吴振照的博客 由Java VM管理的内存区域叫运行时数据区(Runtime Data Area)，这个数据区被划分为几个逻辑区域，包括方法区、堆、虚拟机栈、程序计数器、本地方法栈。 其中方法区和堆是线程共享区域，虚拟机栈、程序计数器、本地方法栈是为线程存储运行时数据的独占区域，每个线程都有一份。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zayeum.com/2021/02/16/jvm/runtime_data_area.png">
<meta property="og:image" content="https://zayeum.com/2021/02/16/jvm/heap_area.png">
<meta property="article:published_time" content="2021-02-15T16:00:00.000Z">
<meta property="article:modified_time" content="2021-03-22T07:15:25.654Z">
<meta property="article:author" content="Zayeum">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="GC">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zayeum.com/2021/02/16/jvm/runtime_data_area.png">


<link rel="canonical" href="https://zayeum.com/2021/02/16/jvm/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Java VM 系列 | Zayeum's Carriage</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Zayeum's Carriage</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">旅之途中</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="nav-text">运行时数据区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86"><span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-text">堆内存结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-text">对象内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-text">对象头</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE"><span class="nav-text">实例数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85"><span class="nav-text">对齐填充</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-text">虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E5%BC%8F%E6%A0%88"><span class="nav-text">本地方式栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-text">加载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-text">加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE"><span class="nav-text">双亲委派</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5-link"><span class="nav-text">链接(link)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-text">验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-text">准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-text">解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">特殊：字符串的初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95-Reference-Counting-GC"><span class="nav-text">引用计数算法(Reference Counting GC)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95-Tracing-GC"><span class="nav-text">根搜索算法(Tracing GC)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GC-Roots"><span class="nav-text">GC Roots</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Stop-The-World"><span class="nav-text">Stop The World</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95"><span class="nav-text">内存回收方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4"><span class="nav-text">标记清除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86-Compacting-GC"><span class="nav-text">标记整理(Compacting GC)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6-Copying-GC"><span class="nav-text">标记复制(Copying GC)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Adaptive-GC"><span class="nav-text">Adaptive GC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cheney%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94Minor-GC%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="nav-text">Cheney算法——Minor GC的起源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="nav-text">堆内存划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E7%A7%8DGC%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">各种GC模型的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E7%A7%8DGC%E5%AD%90%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-text">各种GC子模型的触发条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">值得注意的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E4%BB%A3"><span class="nav-text">为什么要分代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Young-Generation%E4%B8%AD%E8%A6%81%E5%88%86%E4%B8%BAEden%E5%92%8CSurvivor%E5%8C%BA"><span class="nav-text">为什么Young Generation中要分为Eden和Survivor区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Survivor%E5%8C%BA%E5%88%86%E4%B8%BA%E4%B8%A4%E5%9D%97"><span class="nav-text">为什么Survivor区分为两块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEforwarding-pointer%E5%92%8C%E6%9B%B4%E6%96%B0%E5%BC%95%E7%94%A8"><span class="nav-text">设置forwarding pointer和更新引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Young-GC"><span class="nav-text">Young GC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Full-GC"><span class="nav-text">Full GC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS-GC"><span class="nav-text">CMS GC</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%85%E8%AF%BB"><span class="nav-text">待读</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%9A%84%E5%85%B3%E9%97%AD"><span class="nav-text">JVM的关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK%E5%91%BD%E4%BB%A4"><span class="nav-text">JDK命令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jps"><span class="nav-text">jps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jstat"><span class="nav-text">jstat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jinfo"><span class="nav-text">jinfo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Jstack"><span class="nav-text">Jstack</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="nav-text">OOM问题排查</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zayeum"
      src="/images/avatar-small-mage.png">
  <p class="site-author-name" itemprop="name">Zayeum</p>
  <div class="site-description" itemprop="description">Wanna be a mage, a great mage.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Smilence7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Smilence7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:smilence7@outlook.com" title="E-Mail → mailto:smilence7@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zayeum.com/2021/02/16/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar-small-mage.png">
      <meta itemprop="name" content="Zayeum">
      <meta itemprop="description" content="Wanna be a mage, a great mage.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zayeum's Carriage">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java VM 系列
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-16 00:00:00" itemprop="dateCreated datePublished" datetime="2021-02-16T00:00:00+08:00">2021-02-16</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-03-22 15:15:25" itemprop="dateModified" datetime="2021-03-22T15:15:25+08:00">2021-03-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2021/02/16/jvm/#waline-comments" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" id="/2021/02/16/jvm/" data-xid="/2021/02/16/jvm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><em><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuzhenzhao/p/12346515.html">吴振照的博客</a></em></p>
<p>由Java VM管理的内存区域叫运行时数据区(Runtime Data Area)，这个数据区被划分为几个逻辑区域，包括方法区、堆、虚拟机栈、程序计数器、本地方法栈。</p>
<p>其中方法区和堆是线程共享区域，虚拟机栈、程序计数器、本地方法栈是为线程存储运行时数据的独占区域，每个线程都有一份。</p>
<img src="/2021/02/16/jvm/runtime_data_area.png" class="" title="运行时数据区">

<a id="more"></a>

<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区在JVM启动时创建，是堆的一部分，但为了与存放对象的堆区分，被取名为Non-Heap。方法区中存放<strong>运行时常量池</strong>、静态变量、类信息、即时编译器编译后的代码。方法区的内存不需要连续，在JDK 6、7中，方法区是永久代Perm Space，有JVM要求的固定大小上限；在JDK 8中，方法区改为元区域Metaspace，由JVM使用直接内存，仅被实际内存大小约束。JVM提供参数修改方法区的初始、最大、最小大小。如果方法区内存溢出，会产生错误信息OutOfMemoryError: Metaspace。</p>
<blockquote>
<p><strong>运行时常量池</strong></p>
</blockquote>
<p>运行时常量池(Runtime Constant Pool)中包含编译时已知的<strong>字面量</strong>和运行时解析的<strong>方法</strong>、<strong>字段引用</strong>。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是JVM内存中最大的一块，也不需要是连续的，堆内存用于存放Java对象实例和数组。因为对象的使用寿命一般较短，因此堆是垃圾回收发生的主要区域。如果堆内存溢出，会产生错误信息OutOfMemoryError: Heap Space。</p>
<h4 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h4><p>堆内存结构是以优化垃圾回收为目的设计的，具体结构见「垃圾回收机制」章节。</p>
<h4 id="对象内存结构"><a href="#对象内存结构" class="headerlink" title="对象内存结构"></a>对象内存结构</h4><p>根据前文对JVM内存结构的介绍我们可以想到，一个静态引用是从<strong>方法区</strong>指向堆对象的引用，而一个普通引用是从<strong>栈帧</strong>指向堆对象的引用。那么对象的内部结构是怎样的呢？对象是怎么和它属于的类连接的呢？</p>
<p>在其它语言实现中，很多会用到句柄，一个句柄分别指向对应的对象和类，引用变量只需要指向句柄即可间接连接到对象和类；而在HotSpot中是采用直接操控指针的方式实现的，每个对象内存中直接存放了指向所属类的指针。</p>
<p>在一个对象中，有对象头、实例数据和填充数据三个逻辑部分。</p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>保存与对象整体相关的信息：</p>
<ul>
<li>Mark Word: 用于保存hashcode、年龄(用于GC)、锁状态(用于分段锁)等信息，8 byte;</li>
<li>Class Pointer: 指向方法区中的对应类数据，8 byte;</li>
<li>Length: 数组长度，是数组对象特有的部分，4 byte。</li>
</ul>
<h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h5><p>保存对象的成员变量：</p>
<ul>
<li>boolean / byte: 1byte;</li>
<li>short / char: 2 byte;</li>
<li>int / float: 4 byte;</li>
<li>long / double: 8 byte;</li>
<li>reference: 8byte.</li>
</ul>
<h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><p>将对象的大小填充到8byte的整数倍。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器(Program Count Register)用于记录程序运行的进度，具体地说，用于保存当前正在执行的VM字节码指令的地址。每个线程都有一个程序计数器，通过它，线程能够在拿到cpu时间片时直接定位到该执行的指令。如果执行的是Native方法，则当前值为Undefined。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈是线程在方法调用时使用的底层存储空间，线程将调用方法所要用的数据存放在一起压入栈中，称作一个栈帧。方法的调用开始和完成就对应了一个栈帧的压入和弹出。每个栈帧中包含四个部分：</p>
<ul>
<li><p>局部变量表：存放方法参数和局部变量，注意，使用这些变量需要先将它们压入操作数栈中。</p>
</li>
<li><p>操作数栈：存储当前使用的操作数。</p>
</li>
<li><p>动态链接：指向<strong>运行时常量池</strong>中该栈帧对应方法的引用，支持方法中的动态链接</p>
</li>
<li><p>方法出口：方法返回的地址。</p>
</li>
</ul>
<h3 id="本地方式栈"><a href="#本地方式栈" class="headerlink" title="本地方式栈"></a>本地方式栈</h3><p>与虚拟机栈类似，只是本地方法栈专用于本地方法的执行。</p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p><em><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuzhenzhao/p/12346516.html">吴振照的博客</a></em></p>
<p>Java文件在编译时经过词法分析器、tokens流、语法分析器、语法树、语义分析器、注解抽象语法树、字节码生成器这一系列操作转换成字节码，保存在.class文件中。类文件在运行时被加载到虚拟机，其中包括加载、链接(验证、准备、解析)、初始化这三个阶段。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><ul>
<li>通过类的全限定名获取.class字节码文件</li>
<li>将字节码中的静态存储结构转化为方法区的运行时数据结构</li>
<li>在Java堆中生成代表这个类的java.lang.Class对象，作为这些静态数据的访问入口</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>加载由类加载器ClassLoader完成，类加载器从上到下有Bootstrap, Extension, System, Custom四种，Bootstrap加载核心类库，Extension加载扩展类，System加载类路径下的类，而Custom是用户自定义的类加载器。加载类时采用双亲委派机制。</p>
<h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>某个具体的类加载器收到加载请求时，会先从上往下检查是否被某个类加载器加载过，如果没有加载过，再从下往上递归地让父类加载器完成，最终由最上层能够加载的父类加载器执行加载，这样做可以避免重复加载，同时考虑了安全因素(如果类在核心类库中被加载过了，就不会被自定义的同名类替换)。</p>
<h3 id="链接-link"><a href="#链接-link" class="headerlink" title="链接(link)"></a>链接(link)</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保字节码中的信息符合虚拟机要求，包括文件格式验证、原数据验证、字节码验证、符号引用验证；</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>给类变量(类静态变量)分配内存和设置初始化值(final静态变量在编译期被赋值保存在方法区的运行时常量池)。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>把常量池中的符号引用替换为直接引用，如果引用指向未被加载的类或类成员，会先加载这个类。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行由编译器收集好的类的初始化器(类变量赋值语句和静态代码块)，进行初始化。</p>
<p>在运行时，JVM根据语句执行顺序对<strong>类对象</strong>进行初始化，当运行时发生以下情况时触发初始化：</p>
<ul>
<li>遇到new, getstatic, putstatic, invokestatic四条字节码指令时，即：实例化对象时、读取或设置非final的静态字段时、调用静态方法时，如果类还没有初始化，先触发类的初始化；</li>
<li>调用java.lang.reflect包时，如果类还没有初始化，先触发类的初始化；</li>
<li>初始化一个类时，如果父类还没有初始化，先触发<strong>父类</strong>的初始化；</li>
<li>虚拟机启动时，先初始化main方法所在的类(主类)；</li>
<li>JDK1.7 方法句柄对应的类没有初始化，先触发初始化。</li>
</ul>
<h3 id="特殊：字符串的初始化"><a href="#特殊：字符串的初始化" class="headerlink" title="特殊：字符串的初始化"></a>特殊：字符串的初始化</h3><p>运行时常量池：在方法区中，保存类加载过程的字面量</p>
<p>字符串常量池：全局存在，保存对字符串对象的唯一引用</p>
<p>字符串对象在初始化和赋值给引用时，会先查找<strong>字符串常量池</strong>中是否已经存在相同内容的引用。字符串常量池通过维护一个HashSet&lt;String&gt;来保存所有全局共享的字符串对象，相同的字符串都会使用字符串常量池中的同一个引用。在类加载的解析阶段，JVM把字符串的引用添加到字符串常量池，但HotSpot VM的实现是采用懒加载的方式，仅当一个字符串引用第一次被执行<strong>ldc</strong>指令时，才会加载到字符串常量池。ldc的功能是将int、float或String型常量值从运行时常量池拷贝到操作数栈的栈顶，懒加载就是仅当遇到ldc指令时才实际创建字符串对象、把引用添加到字符串常量池。也就是说，在加载类时，字面量会进入<strong>当前类的运行时常量池</strong>，而不会进入<strong>全局的字符串常量池</strong>。在ldc过程中，如果字面量(Literal, 也就是”xxx”)的引用已经存在于字符串常量池，就直接使用对应的引用，否则才创建新的对象和添加引用到字符串常量池；如果使用 <code>&quot;xxx&quot;+&quot;xxx&quot;</code> 的方式，会采用stringbuffer的<code>append()</code>方式，并以<code>toString()</code>产生一个新的字符串，因为这个新字符串<strong>是在操作数栈中产生的</strong>，没有用到ldc指令，所以不会在字符串常量池中添加引用。而String对象的<code>intern()</code>方法会检查常量池是否有这个字符串对象的引用，如果没有就保存一份到常量池中，最后不管有没有都会返回它的引用。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>当一些对象不在被任何对象引用引用，JVM的垃圾回收机制(Garbage Collector)会帮我们释放对象占用的内存。那么GC应该怎么判断对象是否需要回收呢？有两种思想，一种是引用计数，一种是根搜索。</p>
<h3 id="引用计数算法-Reference-Counting-GC"><a href="#引用计数算法-Reference-Counting-GC" class="headerlink" title="引用计数算法(Reference Counting GC)"></a>引用计数算法(Reference Counting GC)</h3><p>每一个对象存储一个计数变量，每当有一个地方引用它就加1，每当有一个引用失效就减1。由于一个对象在创建后必须被引用，否则就再也不能被引用，所以当计数值归0时，就说明不再会有任何引用能够引用到它。</p>
<p>这种算法的特点是简单，可以与正常程序并发进行，但检查不出对象间的循环引用，早期的JVM曾用过这种方法。</p>
<h3 id="根搜索算法-Tracing-GC"><a href="#根搜索算法-Tracing-GC" class="headerlink" title="根搜索算法(Tracing GC)"></a>根搜索算法(Tracing GC)</h3><p>如果把对象的引用变量关系看作一张有向图，只要定义一些一直存在的结点为根结点(GC Roots)，从根节点开始搜索，能搜索到的结点就是仍在使用中的对象。Tracing GC的实现可以使用广度优先算法，算法的思想是将结点分为白、灰、黑三种颜色：白色代表还没搜索到的结点；灰色代表正在搜索的结点，也就是说这个对象仍有引用没有遍历完，将其放入搜索队列；黑色代表已经搜索过的结点，放入集合。具体实现方法是，申请一段连续地址作为队列，从根集合出发进行广度优先搜索，在搜索的过程中，只扫描没有标记过的对象，先标记这些对象，再将其放入队尾。</p>
<p>在tracing GC中包含GC Roots、Stop The World的概念，基于根搜索的标记思想又衍生出不同的回收方案。</p>
<h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>GC Roots包括：</p>
<ul>
<li>虚拟机栈中引用的对象，即栈帧中的局部变量表中的引用对象；</li>
<li>方法区中的常量引用的对象；</li>
<li>方法区中的类静态属性引用的对象；</li>
<li>本地方法栈中JNI的引用对象；</li>
<li>活跃线程。</li>
</ul>
<h4 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h4><p>由于程序在运行过程中，对象的引用关系是动态变化的，所以要进行Tracing和marking，必须暂停所有应用线程。JVM会让所有线程运行到安全点(safepoint)，并触发一次Stop The World(STW)。暂停的时间取决于存活对象的多少。</p>
<h4 id="内存回收方法"><a href="#内存回收方法" class="headerlink" title="内存回收方法"></a>内存回收方法</h4><p>在根搜索标记阶段完成后，就需要真正地回收内存了，在这一步可以采用不同的方法。</p>
<h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><p>标记阶段结束后，直接回收所有没被标记的对象，这种方法的好处就是在引用计数法的效果上弥补了循环引用问题的不足，而比起其他tracing算法，它不需要移动对象；缺点是需要用一个表来维护所有没被标记的对象，而且回收后会产生内存碎片。</p>
<h5 id="标记整理-Compacting-GC"><a href="#标记整理-Compacting-GC" class="headerlink" title="标记整理(Compacting GC)"></a>标记整理(Compacting GC)</h5><p>标记阶段结束后，将所有的标记对象向内存地址的一边移动，相当于“整理”内存。这样就不会有内存碎片，新对象的创建地址只需要用一个指针指示。缺点是整理耗费的时间长。</p>
<h5 id="标记复制-Copying-GC"><a href="#标记复制-Copying-GC" class="headerlink" title="标记复制(Copying GC)"></a>标记复制(Copying GC)</h5><p>Copying的思想是把内存分成大小相等的两块，每次只使用其中一块。每当需要垃圾回收时，通过tracing标记所有存活的对象，把它们拷贝到另外一块内存中。这种方法的好处是标记和复制可以同时进行，而且复制操作中目标地址是连续的，原地址也不需要备份，实现更高效，也不会产生内存碎片；缺点就是需要两倍大小的内存空间。</p>
<p>Copying GC是HotSpot GC中负责新生代垃圾回收的算法主要采用的方法，因为新生代中大多数对象的生命周期都很短，每次标记只有少量对象能存活，因此需要复制的对象就少，算法效率更高。</p>
<h5 id="Adaptive-GC"><a href="#Adaptive-GC" class="headerlink" title="Adaptive GC"></a>Adaptive GC</h5><p>这种思想是根据当前情况选择合适的GC算法去处理。分代其实也有一点Adaptive GC思想，只是分代并不是动态选择，而是划分好了不同的情况，并规定每种情况用哪种GC算法。</p>
<h3 id="Cheney算法——Minor-GC的起源"><a href="#Cheney算法——Minor-GC的起源" class="headerlink" title="Cheney算法——Minor GC的起源"></a>Cheney算法——Minor GC的起源</h3><p><em><a target="_blank" rel="noopener" href="https://hllvm-group.iteye.com/group/topic/39376#post-257329">R大的文章</a></em></p>
<p>Minor GC与其对应在serial GC中的实现类DefNewGeneration使用的就是Cheney算法的变种，Cheney是一种经典的copying算法，它的实现思想就是上文介绍的标记复制方法，具体来说，有以下几个重点：</p>
<ol>
<li>使用一块连续的地址空间，划分成from-space和to-space。</li>
<li>从GC Roots中逐个扫描指向堆的引用，每扫描到一个对象，就把它从from-space拷贝到to-space，并在原对象里记录forwarding pointer，用于标识这个对象被移动到的新位置。并且，每通过<strong>引用</strong>扫描到一个引用对象、拷贝这个对象后，就将这个引用<strong>修正</strong>为指向拷贝后的新对象。</li>
<li>扫描到一个对象时，通过是否有forwarding pointer来判断对象是否被扫描过。所以forwarding pointer既有转发、更新引用的作用，也有标记(mark)作用。</li>
<li>to-space区域用一个指针(scanned)指示已经完成扫描的对象位置，另一个指针(top)指示新来的对象应该放到哪里，逻辑上地址是由低到高。由于一个对象可能包含多个引用，每扫描到一个引用，都需要将引用对象拷贝到to-space的对应位置，但对象本身并没有扫描完成，所以to-space成为了一个隐式的队列结构，bottom~scanned区域是完成扫描的对象，scanned~top区域是已经扫描到但没扫描完的对象，top~end是未分配的空间。</li>
</ol>
<h3 id="堆内存划分"><a href="#堆内存划分" class="headerlink" title="堆内存划分"></a>堆内存划分</h3><p>JVM研究人员发现，对象的生命周期各不相同，其中大部分对象的生命周期都很短，根据年龄划分对象和对象存放区域，能够有效地利用copying算法的优势，从而提高整个GC体系的效率。因此堆内存在HotSpot虚拟机中，以优化垃圾回收算法为目的，划分为新生代(Young Generation)、年老代(Old Generation)和永久代(Permanent Generation)。其中新生代又被划分为Eden区和Survivor区，Survivor区又被分为survivor0和survivor1两半，对应copying算法中的from-space和to-space。新生代中 Eden : S0 : S1 = 8 : 1 : 1。</p>
<img src="/2021/02/16/jvm/heap_area.png" class="" title="堆内存结构">

<p>一般情况下，新创建的对象会被分配到eden区，而大对象会被直接分配到old区。</p>
<p>常说的Minor GC，是负责整个young区的垃圾回收器的俗称。当eden区被放满，就会对eden区进行一次minor GC，把eden和from-space中存活的对象复制到to-space，并且年龄+1，年龄到达阈值的对象会被移到old区。to-space总是在结束前和from-space互换，保证只有from-space有对象。当to-space在一次GC过程中被填满了，minor GC就会把所有存活对象放入old区。</p>
<p>Old区空间比较大，且在这里的对象都已经很老了比较长(从统计学上看，对象的生命周期要么很短，要么偏长)，所以old区进行GC的频率远小于young区，负责old区的GC俗称为Major GC。又因为只有CMS具有单独处理old区的GC，其他垃圾处理器在处理old时都会先触发一次Minor GC，或者像G1直接收集整个堆，所以很多时候也把Major GC称为Full GC，Full GC指收集整个堆的GC模式。</p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><em><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5261a62e4d29">简欲明心的文章</a><em>、</em><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41922036/answer/144566789">Ted Mosby的回答</a><em>、</em><a target="_blank" rel="noopener" href="https://blog.csdn.net/renfufei/article/details/54885190">JVM的GC器</a></em></p>
<p>垃圾回收器通过设计、组合和优化不同分代使用的算法产生，是指整个垃圾回收模型。这里归纳几种GC的特点。</p>
<p>Serial GC =  Serial Young GC + Serial Old GC (Full GC)s</p>
<p>Parallel GC = Parallel Young GC + (非并行) PS MarkSweep GC (Full GC) / (并行) Parallel Old GC (Full GC)</p>
<p>CMS = ParNew GC(Young GC)  + CMS GC(Old GC) + Full GC for CMS(备用)</p>
<p>G1 GC = Young GC + mixed GC(Young + part of Old) + Full GC for G1 GC(备用)</p>
<h4 id="各种GC模型的特点"><a href="#各种GC模型的特点" class="headerlink" title="各种GC模型的特点"></a>各种GC模型的特点</h4><ul>
<li>所有的Minor GC都采用copying思想；</li>
<li>所有的Full GC都采用compacting思想；</li>
<li>CMS GC(Old GC)采用mark-sweep思想(concurrent mark sweep)；</li>
<li>CMS追求最短STW时间；</li>
<li>G1 GC能够根据用户希望的STW时间制定回收计划，设计目标是取代CMS。</li>
</ul>
<h4 id="各种GC子模型的触发条件"><a href="#各种GC子模型的触发条件" class="headerlink" title="各种GC子模型的触发条件"></a>各种GC子模型的触发条件</h4><ul>
<li>所有Young GC触发条件都是Eden区满了；</li>
<li>Serial Old GC 和Parallel Old GC(并行和非并行)的触发条件是在Young GC执行前预测old会满；</li>
<li>CMS GC的initial marking触发条件是old使用比例超过阈值；</li>
<li>G1 GC的initial marking触发条件是整堆使用比例超过阈值；</li>
<li>Full GC for CMS和Full GC for G1 GC的触发条件是前面的Old GC没效果。</li>
</ul>
<h3 id="值得注意的问题"><a href="#值得注意的问题" class="headerlink" title="值得注意的问题"></a>值得注意的问题</h3><h4 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h4><p>对于Serial GC来说，GC过程中需要stop the world，所以缩短一次GC的耗时是一件重要的事，而分代作为一种partition的思路，基于对象“朝生暮死”的特性，让新对象在新生代创建，并且频繁收集新生代中的垃圾，而新生代的大小通常也只占堆中的一小部分，所以能够降低STW时间。</p>
<p>而对于<strong>并发</strong>GC来说，GC是一场和应用拼速度的游戏：应用在创建对象和引用，而GC在后面收集失效的对象和引用。在这种情形下，分代缩短GC的处理时间，就能提高GC的速度，避免或者降低GC应付不了应用不断产生的垃圾、造成STW并等待GC收集的情况。</p>
<h4 id="为什么Young-Generation中要分为Eden和Survivor区"><a href="#为什么Young-Generation中要分为Eden和Survivor区" class="headerlink" title="为什么Young Generation中要分为Eden和Survivor区"></a>为什么Young Generation中要分为Eden和Survivor区</h4><p>如果没有年龄机制，每次Young区满了就要把存活对象放入old区，这样old区更快被填满，发生Full GC的频率增大，效率慢。设置Survivor区和年龄晋升机制就是为了让young区更频繁的触发具有高效率的Minor GC，减少Full GC频率。</p>
<h4 id="为什么Survivor区分为两块"><a href="#为什么Survivor区分为两块" class="headerlink" title="为什么Survivor区分为两块"></a>为什么Survivor区分为两块</h4><p>显然，是为了使用Copying GC的思想，得到它的优点：高效地同时去碎片化。</p>
<h4 id="设置forwarding-pointer和更新引用"><a href="#设置forwarding-pointer和更新引用" class="headerlink" title="设置forwarding pointer和更新引用"></a>设置forwarding pointer和更新引用</h4><p><em><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/42181722/answer/145085437">Ted Mosby的回答</a></em></p>
<p>Copying GC策略中复制对象后，原对象的对象头改为指向新对象地址的指针forwarding pointer。</p>
<h5 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h5><p>Young GC类算法中，GC roots包含原定义的GC roots加上old-&gt;young的引用，从这些roots出发，trace每一条路径，如果遇到young-&gt;old的引用，则停止这条路径的搜索；</p>
<p>当第一次遇到一个对象，会将其copy或者promote，并在这个原对象的markword中存放forwarding pointer；如果这个对象还被其他<strong>引用</strong>指向，下一次tracing到这个对象时，会根据其存放的forwarding pointer更新这些<strong>引用</strong>。</p>
<p>这类算法包括Serial Young GC（DefNew）、Parallel Young GC、ParNew，以及G1 GC的Young GC &amp; Mixed GC。</p>
<h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>Full GC类算法中，先扫描一遍整个堆，找到所有的live objects，计算它们将要去往的新地址，先通过这些地址更改所有live objects的引用，使它们指向正确的新地址，再把live objects复制到对应的新地址上。</p>
<p>这类算法包括Serial Old GC、PS MarkSweep GC、Parallel Old GC、Full GC for CMS和Full GC for G1 GC。</p>
<h5 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h5><p>CMS算法的老年代GC采用标记-清除法，当ParNew GC的mark-copy结束后，再trace一遍指向老年代的引用，对扫描到的对象进行remark。</p>
<h4 id="待读"><a href="#待读" class="headerlink" title="待读"></a>待读</h4><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/53613423/answer/135743258">RednaxelaFX的回答</a></p>
<h3 id="JVM的关闭"><a href="#JVM的关闭" class="headerlink" title="JVM的关闭"></a>JVM的关闭</h3><p>JVM的关闭分为正常关闭、异常关闭和强制关闭三种。其中，有四种正常关闭的方法：</p>
<ol>
<li>所有非守护线程执行结束</li>
<li>程序中调用System.exit(0)</li>
<li>终端使用ctrl+c发送SIGINT信号</li>
<li>linux命令kill -15发送SIGTERM信号</li>
</ol>
<p>两种异常关闭的情况：</p>
<ol>
<li>RuntimeException发生</li>
<li>OOM</li>
</ol>
<p>强制关闭分为3种情况：</p>
<ol>
<li>linux命令kill -9发送SIGKILL信号</li>
<li>程序调用Runtime.halt()</li>
<li>断电、宕机等物理情况使系统关机</li>
</ol>
<p>在JVM非强制关闭的情况下，会在关闭前调用已注册的shutdown hooks，实现用户自定义的资源释放过程。钩子本质上是一个线程，因此在注册多个钩子时会并发执行，所以可能产生死锁问题，因此建议在同一个钩子中执行操作。</p>
<p>而在强制关闭的情况下不会执行钩子方法和finalizer方法。</p>
<h3 id="JDK命令"><a href="#JDK命令" class="headerlink" title="JDK命令"></a>JDK命令</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>jps：查看所有虚拟机执行主类名称和进程的本地虚拟机唯一ID(LVMID)</p>
<p>jps -q: 只输出进程的本地虚拟机唯一ID</p>
<p>jps -l: 输出主类的全名或jar包路径</p>
<p>jps -v: 输出进程启动时JVM参数</p>
<p>jps -m: 输出传给main()函数的参数</p>
<h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>Jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</p>
<p>jstat用于监视虚拟机的运行状态信息</p>
<h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>jinfo vmid 输出对应ID的虚拟机的全部参数</p>
<p>jinfo -flag name vmid 输出对应 ID的虚拟机的对应名称的参数值</p>
<p>jinfo -flag name [+|-]name vmid 开启或关闭对应ID的虚拟机的对应名称的参数值</p>
<h4 id="Jstack"><a href="#Jstack" class="headerlink" title="Jstack"></a>Jstack</h4><p>jstack生成虚拟机当前时刻的线程快照</p>
<h3 id="OOM问题排查"><a href="#OOM问题排查" class="headerlink" title="OOM问题排查"></a>OOM问题排查</h3><p>内存溢出问题会发生在堆内存区域(Java heap space)或元数据区(MetaSpace)。</p>
<p>堆内存溢出产生的原因可能是内存泄漏或超出了预期的流量/数据量峰值。内存泄漏是指使用完的对象仍存在强引用，垃圾回收器无法对其占用的资源进行回收释放，导致可用内存不够。内存泄漏发生的情况之一是使用对象作为HashMap的键，当对象不再使用时，没有及时释放HashMap对其的引用，导致键值对不会被回收。</p>
<p>通过设置JVM参数导出dump文件到指定目录：</p>
<p><code>-XX:+HeapDumpOnOutOfMemoryError -XX: HeapDumpPath=oom.hprof</code></p>
<p>使用MAT工具分析生成的文件，用Leak Suspects Reports功能可以查看怀疑的对象和堆栈信息，从堆栈信息可以追溯到发生OOM的代码段。</p>
<p>方法区(MetaSpace)内存溢出是有太多或者太大的类被加载到方法区，可以尝试使用G1 GC回收方法区垃圾，或者排查程序是否加载了不合理的类。</p>
<p><code>OOM Error: Unable to create new native thread</code> 发生在操作系统拒绝向JVM提供更多的线程，因为创建的线程数已经超过上限。</p>
<p><code>OOMError: Out of swap space?</code> 发生在操作系统配置的交换空间不足或系统的另一个进程消耗所有的内存资源时，或者是用户使用了JVM的native heap memory，但没有正确地释放。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/GC/" rel="tag"><i class="fa fa-tag"></i> GC</a>
              <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/02/15/io-models/" rel="prev" title="I/O 模型">
                  <i class="fa fa-chevron-left"></i> I/O 模型
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/02/17/sort/" rel="next" title="排序系列">
                  排序系列 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zayeum</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">78k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:11</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  
<script src="/js/local-search.js"></script>





  <script>
    NProgress.configure({
      showSpinner: true
    });
    NProgress.start();
    document.addEventListener('readystatechange', () => {
      if (document.readyState === 'interactive') {
        NProgress.inc(0.8);
      }
      if (document.readyState === 'complete') {
        NProgress.done();
      }
    });
    document.addEventListener('pjax:send', () => {
      NProgress.start();
    });
    document.addEventListener('pjax:success', () => {
      NProgress.done();
    });
  </script>

  



    <div class="pjax">

  <script src="//cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://zayeum.com/2021/02/16/jvm/',]
      });
      });
  </script>
<script>
NexT.utils.loadComments('#waline-comments', () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js', () => {
    new Waline(Object.assign({
      lang: 'zh-CN'
    }, {"enable":true,"serverURL":"https://comment-api-seven.vercel.app","placeholder":"欢迎在这里评论...","avatar":"monsterid","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":false,"requiredFields":["nick"],"lang":"zh-cn","libUrl":null}, {
      el: '#waline-comments',
      path: "/2021/02/16/jvm/",
    }));
  }, window.Waline);
});
</script>
<script type="text/javascript" src="/js/fold_action.js"></script>

    </div>
</body>
</html>
