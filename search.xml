<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>查找树系列</title>
    <url>/2021/02/04/binary-search-tree/</url>
    <content><![CDATA[<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树定义每个结点的左子树里的元素值都小于该节点、右子树里的元素都大于该节点，这样的定义使它的中序遍历就是升序的有序数据，时间复杂度为O(n)。</p>
<p>查找操作：从根节点出发，小于就递归左子树，大于就递归右子树，直到等于根节点就返回。</p>
<p>插入操作：一直递归比较，直到找到该分支底部的位置（左小右大向下查找，直到左/右子树为空，就新建一个结点放到左/右子结点）。</p>
<a id="more"></a>

<p>删除操作：先查找到删除的结点位置，</p>
<ul>
<li>如果该位置没有子结点，将父节点指向null；</li>
<li>如果该位置有一个子结点，将父节点指向该子结点（如果待删除结点是父节点的左子结点就接左指针，否则接右指针）；</li>
<li>如果该位置有两个子结点，查找右子树中最小的结点，用它的值覆盖待删除位置，再递归地删除新的待删除结点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node p = tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">  Node pp = <span class="keyword">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">    <span class="keyword">else</span> p = p.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">    Node minP = p.right;</span><br><span class="line">    Node minPP = p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minPP = minP;</span><br><span class="line">      minP = minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">    p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">    pp = minPP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">  Node child; <span class="comment">// p的子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) child = p.left;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) child = p.right;</span><br><span class="line">  <span class="keyword">else</span> child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pp == <span class="keyword">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">  <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前驱结点：比该结点小的最大结点。后继结点：比该结点大的最小结点。</p>
<p>前驱结点和后继结点在后面说到的平衡树中有重要的作用，因为平衡的过程中需要调整结点位置而不改变查找树左大右小的性质，因此需要找到并移动前驱或后继结点。</p>
<p>支持重复数值：如果存储的是对象，并通过其中一个成员变量来判断大小，那么就可能存在重复值。对于重复值的处理很简单：后出现的重复值看作大于前面出现的值就可以了。在插入时，新出现的重复值被插入前一个的右子树；在查找时，每查找到一个就存入结果，并继续往右子树查找，直到遇到叶子结点才结束；删除时同理。</p>
<p>时间复杂度：完全二叉树O(logn)，极端不平衡的二叉树退化成链表O(logn)。</p>
<p>二叉查找树 v.s. 哈希表：二叉查找树存储的是有序数据，且性能稳定，而哈希表会遇到散列冲突、扩容等情况；哈希表大多数情况比二叉查找树快，因为O(1)与O(logn)的差别，只有n特别小时，哈希函数的复杂度加上常量级的查找时间也可能超过O(logn)。</p>
<h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>平衡树就是B树(Balance Tree, B-Tree)。</p>
<h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><p>平衡树的二叉树版本，通常称为AVL树。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><em>整理自 <a href="https://www.zhihu.com/question/312327402/answer/1560653215">敖丙的知乎回答</a></em>  </p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>红黑树是对概念模型<strong>2-3-4树</strong>的一种实现。2-3-4树是阶数为4的B树(平衡多路查找树)。</p>
<p>2-3-4 树可以包含三种结点：</p>
<ul>
<li>2结点：结点有1个值，二叉，分别对应小于该结点和大于该结点的子树；</li>
<li>3结点：结点有2个值，三叉，同理；</li>
<li>4结点：结点有3个值，四叉，同理。</li>
</ul>
<p>而红黑树是把这种4阶树实现在<strong>二叉树</strong>上，通过引入结点颜色并相应地设计一套规则，减小了调整平衡的时间开销。</p>
<p>为简化理解难度，我们先理解一下2-3树到红黑树的转换过程，再了解2-3树的调平方式，从而理解红黑树的调平策略。</p>
<h3 id="将一颗2-3树转换成红黑树"><a href="#将一颗2-3树转换成红黑树" class="headerlink" title="将一颗2-3树转换成红黑树"></a>将一颗2-3树转换成红黑树</h3><p>2结点就是二叉结点，令它作为黑色结点；</p>
<p>3结点可以拆成两个结点，遵循查找树的特性，有左倾和右倾两种转换形式，父结点为黑，子结点为红；</p>
<p>(如果是2-3-4树转换为红黑树，同理，4结点用3个值里中间的那个作为黑色根结点，连接左右两个红色子结点。)</p>
<img src="/2021/02/04/binary-search-tree/2-3%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" class="" title="2-3树与红黑树">

<p>如果把所有的3结点都按左倾的方式处理，就形成了图中的对应关系，即所有3结点的第一个数作为左子结点，第二个数作为父结点。</p>
<h3 id="2-3-4-树的插入删除"><a href="#2-3-4-树的插入删除" class="headerlink" title="2-3(-4)树的插入删除"></a>2-3(-4)树的插入删除</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>对于2结点的插入，直接转为3结点。对应红黑树中在黑结点下插入元素(红结点)。</p>
<p>对于3结点，如果是2-3树，先产生临时的4结点，再向上分裂（中间值左为父结点）；如果是2-3-4树，直接转为4结点。融合出临时4结点后的分裂操作对应红黑树中插入红结点后对双红结点旋转的操作。</p>
<p>对于4结点，先将4结点向上分裂，在找到插入元素所应该在的2结点，将其转为3结点。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除元素在3结点中，直接删除。</p>
<p>删除元素在2结点中，直接删除这个结点会破坏树的平衡。对应插入过程中的分裂，删除时可以从兄弟和父结点中借元素。</p>
<ul>
<li><p>兄弟结点是2结点，父结点为3结点：父结点下移一个元素给当前结点，此时当前结点有2个元素，与兄弟结点的2个元素合并成一个临时4结点，再删除元素成为3结点。</p>
</li>
<li><p>兄弟结点是3结点：兄弟结点上移一个元素给父结点，父结点下移一个元素给当前结点，再删除对应元素。</p>
</li>
<li><p>兄弟结点和父结点都是2结点：三者合并成一个临时4结点，再删除元素成为3结点。</p>
</li>
</ul>
<h3 id="通过2-3树理解红黑树的定义"><a href="#通过2-3树理解红黑树的定义" class="headerlink" title="通过2-3树理解红黑树的定义"></a>通过2-3树理解红黑树的定义</h3><ol>
<li><p>结点颜色分为红色和黑色</p>
<p>对应2-3树中的3结点，令其中一个是黑色一个是红色</p>
</li>
<li><p>根结点为黑色</p>
<p>2-3树中的2结点自然是黑结点，因此根2结点是黑色；对于根3结点，定义其中一个元素为黑色根结点(取决于左倾还是右倾)。</p>
</li>
<li><p>叶子结点是黑色（空结点）</p>
<p>实际上是所有叶子结点指向同一个黑色空结点，方便代码实现。</p>
</li>
<li><p>每个结点到任意叶子结点的路径中经过的黑色节点数相同</p>
<p>参考上面的图，所有的红色结点和其父结点在2-3树中是同一个结点，自然不会贡献高度；而2-3树的定义就有结点到任意叶子结点的距离相同。</p>
</li>
<li><p>红色结点不能直接连接</p>
<p>连续红色结点代表2-3-4树中的3结点，在红黑树中是作为左右子结点隔开的。</p>
</li>
</ol>
<h3 id="二叉查找树的调平"><a href="#二叉查找树的调平" class="headerlink" title="二叉查找树的调平"></a>二叉查找树的调平</h3><p>前面介绍二叉查找树的时候提到，查找前驱结点和后继结点是十分重要的功能。<em>待填</em></p>
<h3 id="左倾红黑树的插入删除"><a href="#左倾红黑树的插入删除" class="headerlink" title="左倾红黑树的插入删除"></a>左倾红黑树的插入删除</h3><p><em>待填</em></p>
<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p><em>待填</em></p>
<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p><em>待填</em></p>
<h3 id="普通红黑树的插入"><a href="#普通红黑树的插入" class="headerlink" title="普通红黑树的插入"></a>普通红黑树的插入</h3><p><em>代填</em></p>
<h3 id="值得思考的问题"><a href="#值得思考的问题" class="headerlink" title="值得思考的问题"></a>值得思考的问题</h3><h4 id="为什么HashMap底层实现用红黑树而不是AVL树"><a href="#为什么HashMap底层实现用红黑树而不是AVL树" class="headerlink" title="为什么HashMap底层实现用红黑树而不是AVL树"></a>为什么HashMap底层实现用红黑树而不是AVL树</h4><p>严格平衡二叉树：任意结点的左右子树高度差不大于1。因此平衡二叉树不一定是完全二叉树。</p>
<p>最先被发明的 <em>AVL树</em> 是严格的平衡二叉查找树，而后面的平衡查找树并没有严格符合高度差不超过1，只需要大致平衡。</p>
<p>因为维护一个严格平衡的树需要更多的操作，使得维护<strong>近似平衡</strong>的树虽然会增加一些(红黑树中两倍)结点数量产生额外的开销，但相比维护<strong>严格平衡</strong>的树带来的开销还是更小的。</p>
<h4 id="为什么红黑树是近似平衡的"><a href="#为什么红黑树是近似平衡的" class="headerlink" title="为什么红黑树是近似平衡的"></a>为什么红黑树是近似平衡的</h4><p>不失一般性，当一颗红黑树包含m个红结点和n个黑结点，如果我们把这棵树按2-3-4树的形态来看，那么它的高度只跟黑结点有关，即高度等于logn。同时，由于定义了红结点不能直接相连，所以红结点的个数m一定小于n，因此整个树算上红结点的高度一定小于2logn，所以插入删除算法的时间复杂度仍然是O(logn)级别的。</p>
<img src="/2021/02/04/binary-search-tree/RBTree.jpg" class="" title="黑色结点高度">

<h4 id="如果一颗红黑树只有黑色结点会怎样"><a href="#如果一颗红黑树只有黑色结点会怎样" class="headerlink" title="如果一颗红黑树只有黑色结点会怎样"></a>如果一颗红黑树只有黑色结点会怎样</h4><p>根据前面引入的B树与红黑树的关系理解，如果一棵红黑树没有红色结点，也就是说对应B树里的所有结点都是2结点，也就是平衡二叉树。因此一颗只有黑色结点的红黑树就成为了一颗AVL树（严格平衡）。所以串起上文，红色结点就是红黑树<strong>近似平衡</strong>的特性中<strong>不稳定</strong>的那部分(根据上文，最坏情况也可以接受)。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><em>码好再更新，To be continued…</em></p>
]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 快速部署</title>
    <url>/2021/01/23/hexo/</url>
    <content><![CDATA[<p>因为搭建博客的命令步骤都很容易理解，所以本文只是简单的记录过程中用到的命令和配置，可供参考和回查。</p>
<h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo wget https://npm.taobao.org/mirrors/node/latest-v14.x/node-v14.15.4.tar.gz</span><br><span class="line">sudo tar zxvf node-v14.15.4.tar.gz</span><br><span class="line">yum install gcc gcc-c++</span><br><span class="line">mv node-v14.15.4-linux-x64 nodejs</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/nodejs/bin/node /usr/bin/node </span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/nodejs/bin/npm /usr/bin/npm</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/nodejs/bin/npx /usr/bin/npx</span><br><span class="line"><span class="comment"># 换源</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/nodejs/bin/cnpm /usr/bin/cnpm</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo cnpm install -g hexo-cli</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/nodejs/bin/hexo /usr/bin/hexo</span><br></pre></td></tr></table></figure>


<h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 依赖</span></span><br><span class="line">yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc</span><br><span class="line">sudo tar -zxf git-2.21.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> git-2.21.0</span><br><span class="line">sudo make</span><br><span class="line">sudo make install prefix=/usr/<span class="built_in">local</span>/git</span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/git/bin</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 或建立软连接</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/git/bin/git /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"><span class="comment"># 配置身份</span></span><br><span class="line">git config --global user.name <span class="string">&quot;zayeum&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;smilence7@outlook.com&quot;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo hexo init</span><br><span class="line">sudo hexo s  <span class="comment"># start local server</span></span><br><span class="line">sudo npm install hexo-deployer-git --save</span><br><span class="line">sudo vim _config.yml</span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repo: <span class="string">&#x27;https://github.com/Smilence7/Smilence7.github.io&#x27;</span></span><br><span class="line">  branch: <span class="string">&#x27;master&#x27;</span></span><br><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo g  <span class="comment"># generate</span></span><br><span class="line">sudo hexo d  <span class="comment"># deploy</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="多端部署"><a href="#多端部署" class="headerlink" title="多端部署"></a>多端部署</h4><p>主要参考 <a href="https://leooo48.github.io/2017/07/12/hexo-github/">这篇博客</a></p>
<p>从base端上传源文件到github的hexo branch下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># 先删除theme中的.git文件夹</span></span><br><span class="line">sudo git init</span><br><span class="line">sudo git add -A</span><br><span class="line">sudo git commit -m <span class="string">&quot;all blog source files&quot;</span></span><br><span class="line">sudo git branch hexo</span><br><span class="line">sudo git checkout hexo</span><br><span class="line">sudo git remote add origin https://github.com/Smilence7/Smilence7.github.io.git</span><br><span class="line">sudo git push origin hexo -f</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在新环境中安装Git, Nodejs</p>
</li>
<li><p>从github repo中克隆源文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo https://github.com/Smilence7/Smilence7.github.io.git</span><br></pre></td></tr></table></figure></li>
<li><p>安装hexo</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog/<span class="built_in">source</span></span><br><span class="line"><span class="comment"># 创建CNAME文件绑定域名</span></span><br><span class="line">vim CNAME</span><br><span class="line">zayeum.com</span><br><span class="line"><span class="comment"># 在域名管理页面中配置DNS解析</span></span><br><span class="line"><span class="comment"># 解析类型为CNAME，ip为Smilence7.github.io</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA Keymap</title>
    <url>/2021/01/31/idea-keymap/</url>
    <content><![CDATA[<p><em>本文归纳自官方文档与 <a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-introduce.md">IntelliJ-IDEA-Tutorials</a></em></p>
<p><em>待更新，调整只保留常用实用快捷键。</em></p>
<a id="more"></a>

<h2 id="for-Windows"><a href="#for-Windows" class="headerlink" title="for Windows"></a>for Windows</h2><h4 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>Ctrl</kbd> + <kbd>F</kbd></td>
<td>在当前文件进行文本查找</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>R</kbd></td>
<td>在当前文件进行文本替换</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>Z</kbd></td>
<td>撤销</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>C</kbd></td>
<td>复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>X</kbd></td>
<td>剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>D</kbd></td>
<td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>Y</kbd></td>
<td>删除光标所在行 或 删除选中的行</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>W</kbd></td>
<td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>E</kbd></td>
<td>显示最近打开的文件记录列表</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>N</kbd></td>
<td>根据输入的类名查找类文件</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>J</kbd></td>
<td>插入自定义动态代码模板</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>P</kbd></td>
<td>方法参数提示显示</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>U</kbd></td>
<td>前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>B</kbd></td>
<td>进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>/</kbd></td>
<td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F1</kbd></td>
<td>在光标所在的错误代码处显示错误信息</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F3</kbd></td>
<td>调转到所选中的词的下一个引用位置</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F4</kbd></td>
<td>关闭当前编辑的文件</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F9</kbd></td>
<td>执行 Make Project 操作</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F11</kbd></td>
<td>选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F12</kbd></td>
<td>弹出当前文件结构层，用来在当前文件中定位</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>Space</kbd></td>
<td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>Delete</kbd></td>
<td>删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>BackSpace</kbd></td>
<td>删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>1,2,3...9</kbd></td>
<td>定位到对应数值的书签位置</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>左键单击</kbd></td>
<td>在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>光标定位</kbd></td>
<td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>←</kbd></td>
<td>光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>→</kbd></td>
<td>光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>O</kbd></td>
<td>选择可重写的方法</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>I</kbd></td>
<td>选择可继承的方法</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>+</kbd></td>
<td>展开代码</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>-</kbd></td>
<td>折叠代码</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>H</kbd></td>
<td>显示当前类的层次结构</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>T</kbd></td>
<td>版本控制更新项目</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>K</kbd></td>
<td>版本控制提交项目</td>
</tr>
</tbody></table>
<h4 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>Alt</kbd> + <kbd>`</kbd></td>
<td>显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>Q</kbd></td>
<td>弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>F1</kbd></td>
<td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>Enter</kbd></td>
<td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>Insert</kbd></td>
<td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>←/→</kbd></td>
<td>切换当前已打开的窗口中的子视图</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>↑/↓</kbd></td>
<td>当前光标跳转到当前文件的前一个/后一个方法名位置</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>1,2,3...9</kbd></td>
<td>打开/关闭对应视图（1是project）</td>
</tr>
</tbody></table>
<h4 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>Shift</kbd> + <kbd>F2</kbd></td>
<td>跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F3</kbd></td>
<td>在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F7</kbd></td>
<td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F8</kbd></td>
<td>在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F9</kbd></td>
<td>等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F10</kbd></td>
<td>等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F11</kbd></td>
<td>弹出书签显示层</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>End</kbd></td>
<td>选中光标到当前行尾位置</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>Home</kbd></td>
<td>选中光标到当前行头位置</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>左键单击</kbd></td>
<td>点击文件名快速关闭文件</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>滚轮</kbd></td>
<td>横向滚动文件</td>
</tr>
</tbody></table>
<h2 id="for-Mac"><a href="#for-Mac" class="headerlink" title="for Mac"></a>for Mac</h2><h4 id="Editing"><a href="#Editing" class="headerlink" title="Editing"></a>Editing</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>⌃</kbd> + <kbd>Space</kbd></td>
<td>基本的代码补全（补全任何类、方法、变量）</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>Shift</kbd> + <kbd>Space</kbd></td>
<td>智能代码补全（过滤器方法列表和变量的预期类型）</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>Shift</kbd> + <kbd>Enter</kbd></td>
<td>自动结束代码，行末自动添加分号</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>P</kbd></td>
<td>显示方法的参数信息</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>J</kbd></td>
<td>显示当前位置的变量、方法的 Documentation 内容</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F1</kbd></td>
<td>查看外部文档</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>光标停留</kbd></td>
<td>显示代码简要信息</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>F1</kbd></td>
<td>在错误或警告处显示具体描述信息</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>N</kbd></td>
<td>生成代码</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>O</kbd></td>
<td>重写父类方法</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>I</kbd></td>
<td>显示代码简要信息</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>T</kbd></td>
<td>生成包围代码</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>/</kbd></td>
<td>注释/取消注释与行注释</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>/</kbd></td>
<td>注释/取消注释与块注释</td>
</tr>
<tr>
<td><kbd>⌥</kbd> + <kbd>↑</kbd> / <kbd>↓</kbd></td>
<td>跳转代码块</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>Shift</kbd> + <kbd>Q</kbd></td>
<td>显示上下文信息</td>
</tr>
<tr>
<td><kbd>⌥</kbd> + <kbd>Enter</kbd></td>
<td>显示意向动作和快速修复代码</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>L</kbd></td>
<td>格式化代码</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>⌥</kbd> + <kbd>O</kbd</td>
<td>优化import</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>V</kbd></td>
<td>从缓冲区中选择粘贴</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd></td>
<td>切换大小写</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd></td>
<td>智能的将代码拼接成一行</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Enter</kbd></td>
<td>智能的拆分拼接的行</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>-</kbd> / <kbd>=</kbd></td>
<td>展开/折叠代码块</td>
</tr>
</tbody></table>
<h4 id="Search-Replace"><a href="#Search-Replace" class="headerlink" title="Search/Replace"></a>Search/Replace</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>⌘</kbd> + <kbd>G</kbd></td>
<td>查找模式下，向下查找</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd></td>
<td>查找模式下，向上查找</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>R</kbd></td>
<td>文件内替换</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td>
<td>全局查找</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd></td>
<td>全局替换</td>
</tr>
<tr>
<td><kbd>⌥</kbd> + <kbd>F7</kbd></td>
<td>find usage</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>F7</kbd></td>
<td>show usage</td>
</tr>
</tbody></table>
<h4 id="Run-Debug"><a href="#Run-Debug" class="headerlink" title="Run/Debug"></a>Run/Debug</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>⌃</kbd> + <kbd>⌥</kbd> + <kbd>R</kbd></td>
<td>弹出 Run 的可选择菜单</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>⌥</kbd> + <kbd>D</kbd></td>
<td>弹出 Debug 的可选择菜单</td>
</tr>
<tr>
<td><kbd>F7</kbd></td>
<td>步入(step into)</td>
</tr>
<tr>
<td><kbd>F8</kbd></td>
<td>步过(step over)</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F7</kbd></td>
<td>智能步入</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F8</kbd></td>
<td>跳出</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>R</kbd></td>
<td>继续运行</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>F8</kbd></td>
<td>查看所有断点</td>
</tr>
</tbody></table>
<h4 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>⌘</kbd> + <kbd>B</kbd></td>
<td>进入光标所在的方法/变量的接口或是定义处</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>H</kbd></td>
<td>显示当前类的层次结构</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd></td>
<td>显示当前类的层次结构</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础</title>
    <url>/2021/01/28/java-basics/</url>
    <content><![CDATA[<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>括号</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td>正负号、非、反、自增自减</td>
<td>从右向左</td>
</tr>
<tr>
<td>3</td>
<td>*  /  %</td>
<td>从左到右</td>
</tr>
<tr>
<td>4</td>
<td>+(加)  -(减)</td>
<td>从左到右</td>
</tr>
<tr>
<td>5</td>
<td>位移符号</td>
<td>从左到右</td>
</tr>
<tr>
<td>6</td>
<td>&lt; &lt;= &gt; &gt;= instanceof</td>
<td>从左到右</td>
</tr>
<tr>
<td>7</td>
<td>== !=</td>
<td>从左到右</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>9</td>
<td>^ (异或)</td>
<td>从左到右</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>从左到右</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>从左到右</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>14</td>
<td>=  +=  -=  *=  /=  %=  &amp;=  |=  ^=  ~=  &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td>
<td>从右向左</td>
</tr>
</tbody></table>
<a id="more"></a>

<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>​        多个方法可以有相同的名字和不同的参数，这种特征叫做<strong>重载</strong>。编译器通过各方法给出的参数与调用时填入的参数类型进行匹配来挑选出合适的方法，这个过程叫做<strong>重载解析</strong>(overloading resolution)。</p>
<p>​        方法的<strong>签名</strong>(signature)包括方法名和参数类型，而不包括返回值类型。</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ol>
<li><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
</li>
<li><p>抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>
</li>
<li><p>构造方法无法被重写</p>
</li>
<li><p>如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
</li>
</ol>
<h3 id="面向对象编程三大特性"><a href="#面向对象编程三大特性" class="headerlink" title="面向对象编程三大特性"></a>面向对象编程三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><em>封装</em> 把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><em>继承</em> 是使用已存在的类的定义作为基础建立新类的技术，使用继承我们能够非常方便地复用以前的代码。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p><em>多态</em> 可以通过继承和接口两种方式实现</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>被static修饰的变量是类变量，在被JVM加载时跟随class信息放入栈空间，可以被修改，但所有实例都会共享同一份值。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><p>final关键词表示一个常量，它的值在初始化之后就不能再修改。</p>
<p>被final修饰的静态变量只能在<strong>声明时</strong>或<strong>静态初始化块</strong>内初始化；</p>
<p>被final修饰的非静态变量还可以在<strong>构造器</strong>中初始化；</p>
<p>被final修饰的局部变量可以在生命周期内的任意时候初始化。</p>
<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><p>final修饰的方法不能被子类重写</p>
<p>final修饰的方法可以被重载</p>
<h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h4><p>final修饰的类不能被子类继承，如果使用private和final修饰final类的成员变量，且只提供getter方法，那么这个类就是不变类。</p>
<h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><p>Java中的参数变量是按值传递(called by value)的，通俗的说，不管参数是<strong>基础数据类型</strong>还是<strong>对象引用</strong>，方法接收的参数 <em>永远</em> 是参数值的副本。</p>
<p>也就是说，如果我们在方法内修改参数的值，那么作为局部变量的副本参数在方法完成后就被丢弃了，并不会影响方法外原参数的值。不管是修改基础数据类型参数，还是修改对象引用参数，都只是作用在副本上；</p>
<p>但是，如果要修改引用的对象内的属性，是可以生效的：因为 <strong>对象引用的副本</strong> 与 <strong>原对象引用</strong> 指向的是同一个对象，我们是根据这个引用找到对象并修改对象的值，并没有试图修改<strong>原对象引用</strong>的值。</p>
<p>举一个例子：如果a是person对象的引用，方法接收的参数是a的副本b，那么a和b都引用的是person对象。此时我们无法通过让b引用别的对象（通过修改b的值），来让a引用别的对象（来修改a的值）；但我们能通过b修改person对象的属性，因为不管对b的引用操作还是对a的引用操作，最终都是对person操作。</p>
<h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>一个很容易忽视的细节是，局部变量必须初始化才能使用，而类中的字段如果不初始化值，会自动初始化为默认值(0, false, null)。例如在Java8的HashMap源码中无参构造器就没有为threshold变量初始化，但其在后续的逻辑中以0生效。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>如果一个类没有写任何构造器，就会有一个隐式的无参构造器，将所有实例变量设置为默认值；</p>
<p>如果写了有参构造器，但没有无参构造器，在调用无参构造器时就会产生错误。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>嵌套类(nested class)分为静态和非静态两种，分别称为静态嵌套类(static nested class)和内部类(Inner class)。</p>
<h4 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1. 成员内部类"></a>1. 成员内部类</h4><p>在一个类内定义另一个内，内部的这个类就叫成员内部类，相对地，外层的类叫外部类。</p>
<ul>
<li><p>成员内部类可以访问外部类的<strong>所有</strong>成员属性和方法（包括private和static成员），因为编译后的字节码为内部类构造器传入了指向外部类对象的引用（指针）。</p>
</li>
<li><p>当成员内部类和外部类有同名的成员变量或方法时，默认调用的是内部类的成员，如果要调用外部类的同名成员，需要使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.xxxVariable</span><br><span class="line">外部类.<span class="keyword">this</span>.xxxMethod</span><br></pre></td></tr></table></figure></li>
<li><p>而外部类访问内部类的成员时，需要先创建外部类的对象，再通过外部类对象创建内部类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</span><br></pre></td></tr></table></figure></li>
<li><p>要在其他地方创建一个内部类的对象，则需要先创建外部类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//多例模式：</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();  <span class="comment">//先创建Outter对象outter  </span></span><br><span class="line">        Outter.Inner inner = outter.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;  <span class="comment">//通过outter对象创建其内部类对象inner</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//单例模式：</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2. 静态内部类"></a>2. 静态内部类</h4><p>静态内部类 (static nested class) 就是静态的成员内部类 (Inner class)，与之不同的是静态内部类不需要依赖与外部类，相应地，静态内部类只能访问外部类的静态成员（因为非静态成员依附于具体的对象）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3. 局部内部类"></a>3. 局部内部类</h4><p>定义在一个方法或作用于里面的类，相当于一个局部变量，不能有权限修饰符，仅限于方法或作用域内部访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4. 匿名内部类"></a>4. 匿名内部类</h4><p>匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>匿名内部类/局部内部类只能访问局部final变量。因为内部类和外部类的生命周期可能不同，编译器会为内部类传入变量的拷贝值，同时，为了防止数据不一致，必须使用final修饰来防止内部类改变这个值。</li>
</ul>
<h2 id="Java-源码"><a href="#Java-源码" class="headerlink" title="Java 源码"></a>Java 源码</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>我们知道HashMap通过对key计算哈希值来高效存取映射关系，当遇到哈希冲突，对应位置的结点会以链表的形式向下扩展。这里具体聊一下Java 8中，HashMap的实现逻辑。</p>
<p>首先，在调用构造函数时，如果没有指定初始大小和装载因子，会使用默认的装载因子0.75、初始阈值0、初始大小16。其中<strong>阈值</strong>的含义是当装填的因子超过该值时就扩容。注意：构造函数只是设定了参数值，并没有创建数组。</p>
<p>当调用<code>put()</code>方法时，实际上执行的是<code>putVal()</code>方法，<code>put()</code>方法帮我们隐藏了<code>onlyIfAbsent</code>和<code>evict</code>参数。前者为true表示遇到相同键值不进行覆盖，默认为false；后者为false表示table在创造模式(creation mode)，默认为true。</p>
<p>在<code>putVal()</code>方法中，首先判断table（hashmap数据结构的变量名）是否为null，如果为null会先通过<code>resize()</code>方法创建一个初始table。</p>
<p><code>resize()</code>方法用于扩容和初始化，具体来说，是根据table.length和threshold两个参数判断：</p>
<ul>
<li>如果table.length == 0，说明哈希表还没有创建，此时分两种情况：<ul>
<li>threshold &gt; 0：把容量设置成threshold的大小；</li>
<li>threshold == 0：把容量设置成默认的16，threshold设置成装载因子*16；</li>
</ul>
</li>
<li>如果table.length &gt; 0，说明是需要扩容，也分两种情况：<ul>
<li>容量已经超过最大容量的阈值，不能再扩容了，只能把threshold设置成MAX_VALUE，继续使用剩下的空间；</li>
<li>容量还没超过最大值，将容量和threshold都扩大一倍。</li>
</ul>
</li>
</ul>
<p>定好新的参数后，创建一个新的数组，把旧数组的数据拷贝到新数组上。</p>
<p>接着，通过对key的哈希值hash取table.length的模来定位：</p>
<ul>
<li>如果这个位置是空的，在这个位置创建一个键值对结点；</li>
<li>否则存在三种情况：<ul>
<li>哈希值相等，key值也相等，说明是存在相同的键，应该覆盖；</li>
<li>数组的这个位置存储的不是Node&lt;K, V&gt;对象，而是TreeNode&lt;K, V&gt;对象，使用<code>putTreeVal()</code>方法来插入值；</li>
<li>否则，说明发生了哈希冲突（碰撞），应该把值加在该位置链表的末尾。插入之后，如果链表长度超过了<strong>树化</strong>的阈值，则将链表Node转为树TreeNode。</li>
</ul>
</li>
</ul>
<p>这其中有几点需要解释：</p>
<ol>
<li>HashMap的底层实现中，如果一个位置的链表长度超过阈值(8)，就会转为树结构（树化）；</li>
<li>链表结构是自定义的Node&lt;K, V&gt;类，实现自Map.Entry&lt;K, V&gt;接口；树结构是自定义的TreeNode&lt;K, V&gt;类，继承自LinkedHashMap.Entry&lt;K, V&gt;类，而LinkedHashMap的Entry类实际上就是继承自HashMap本身的Node类；简单地说，它们的关系是：<ul>
<li>Map.Entry&lt;K, V&gt;接口  &lt;=  HashMap.Node&lt;K, V&gt;类  &lt;=  LinkedHashMap.Node&lt;K, V&gt;类  &lt;=  HashMap.TreeNode&lt;K, V&gt;类</li>
</ul>
</li>
</ol>
<h4 id="树化逻辑"><a href="#树化逻辑" class="headerlink" title="树化逻辑"></a>树化逻辑</h4><p><em>待更新</em></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Singleton Pattern</title>
    <url>/2021/01/28/singleton-pattern/</url>
    <content><![CDATA[<p>This post references <a href="https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples">JournalDev</a>, and was written in English for personnal practicing.</p>
<h1 id="Singleton-Pattern"><a href="#Singleton-Pattern" class="headerlink" title="Singleton Pattern"></a>Singleton Pattern</h1><p>Singleton pattern restricts the instantiation of a class and ensures that only one instance of the class exists in the Java virtual machine.</p>
<p>To implement a singleton pattern, we should follow three concepts.</p>
<ul>
<li>Private constructor to prevent new instantiation act from other class.</li>
<li>Private static variable of the same class that is the only instance of the class.</li>
<li>Public static method that returns the instance of the class, providing the only way for outer programs to get the instance of the singleton class.</li>
</ul>
<a id="more"></a>

<h2 id="Implemention-practices"><a href="#Implemention-practices" class="headerlink" title="Implemention practices"></a>Implemention practices</h2><h3 id="1-Eager-initialization"><a href="#1-Eager-initialization" class="headerlink" title="1. Eager initialization"></a>1. Eager initialization</h3><p>In eager initialization, the instance of singleton class is created when class is loaded by Java virtual machine. While it is the easiest way to create a singleton class, it has a drawback that instance is created even if it may not be used by any program.</p>
<p>Implemention is as follows.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerInitializedSingleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerInitializedSingleton instance = <span class="keyword">new</span> EagerInitializedSingleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerInitializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerInitializedSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Static-block-initialization"><a href="#2-Static-block-initialization" class="headerlink" title="2. Static block initialization"></a>2. Static block initialization</h3><p>Static block initialization is similar to eager initialization, but implement by using static block and exception throwing.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBlockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StaticBlockSingleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticBlockSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> StaticBlockSingleton();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Exception occured in creating singleton instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticBlockSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Lazy-Initialization"><a href="#3-Lazy-Initialization" class="headerlink" title="3. Lazy Initialization"></a>3. Lazy Initialization</h3><p>Lazy initialization implementation only creates instance at the first time accessed.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitializedSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyInitializedSingleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInitializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInitializedSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazyInitializedSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This implemention is not thread-safe. When two threads are inside the if condition at the same time, they will get different instances of the “singleton” class.</p>
<h3 id="4-Thread-Safe-Singleton"><a href="#4-Thread-Safe-Singleton" class="headerlink" title="4. Thread Safe Singleton"></a>4. Thread Safe Singleton</h3><p>To make above program thread-safe, the easiest way is adding <code>synchronized</code> to the method <code>getInstance()</code>. But notice that we only need to create the instance at the first time (when first few thread in the if condition) method is called. </p>
<p>To avoid extra time-consuming, <strong>double checked locking</strong> principle is used. In this approach, synchronized block is used outside the instance initialization code, with two if condition inside and outside the synchronized block respectively.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitializedSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyInitializedSingleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInitializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadSafeSingleton <span class="title">getInstanceUsingDoubleLocking</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadSafeSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> ThreadSafeSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The double check part is to prevent later threads in first <code>if</code> block (which wait and get the lock) from creating new instances.</p>
<h3 id="5-Bill-Pugh-Singleton-Implementation"><a href="#5-Bill-Pugh-Singleton-Implementation" class="headerlink" title="5. Bill Pugh Singleton Implementation"></a>5. Bill Pugh Singleton Implementation</h3><p>Still, above implemention used to fail in certain scenarios where large amount of threads try to get the instance simultaneously. So Bill Pugh came up with a different approach to create the Singleton class using an <a href="https://www.journaldev.com/996/java-inner-class">inner static helper class</a>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillPughSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BillPughSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BillPughSingleton INSTANCE = <span class="keyword">new</span> BillPughSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BillPughSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingletonHelper is a static nested/inner class, which gets loaded only when someone calls the <em>getInstance</em> method.</p>
<h3 id="6-Enum-Singleton"><a href="#6-Enum-Singleton" class="headerlink" title="6. Enum Singleton"></a>6. Enum Singleton</h3><p>Enum singleton is used to overcome <strong><em>reflection</em></strong> problem (which can destroy singleton pattern we talked above).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-SerializedSingleton"><a href="#7-SerializedSingleton" class="headerlink" title="7. SerializedSingleton"></a>7. SerializedSingleton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializedSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7604766932017737115L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SerializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SerializedSingleton instance = <span class="keyword">new</span> SerializedSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SerializedSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The problem with serialized singleton class is that whenever we deserialize it, it will create a new instance of the class.</p>
</blockquote>
<p><strong><em>Mark to update later.</em></strong></p>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Design Patterns</tag>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 2</title>
    <url>/2021/02/01/spring-boot/</url>
    <content><![CDATA[<h3 id="Web-开发"><a href="#Web-开发" class="headerlink" title="Web 开发"></a>Web 开发</h3><h4 id="1-静态资源访问"><a href="#1-静态资源访问" class="headerlink" title="1. 静态资源访问"></a>1. 静态资源访问</h4><h5 id="1-1-路径"><a href="#1-1-路径" class="headerlink" title="1.1 路径"></a>1.1 路径</h5><p>静态资源路径包括 <code>/static</code>、 <code>/public</code>、 <code>/resources</code> 、<code>/META-INF/resources</code> ，访问 <em>根路径 + 静态资源名</em> 即可访问对应的静态资源，如： /picture123.jpg</p>
<p>其原理是使用静态映射/**，当访问请求找不到对应的Controller，再交给静态资源处理器，如果静态资源处理器也找不到就返回404。</p>
<p>在application.yaml文件中使用<code>  static-path-pattern</code>修改配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">mvc:</span></span><br><span class="line">	<span class="attr">static-path-pattern:</span> <span class="string">/resources/**</span></span><br></pre></td></tr></table></figure>
<p>相应地，<code>static-location: [classpath: /xxx/]</code> 用来重新设置多个静态资源路径</p>
<a id="more"></a>









]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile 关键字</title>
    <url>/2021/02/07/volatile/</url>
    <content><![CDATA[<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>volatile解决的问题：针对变量的轻量级同步解决方案。</p>
<p>由于cpu读写速度与主存之间存在巨大的差异，所以Java的内存模型中，每个cpu的线程把共享变量从主存拷贝到自己cpu内的工作内存，来保证处理速度。这就会产生各线程的工作内存间数据不可见的问题。解决数据可见性，就解决了针对变量级别的同步机制。</p>
<h4 id="volatile机制的原理"><a href="#volatile机制的原理" class="headerlink" title="volatile机制的原理"></a>volatile机制的原理</h4><ol>
<li>当对volatile变量进行写操作时，JVM会向处理器发送带Lock前缀的指令，处理器收到这种指令会马上将本地缓存写回主存；</li>
<li>每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是否失效；</li>
<li>处理器将过期的缓存标记，当要用到对应数据时，从主存中把新数据读到本地缓存中，防止读脏数据。</li>
</ol>
<a id="more"></a>

<h4 id="volatile机制下的处理过程"><a href="#volatile机制下的处理过程" class="headerlink" title="volatile机制下的处理过程"></a>volatile机制下的处理过程</h4><ol>
<li>带Lock前缀的指令触发处理器缓存写回主存；</li>
<li>其他处理器感知到，把自己的缓存标记为失效；</li>
<li>当用到的变量是失效的，处理器从主存中重新读取该数据到本地缓存。</li>
</ol>
<h4 id="volatile的happens-before"><a href="#volatile的happens-before" class="headerlink" title="volatile的happens-before"></a>volatile的happens-before</h4><p>对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</p>
<h4 id="volatile的实现方法："><a href="#volatile的实现方法：" class="headerlink" title="volatile的实现方法："></a>volatile的实现方法：</h4><p>JMM在保证happens-before关系的前提下，尽可能允许编译器和处理器对指令序列重排序。为了实现这一点，做了两件事：</p>
<ol>
<li>创造出<strong>内存屏障</strong>指令，根据读写顺序对应四种指令，分别是LoadLoad, StoreStore, LoadStore, StoreLoad。通过在指令序列中间插入这些屏障指令，来禁止特定类型的处理器重排序；</li>
<li>找到所有不符合happens-before原则的指令序列（下表）。需要注意的是，编译器难以做到为一个程序找到能插入最少屏障次数的重排序方案，所以为了覆盖图中的情况，并且简化逻辑，用4条规则来覆盖这些情况（覆盖范围会多出一点，但保证了规则的简单）：<ul>
<li><strong>volatile写</strong>操作<strong>前</strong>插入StoreStore屏障</li>
<li><strong>volatile写</strong>操作<strong>后</strong>插入StoreLoad屏障</li>
<li><strong>volatile读</strong>操作<strong>后</strong>插入LoadLoad屏障</li>
<li><strong>volatile读</strong>操作<strong>后</strong>插入LoadStore屏障</li>
</ul>
</li>
</ol>
<table>
   <tr>
      <td colspan="1">是否能重排序</td>
      <td colspan="3">第二个操作</td>
   </tr>
   <tr>
      <td>第一个操作</td>
      <td>普通读/写</td>
      <td>volatile读</td>
      <td>volatile写</td>
   </tr>
   <tr>
      <td>普通读/写</td>
      <td></td>
      <td></td>
      <td>x</td>
   </tr>
   <tr>
      <td>volatile读</td>
      <td>x</td>
      <td>x</td>
      <td>x</td>
   </tr>
   <tr>
      <td>volatile写</td>
      <td></td>
      <td>x</td>
      <td>x</td>
   </tr>
</table>





<style>
  table {
    table-layout: fixed;
    width: 1000px; /*表格宽度*/
    max-width: 1000px; /*表格最大宽度，避免表格过宽*/
    border: 1px solid #dedede; /*表格外边框设置*/
    margin: 15px auto; /*外边距*/
    border-collapse: collapse; /*使用单一线条的边框*/
    word-break:break-all;
    word-wrap:break-word;
    empty-cells: show; /*单元格无内容依旧绘制边框*/
  }
  table th,
  table td {
    height: 35px; /*统一每一行的默认高度*/
    border: 1px solid #dedede; /*内部边框样式*/
    padding: 0 10px; /*内边距*/
    text-align: center !important;
  }
  table th {
    font-weight: bold; /*加粗*/
    text-align: center !important; /*内容居中，加上 !important 避免被 Markdown 样式覆盖*/
    background: rgba(158,188,226,0.2); /*背景色*/
  }
  table tbody tr:nth-child(2n) {
    background: rgba(158,188,226,0.12);
  }
  table th {
    white-space: nowrap; /*表头内容强制在一行显示*/
  }
  table th:nth-of-type(1){
    width: 20%;
  }
  table th:nth-of-type(2){
    width: 20%;
  }
  table th:nth-of-type(3){
    width: 20%;
  }
  table th:nth-of-type(4){
    width: 40%;
  }
</style>]]></content>
      <categories>
        <category>Multithread &amp; Concurrency</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Multithread &amp; Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress Docker部署</title>
    <url>/2021/01/23/wordpress/</url>
    <content><![CDATA[<h4 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>


<h4 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown -R nz /usr/<span class="built_in">local</span>/bin</span><br><span class="line">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose <span class="comment">#把它放入PATH中，这样才能sudo</span></span><br></pre></td></tr></table></figure>


<h4 id="卸载-docker"><a href="#卸载-docker" class="headerlink" title="卸载 docker"></a>卸载 docker</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum list installed|grep docker</span><br><span class="line">yum -y remove</span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>


<h4 id="卸载-docker-compose"><a href="#卸载-docker-compose" class="headerlink" title="卸载 docker-compose"></a>卸载 docker-compose</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>


<h4 id="docker-国内镜像"><a href="#docker-国内镜像" class="headerlink" title="docker 国内镜像"></a>docker 国内镜像</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>


<h4 id="修改docker内的mysql表ip地址"><a href="#修改docker内的mysql表ip地址" class="headerlink" title="修改docker内的mysql表ip地址"></a>修改docker内的mysql表ip地址</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it my_wordpress_db_1 bash</span><br><span class="line">mysql -u wordpress -p</span><br><span class="line">Enter password: wordpress</span><br><span class="line">show databases;</span><br><span class="line">USE wordpress</span><br><span class="line">select * from wp_options limit 2;</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> UPDATE wp_options SET option_value=<span class="string">&quot;zayeum.com&quot;</span> WHERE option_name=<span class="string">&quot;siteurl&quot;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> UPDATE wp_options SET option_value=<span class="string">&quot;zayeum.com&quot;</span> WHERE option_name=<span class="string">&quot;home&quot;</span>;</span></span><br><span class="line">update wp_options set option_value=&#x27;http://www.zayeum.com:80&#x27; where option_name in (&#x27;siteurl&#x27;,&#x27;home&#x27;);</span><br><span class="line">update wp_options set option_value=&#x27;localhost:9977&#x27; where option_name in (&#x27;siteurl&#x27;,&#x27;home&#x27;);</span><br></pre></td></tr></table></figure>


<h4 id="Docker-服务管理"><a href="#Docker-服务管理" class="headerlink" title="Docker 服务管理"></a>Docker 服务管理</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl restart  dockers</span><br><span class="line">sudo systemctl stop docker</span><br><span class="line">sudo service docker restart</span><br><span class="line">sudo service docker stop</span><br><span class="line">sudo systemctl daemon-reload  <span class="comment"># 重启守护进程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start firewalld</span><br><span class="line"></span><br><span class="line">sudo firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">sudo firewall-cmd  --reload</span><br><span class="line">sudo firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>


<h4 id="Docker-容器管理"><a href="#Docker-容器管理" class="headerlink" title="Docker 容器管理"></a>Docker 容器管理</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker stop $(docker ps -aq)</span><br><span class="line">sudo docker container prune</span><br><span class="line">sudo docker image prune</span><br><span class="line">sudo docker-compose down</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/01/31/computer-network/</url>
    <content><![CDATA[<h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p><em>&#42;本节内容参考中英文维基百科</em>。</p>
<h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>OSI Model是Open System Interconnection Model的缩写，顾名思义，OSI模型是一种为规范不同设备内部结构和技术的通信过程而产生的模型。</p>
<p>引入了服务、接口、协议、分层的概念，实际的模型结构包含七层：</p>
<img src="/2021/01/31/computer-network/OSI.png" class="" title="OSI模型">

<a id="more"></a>

<h3 id="逐层概览"><a href="#逐层概览" class="headerlink" title="逐层概览"></a>逐层概览</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul>
<li>提供为应用软件设计的<strong>接口</strong>，以设置与另一应用软件之间的通信。</li>
<li>HTTP, HTTPS, FTP, SSH, SMTP, POP3, IMAP4</li>
</ul>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><ul>
<li>把数据转换为网络服务通用格式，包括字符编码、数据压缩、编码/解码。</li>
</ul>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><ul>
<li>负责在数据传输中维护计算机网络中两台计算机之间的通信连接和数据交换。</li>
<li>SMTP, DNS</li>
</ul>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul>
<li>接收数据流并将其分成<strong>数据段</strong>，把传输表头（TH）加至数据段。传输表头包含了所使用的协议等发送信息。</li>
<li>数据段使网络传输能够多路复用</li>
<li>TCP, UDP</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>决定数据的路径选择和转寄，将网络表头（NH）加至<strong>数据包</strong>，以形成分组。网络表头包含了网络资料。</li>
<li>管理多结点的网络，包括寻址、路由等。</li>
<li>IP, ICMP, ARP, RARP, AKP, UUCP</li>
</ul>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ul>
<li><p>负责物理层连接的两个结点的<strong>数据帧</strong>传输。</p>
</li>
<li><p>当表头和表尾被加至数据包时，会形成<strong>数据帧</strong>（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。</p>
</li>
<li><p>以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p>
</li>
</ul>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul>
<li>提供两个网络媒体实际连接的所有物理介质。</li>
<li>包括针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</li>
<li>IEEE 802.1A</li>
</ul>
<p>OSI模型并不是一个协议，而是一个制定协议时参考的框架模型。</p>
<h2 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h2><p><em>&#42;本节内容参考中英文维基百科、<a href="https://www.cnblogs.com/onepixel/p/7092302.html">一像素的博客</a>  以及 <a href="https://zhuanlan.zhihu.com/p/59066874">杰杰的文章</a> 。</em></p>
<h3 id="模型结构-1"><a href="#模型结构-1" class="headerlink" title="模型结构"></a>模型结构</h3><p>个人理解：TCP/IP是指Transmission Control Protocol和Internet Protocol， 而我们常说的TCP/IP实际上是一组协议栈(protocol stack)，国外一般称为DoD模型。</p>
<p>基本框架：</p>
<img src="/2021/01/31/computer-network/TCPIP.jpg" class="" title="TCP&#x2F;IP协议栈">

<p>这种模型参考了OSI模型的设计，将7层精简成4层。</p>
<h3 id="逐层概览-1"><a href="#逐层概览-1" class="headerlink" title="逐层概览"></a>逐层概览</h3><h4 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h4><ul>
<li>对应OSI中的应用层、表示层、会话层</li>
<li>应用层定义数据格式，并按照对应的格式解析数据</li>
</ul>
<h4 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h4><ul>
<li><p>对应OSI中的传输层</p>
</li>
<li><p>传输层定义了端口，同一台主机上的每个应用程序都要指定唯一端口号，让主机能确定是哪个应用程序要接收这个包。</p>
</li>
<li><p><strong>UDP协议</strong>，要求在传输数据中加上端口号：</p>
<ul>
<li>首部<strong>8字节</strong>，包括源端口和目标端口；</li>
<li>数据最大65527个字节；</li>
</ul>
</li>
<li><p><strong>TCP协议</strong>解决UDP协议可靠性差的问题，因为UDP协议没有确认机制，无法确定对方是否收到数据；而TCP协议是面向连接的、可靠的、基于字节流的通信协议：</p>
<ul>
<li><p>三次握手建立连接，四次握手关闭连接</p>
</li>
<li><p>TCP数据包和UDP数据包一样，只是长度没有限制，但通常不会超过下一层（网络层）数据包的长度，确保不会再被分割；</p>
</li>
<li><p>TCP比UDP传输速度慢，消耗资源多，但更可靠。</p>
</li>
</ul>
</li>
</ul>
<h4 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>对应OSI中的网络层；</li>
<li>引入<strong>IP协议</strong>(Internet Protocol)指定一套IP地址，用来判断主机所属的网络和在网络内的地址：<ul>
<li>IP地址有IPv4和IPv6两个版本，其中IPv4是32位地址，分为四部分，每部分用0~255的十进制数字表示；IPv6有128位地址；</li>
<li>以C类地址为例：<ul>
<li>IP地址前三部分（24位）表示网络地址，第四部分（8位）表示主机地址；</li>
<li>子网掩码前三部分为255（24位都为1），第四部分为0（8位都为0）；</li>
<li>把子网掩码和IP地址按位与就能得到网络地址；</li>
</ul>
</li>
<li>通过比较两个网络地址就能判断两台主机是否在同一个子网。</li>
</ul>
</li>
<li>引入<strong>ARP协议</strong>(Address Resolution Protocol)根据IP地址获取MAC地址：<ul>
<li>ARP获取到目标IP地址，如果在缓存中找不到对应的MAC地址，就发起一个数据包来<strong>请求</strong>目标IP对应的MAC地址，并等待接收返回消息；</li>
<li>这个请求数据包与普通数据包一样在链路层包装为数据帧（见下段），通过以太网协议<strong>广播</strong>到子网内的所有主机；</li>
<li>主机收到请求，比对首部的IP地址，如果匹配就发回自己的MAC地址，否则丢弃数据包；</li>
<li>ARP接受到发回的MAC地址，存入缓存中。</li>
</ul>
</li>
<li>引入<strong>路由协议</strong>，因为ARP只能提供<strong>子网内</strong>的MAC地址解析。<ul>
<li>先通过IP协议判断两台主机是否在同一个子网中：<ul>
<li>如果在，则直接使用ARP协议查询MAC地址；</li>
<li>否则，把ARP数据包转发给子网的网关进行路由（网关可以连接到其他子网的网关）。</li>
</ul>
</li>
<li>经过多次路由转发，最后到达目标IP所在的子网，子网内再用ARP广播形式发送，并以相同的方式发回源IP地址。</li>
</ul>
</li>
<li>在网络层包装的数据包叫<strong>IP数据包</strong>，因为它主要包含IP地址信息。IP数据包包含：<ul>
<li><strong>20字节</strong>的首部，主要包含目标IP地址和源IP地址；</li>
<li>65515字节的数据。</li>
</ul>
</li>
</ul>
<h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><ul>
<li>对应OSI中的数据链路层、物理层；</li>
<li>将0、1电信号分组，按分组顺序依次发送；</li>
<li>以太网协议：规定一个分组为一个<strong>数据帧</strong>，并以MAC地址作为网卡间通信的唯一身份标识包含：<ul>
<li>14字节的<strong>首部</strong>，包含目标MAC地址，源MAC地址和帧类型；</li>
<li>46~1500字节的<strong>数据</strong>；</li>
<li>4字节的<strong>尾部</strong>，包含校验序列。</li>
</ul>
</li>
<li>以太网采用<strong>广播</strong>形式把数据帧发送给所有<strong>子网内</strong>的主机，每台主机比对目标MAC地址，当匹配时就保留，否则丢弃。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p><strong>“ 配送车就是物理介质，配送站就是网关， 快递员就是路由器，收货地址就是IP地址，联系方式就是MAC地址。”</strong></p>
<p><strong>当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。</strong></p>
</blockquote>
<h3 id="ARP扩展知识"><a href="#ARP扩展知识" class="headerlink" title="ARP扩展知识"></a>ARP扩展知识</h3><p>ARP请求包在通信时也需要经过链路层包装成数据帧，但又不知道目标MAC地址，怎么办呢？</p>
<p>以太网数据帧首部用<strong>帧类型</strong>来区分ARP请求包和IP数据包，ARP请求包的帧类型为0x0806，而IP数据包的帧类型为0x0800；而ARP请求包内的目标MAC地址值为FF-FF-FF-FF-FF-FF。</p>
<img src="/2021/01/31/computer-network/ARP.png" class="" title="ARP数据包封装在以太网帧的格式">

<ul>
<li><p>硬件类型，表示要知道目标网卡的硬件类型，其中，值为1表示以太网地址；</p>
</li>
<li><p>协议类型，0x0800表示IP协议，其他还可能是ICMP/IGMP协议等；</p>
</li>
<li><p>硬件地址长度，指出该报文中硬件地址的长度，对于以太网硬件类型，它的值为6；</p>
</li>
<li><p>协议地址长度，如果是ARP协议、IP协议等，该值为4；</p>
</li>
<li><p>op字段，用于记录ARP操作的类型，分别是：</p>
<ul>
<li>ARP请求，其值为1。</li>
<li>ARP应答，其值为2。</li>
<li>RARP请求，其值为3。</li>
<li>RARP应答，其值为4。</li>
</ul>
<p>其中RARP是逆地址解析协议，已经基本被淘汰。</p>
</li>
</ul>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>当客户端要向服务器发送请求，首先需要通过三次握手协议建立TCP连接：</p>
<ul>
<li>Client端告诉Server端将要开始发送数据，并告知将要使用的同步位和序列号(SYN_bit=1,  seq_A=x)；</li>
<li>Server端发回自己将要使用的同步位和序列号(SYN_bit=1, seq=y)，以及对Client端的确认信号(ACK_A=x+1)；</li>
<li>Client端发回确认信号ACK_B=y+1，表示双方的连接是稳定的，并将开始发送数据。</li>
</ul>




<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>当客户端和服务端完成了通信，需要关闭连接时，采用四次挥手协议：</p>
<p>如果是Client端向Server端提出关闭连接（反之同理），</p>
<ul>
<li><p>Client端发送FIN_A报文，表示自己这边的数据已经发完了，进入FIN_WAI_1状态；</p>
</li>
<li><p>Server端收到FIN_A报文，发回ACK_A报文，作为收到FIN报文的确认；</p>
<ul>
<li>Client端收到ACK_A报文，进入FIN_WAIT_2状态，继续接收Server端的数据；</li>
</ul>
</li>
<li><p>Server端的数据也发完了，向Client端发送FIN_B报文；</p>
</li>
<li><p>Client端收到FIN_B报文也向Server端返回一个ACK_B报文，通知对方准备可以关闭连接了，自己进入TIME_WAIT状态；</p>
<ul>
<li><p>Server端收到ACK_B报文，关闭连接；</p>
</li>
<li><p>Client端TIME_WAIT时间用完，关闭连接。</p>
</li>
</ul>
</li>
</ul>




<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p><em>代填</em></p>
<h3 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h3><p><em>代填</em></p>
<h3 id="值得注意的问题"><a href="#值得注意的问题" class="headerlink" title="值得注意的问题"></a>值得注意的问题</h3><h4 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h4><p>因为建立连接时，当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p>
<p>但是关闭连接时，当Server端收到FIN报文时，先回复ACK报文。等到Server端所有的数据都发送完了，才发送FIN报文。因为两个报文不能一起发送。故需要四步握手。</p>
<h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="Request-报文"><a href="#Request-报文" class="headerlink" title="Request 报文"></a>Request 报文</h3><p>状态行、请求头、消息主体：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">method</span>&gt;</span> <span class="tag">&lt;<span class="name">request-URL</span>&gt;</span> <span class="tag">&lt;<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">headers</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">entity-body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中method有四种：GET, POST, PUT, DELETE, 分别是对资源的查增改删；</p>
<p>URL就是资源的地址，描述method的操作对象。</p>
<p>例如GET请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;books&#x2F;?sex&#x3D;man&amp;name&#x3D;Professional HTTP&#x2F;1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko&#x2F;20050225 Firefox&#x2F;1.0.1</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>
<p>POST请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko&#x2F;20050225 Firefox&#x2F;1.0.1</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">sex&#x3D;man&amp;name&#x3D;Professional</span><br></pre></td></tr></table></figure>
<p>GET请求的长度受到特定浏览器及服务器的限制；POST请求理论上没有大小限制，服务器处于安全因素考虑会有一定的限制。</p>
<p>POST的content-type 可以是 <code>application/x-www-form-urlencoded</code> 或<code>multipart/form-data</code>。前者如<code>sex=man&amp;name=Professional</code>，后者是指定一个boundary，消息主体通过*<code>--boundary</code><em>分隔不同字段，并以</em><code>--boundary--</code>*结束。还有新的content-type，如<code>application/json</code>, <code>text/xml</code>,  <code>application/x-protobuf</code>。</p>
<h3 id="Response-报文"><a href="#Response-报文" class="headerlink" title="Response 报文"></a>Response 报文</h3><p>状态行、响应头、响应正文（对应Request），如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line"></span><br><span class="line">Server:Apache Tomcat/5.0.12  </span><br><span class="line">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class="line">Content-Length:112</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>...</span><br></pre></td></tr></table></figure>
<p>状态码有：</p>
<ul>
<li><code>200 OK</code> 客户端请求成功</li>
<li><code>301 Moved Permanently</code> 请求永久重定向</li>
<li><code>302 Moved Temporarily</code> 请求临时重定向</li>
<li><code>304 Not Modified</code> 文件未修改，可以直接使用缓存的文件。</li>
<li><code>400 Bad Request</code> 由于客户端请求有语法错误，不能被服务器所理解。</li>
<li><code>401 Unauthorized</code> 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li>
<li><code>403 Forbidden</code> 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li><code>404 Not Found</code> 请求的资源不存在，例如，输入了错误的URL</li>
<li><code>500 Internal Server Error</code> 服务器发生不可预期的错误，导致无法完成客户端的请求。</li>
<li><code>503 Service Unavailable</code> 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。</li>
</ul>
<h3 id="Keep-alive"><a href="#Keep-alive" class="headerlink" title="Keep-alive"></a>Keep-alive</h3><p>HTTP1.0中，默认采取完成“请求-应答”后关闭连接的方式，也就是HTTP协议的无连接特点。而Keep-Alive模式不会立刻关闭连接，避免了重新建立连接。如果客户端浏览器支持Keep-Alive，就在请求头中设置字段 <code>Connection: Keep-Alive</code>，如果服务器也支持这种模式，会在相应头中也设置同样的字段，这样Keep-Alive模式就开启了。</p>
<p>HTTP1.1中，默认采取Keep-Alive模式，如果设置字段 <code>Connection: close</code>才关闭。而目前大多数浏览器都是用HTTP1.1协议，这种情况下能否开启Keep-Alive模式取决于服务器的设置。</p>
<p>Keep-Alive的作用是保持下层的TCP连接，并且要求设置一个<strong>超时阈值</strong>和<strong>最大接受请求次数的阈值</strong>，达到阈值会断开连接。</p>
<p>需要注意的是，Keep-Alive只允许保持连接，但HTTP仍然是无状态的，也就是说不同的请求-响应内容仍然是<strong>独立、互不影响</strong>的。此外，程序不应该依赖它的保持连接特性，因为连接会因为各种原因断开。</p>
<h3 id="Chunked-传输"><a href="#Chunked-传输" class="headerlink" title="Chunked 传输"></a>Chunked 传输</h3><p>如果在HTTP消息头部设置字段<code>Transfer-Encoding: chunked</code>，则表示消息分块传输。</p>
<p>每一个非空块都由<code>块字节数 + CRLF + 数据</code>组成，最后一块是空块，由<code>0+CRLF</code>组成，表示本次传输数据结束。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1A</span><br><span class="line">and this is the second one</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>优点：使用chunked传输可以边生成内容边发送。</p>
<p>缺点：chunked 传输的接收方事先不知道全部数据的长度，所以无法实现进度追踪。</p>
<h3 id="内容劫持-HTTP劫持"><a href="#内容劫持-HTTP劫持" class="headerlink" title="内容劫持(HTTP劫持)"></a>内容劫持(HTTP劫持)</h3><p>采用http协议的TCP数据包在传输时会经过网关，网关（如ISP）通过篡改服务器发回的数据包中响应报文的内容，抢先回复客户端，使真正的响应数据包被丢弃，自己篡改的数据包被接受，从而达到目的（修改的内容）。</p>
<p>其中修改内容的方式可以是插入静态脚本，插入html content，或使用Iframe植入内容。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS协议是HTTP over SSL的缩写，也就是在SSL协议之上的HTTP协议。HTTP是第一个使用SSL协议保障安全的应用层协议，邮件系统也能支持SSL协议，如：SMTP，POP3、IMAP。在SSLv3之后有了TLS1.1, TLS1.2, TLS1.3。</p>
<p>对SSL协议和TLS协议的总结见本文对应章节。</p>
<h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><h3 id="非对称密钥"><a href="#非对称密钥" class="headerlink" title="非对称密钥"></a>非对称密钥</h3><p>非对称密钥英文是public-key cryptography，即公钥加密。服务器生成一对密钥，加密和解密使用不同的密钥，因此称为非对称密钥。非对称密钥可以用来加密、解密信息，也可以制作数字签名。两者的区别是应用场景不同，前者是所有客户端都可以加密，而解密只能是服务器；后者是所有人都可以解密，而加密者是唯一的。</p>
<h4 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h4><p>以RSA加密算法为例，服务器生成一对公钥和私钥，自己保留私钥，并把公钥发送给客户端，客户端发送的报文都用这个公钥加密，这样就只有服务器的唯一私钥可以解密，防止其他人获取报文中的信息。</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>因为公钥是可以被他人截取到的，所以为了防止服务器发出的报文被他人替换成假报文发给客户端，可以使用数字签名。首先将要发送的报文用hash算法生成摘要，再将摘要用私钥加密，作为数字签名，在发送报文时加上数字签名。这样，客户端能够：</p>
<ul>
<li>收到报文后可以用公钥解密数字签名部分，得到hash摘要信息。</li>
<li>计算明文报文部分的hash摘要，和解密出的摘要对比，如果相同就说明报文没有被篡改。</li>
</ul>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>数字签名解决了发回的报文被他人修改冒充的问题，那么如果有人在最开始，服务器向客户端发送公钥的阶段就冒充呢？如果有人截取到服务器发出的公钥信息，并向客户端发自己的公钥，那么客户端加密的所有报文都能被这个人截取并且解密，不仅如此，冒充者还能用私钥生成数字签名，破解上述的防护措施。</p>
<p>数字证书(Certificate Authority, CA)就是解决这个问题的。被认证的权威机构用自己的私钥加密真实服务器的公钥，产生数字证书发给客户端，客户端再用CA的公钥解密获得真实服务器的公钥，这个过程也就是对”服务器公钥”的加密解密。这样，权威机构加密的真实公钥就不怕被替换了。</p>
<p>问题来了，CA机构颁发的数字证书不怕被他人伪造吗？实际上这里还有证书的分级，根证书是预装在操作系统里的，从根证书开始每一级保证下一级证书的可信度，到CA机构的证书，构成一条信用链，因此只要上级证书可信，当前证书就可信。</p>
<h3 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h3><p>对称密钥算法中，加密和解密都是用同一个密钥，因此称为对称密钥。使用对称密钥的优势是加/解密速度快，适合于对大数据量进行加密。密钥越长越难破解，加解密速度越慢，反之同理。但问题在于，加解密钥相同就意味着要把这个密钥发送给目标客户端时，他人只要截取了这个密钥，就既能加密也能解密了。</p>
<p>通常为保证安全性，采用非对称密钥加密对称密钥，这样密钥能够安全送到客户端手上，并且之后的通信就可以使用对称密钥快速加解密了。</p>
<h3 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h3><p><em><a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">曹世宏的博客</a></em></p>
<p>SSL协议建立在TCP协议和应用层协议之间，整个协议体系包含两层：下层(下接TCP层)是SSL记录(record)协议层，上层(上接应用层)是SSL握手协议层。</p>
<p>上层协议包括SSL握手协议(SSL HandShake Protocol)、SSL密码参数修改协议(SSL Change Cipher Spec Protocol)和SSL告警协议(SSL Alert Protocol)。其中握手协议负责实际数据传输开始前的身份验证、协商加密算法、交换加密密钥等。而下层负责给上层协议提供压缩解压、加密解密、计算和校验MAC等功能。</p>
<p>SSL会话分为握手阶段和数据传输阶段两个阶段。</p>
<h4 id="握手阶段"><a href="#握手阶段" class="headerlink" title="握手阶段"></a>握手阶段</h4><p>握手阶段包含以下几个步骤：</p>
<ul>
<li><p>客户端向服务端发送client hello，其中主要有：</p>
<ul>
<li>客户端支持的协议版本，按优先级列出；</li>
<li>随机数client_random；</li>
<li>session id，用于会话恢复；</li>
<li>客户端已知的加密套件列表；</li>
<li>压缩方法(存在漏洞，在TLS1.3开始禁止)；</li>
<li>Extension，包括服务器名称、支持的签名算法、session ticket(用于会话恢复)等；</li>
</ul>
</li>
<li><p>服务器收到信息回复server hello：</p>
<ul>
<li>服务器选择的协议版本，即客户端支持的最高协议版本；</li>
<li>随机数server_random；</li>
<li>加密套件，选择客户端支持的一个加密套件；</li>
<li>session id，用于会话恢复；</li>
<li>压缩算法；</li>
<li>Extension；</li>
</ul>
</li>
<li><p>服务器发送一系列包给客户端，其中包括：</p>
<ul>
<li><p>发送证书，其中包含公钥；</p>
</li>
<li><p>服务器根据选择的密钥交换方法发送所需的参数：</p>
<ul>
<li>如果采用RSA密钥交换，就没有这一步；</li>
<li>如果采用DH密钥交换，发送服务器的DH参数(被签名保护)；</li>
</ul>
</li>
<li><p>发送Certificate request（如果是双向认证）；</p>
</li>
<li><p>发送server hello done，表示自己的信息已发送完毕。</p>
</li>
</ul>
</li>
<li><p>客户端回复一系列包给服务器，其中包括：</p>
<ul>
<li><p>发送证书 (可选) ；</p>
</li>
<li><p>客户端根据选择的密钥交换方法发送所需的参数：</p>
<ul>
<li><p>如果采用RSA密钥交换，就生成一个新的随机数pre-master secret，用收到的[证书中的公钥]加密这个pre-master发给服务器；</p>
<p><strong>*</strong> 前两个随机数是明文，这个随机数是公钥加密，理论上这个公钥加密还是有可能被破解；</p>
</li>
<li><p>如果采用DH密钥交换，就发送客户端的DH参数(被签名保护)；</p>
<p><strong>*</strong> 双方都拿到了对方的DH参数，组合起来就能算出同一个pre-master secret，避免了对它的传输。</p>
</li>
</ul>
</li>
<li><p>发送Certificate verify (可选)，如果前面发了证书，这里才需要跟一条verify，包含对所有握手消息的HMAC值用master secret签名；</p>
</li>
</ul>
<p>(此时，双方通过三个随机数和选定的加密套件生成了最终的会话密钥)</p>
</li>
<li><p>客户端发送密码更改通知(Change Cipher Spec)，表示准备好使用协商好的加密套件进行通信了；</p>
</li>
<li><p>客户端使用HMAC算法计算前面发送的所有内容的hash值，并用会话密钥加密，供服务器校验，同时表示客户端握手阶段结束了；</p>
</li>
<li><p>服务器用会话密钥解密hash值，同时自己也计算出一个hash值，比较验证数据和密钥的正确性；</p>
</li>
<li><p>服务器发送Change Cipher Spec；</p>
</li>
<li><p>服务器发送自己加密的hash值，供客户端校验，同时表示服务器握手阶段也结束了。</p>
</li>
</ul>
<p>至此，双方终于建立了安全连接，并拥有了共同的会话密钥。</p>
<h4 id="数据传输阶段"><a href="#数据传输阶段" class="headerlink" title="数据传输阶段"></a>数据传输阶段</h4><p>在数据传输阶段，双方使用会话密钥加密、解密明文，同时还对明文计算<strong>检验和</strong>(hash值)，也叫消息认证码(Message Authentication Code, MAC)，或哈希消息验证码(HMAC)，使攻击者无法在篡改明文的同时保证HMAC不变。</p>
<h4 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h4><p>当一次会话断开之后，为了避免重新生成密钥，减少重新建立连接的代价，有几种恢复会话的方法。</p>
<p>一种是session id，即对每个会话绑定一个session id，服务器会保存session id到session secret的映射，收到客户端发来的session id就能找到对应会话已经产生的密钥了，重新建立会话就不用再交换参数生成新的密钥了。这种方式服务器需要保存映射，非常占用存储资源。</p>
<p>另一种是session ticket。服务器将双方协商的密钥等通信信息加密为session ticket附在extension中并发给客户端，由客户端保存。当需要会话恢复时，服务器能够对session ticket进行解密，从而获得会话密钥，重新建立会话连接。</p>
<p>类似于http协议中的session(服务器保存)和cookie(客户端保存)。</p>
<p>详细的会话恢复通信过程见参考博客。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p><em>代填</em></p>
<h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>通过攻击域名解析服务器、修改服务器中某些域名的解析结果，使所有向其发出该域名解析请求的客户端拿到的都是被篡改的ip地址。</p>
<p>或者伪装成域名解析器，做成钓鱼服务器，当接受到域名解析请求，就像客户端返回冒充的ip地址。</p>
<p>解决方法：修改自己的DNS配置为未被劫持的服务器。</p>
<h3 id="DNS污染"><a href="#DNS污染" class="headerlink" title="DNS污染"></a>DNS污染</h3><p>由于通常的域名查询没有任何认证机制，而且域名查询通常基于无连接不可靠的UDP协议，查询者只能接受最先到达的格式正确结果，并丢弃之后的结果，所以通过监听UDP的53端口进行IDS入侵检测，当发现目标域名，就制作伪装的返回包发给请求方，使其得到错误的ip地址，这就是DNS缓存污染，也叫DNS缓存投毒。</p>
<p>解决方法：修改hosts文件，自己配置正确的ip。</p>
<p><em>To be continued..</em></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>Computer Basics</tag>
        <tag>Protocol</tag>
      </tags>
  </entry>
</search>
