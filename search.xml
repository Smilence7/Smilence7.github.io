<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>查找树系列</title>
    <url>/2021/02/04/binary-search-tree/</url>
    <content><![CDATA[<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树定义每个结点的左子树里的元素值都小于该节点、右子树里的元素都大于该节点，这样的定义使它的中序遍历就是升序的有序数据，时间复杂度为O(n)。</p>
<p>查找操作：从根节点出发，小于就递归左子树，大于就递归右子树，直到等于根节点就返回。</p>
<p>插入操作：一直递归比较，直到找到该分支底部的位置（左小右大向下查找，直到左/右子树为空，就新建一个结点放到左/右子结点）。</p>
<a id="more"></a>

<p>删除操作：先查找到删除的结点位置，</p>
<ul>
<li>如果该位置没有子结点，将父节点指向null；</li>
<li>如果该位置有一个子结点，将父节点指向该子结点（如果待删除结点是父节点的左子结点就接左指针，否则接右指针）；</li>
<li>如果该位置有两个子结点，查找右子树中最小的结点，用它的值覆盖待删除位置，再递归地删除新的待删除结点。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node p = tree; <span class="comment">// p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">  Node pp = <span class="keyword">null</span>; <span class="comment">// pp记录的是p的父节点</span></span><br><span class="line">  <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">    pp = p;</span><br><span class="line">    <span class="keyword">if</span> (data &gt; p.data) p = p.right;</span><br><span class="line">    <span class="keyword">else</span> p = p.left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 没有找到</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">    Node minP = p.right;</span><br><span class="line">    Node minPP = p; <span class="comment">// minPP表示minP的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">      minPP = minP;</span><br><span class="line">      minP = minP.left;</span><br><span class="line">    &#125;</span><br><span class="line">    p.data = minP.data; <span class="comment">// 将minP的数据替换到p中</span></span><br><span class="line">    p = minP; <span class="comment">// 下面就变成了删除minP了</span></span><br><span class="line">    pp = minPP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">  Node child; <span class="comment">// p的子节点</span></span><br><span class="line">  <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) child = p.left;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) child = p.right;</span><br><span class="line">  <span class="keyword">else</span> child = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pp == <span class="keyword">null</span>) tree = child; <span class="comment">// 删除的是根节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) pp.left = child;</span><br><span class="line">  <span class="keyword">else</span> pp.right = child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前驱结点：比该结点小的最大结点。后继结点：比该结点大的最小结点。</p>
<p>前驱结点和后继结点在后面说到的平衡树中有重要的作用，因为平衡的过程中需要调整结点位置而不改变查找树左大右小的性质，因此需要找到并移动前驱或后继结点。</p>
<p>支持重复数值：如果存储的是对象，并通过其中一个成员变量来判断大小，那么就可能存在重复值。对于重复值的处理很简单：后出现的重复值看作大于前面出现的值就可以了。在插入时，新出现的重复值被插入前一个的右子树；在查找时，每查找到一个就存入结果，并继续往右子树查找，直到遇到叶子结点才结束；删除时同理。</p>
<p>时间复杂度：完全二叉树O(logn)，极端不平衡的二叉树退化成链表O(logn)。</p>
<p>二叉查找树 v.s. 哈希表：二叉查找树存储的是有序数据，且性能稳定，而哈希表会遇到散列冲突、扩容等情况；哈希表大多数情况比二叉查找树快，因为O(1)与O(logn)的差别，只有n特别小时，哈希函数的复杂度加上常量级的查找时间也可能超过O(logn)。</p>
<h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>平衡树就是B树(Balance Tree, B-Tree)。</p>
<h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><p>平衡树的二叉树版本，通常称为AVL树。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><em>整理自 <a href="https://www.zhihu.com/question/312327402/answer/1560653215">敖丙的知乎回答</a></em>  </p>
<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>红黑树是对概念模型<strong>2-3-4树</strong>的一种实现。2-3-4树是阶数为4的B树(平衡多路查找树)。</p>
<p>2-3-4 树可以包含三种结点：</p>
<ul>
<li>2结点：结点有1个值，二叉，分别对应小于该结点和大于该结点的子树；</li>
<li>3结点：结点有2个值，三叉，同理；</li>
<li>4结点：结点有3个值，四叉，同理。</li>
</ul>
<p>而红黑树是把这种4阶树实现在<strong>二叉树</strong>上，通过引入结点颜色并相应地设计一套规则，减小了调整平衡的时间开销。</p>
<p>为简化理解难度，我们先理解一下2-3树到红黑树的转换过程，再了解2-3树的调平方式，从而理解红黑树的调平策略。</p>
<h3 id="将一颗2-3树转换成红黑树"><a href="#将一颗2-3树转换成红黑树" class="headerlink" title="将一颗2-3树转换成红黑树"></a>将一颗2-3树转换成红黑树</h3><p>2结点就是二叉结点，令它作为黑色结点；</p>
<p>3结点可以拆成两个结点，遵循查找树的特性，有左倾和右倾两种转换形式，父结点为黑，子结点为红；</p>
<p>(如果是2-3-4树转换为红黑树，同理，4结点用3个值里中间的那个作为黑色根结点，连接左右两个红色子结点。)</p>
<img src="/2021/02/04/binary-search-tree/2-3%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91.jpg" class="" title="2-3树与红黑树">

<p>如果把所有的3结点都按左倾的方式处理，就形成了图中的对应关系，即所有3结点的第一个数作为左子结点，第二个数作为父结点。</p>
<h3 id="2-3-4-树的插入删除"><a href="#2-3-4-树的插入删除" class="headerlink" title="2-3(-4)树的插入删除"></a>2-3(-4)树的插入删除</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>对于2结点的插入，直接转为3结点。对应红黑树中在黑结点下插入元素(红结点)。</p>
<p>对于3结点，如果是2-3树，先产生临时的4结点，再向上分裂（中间值左为父结点）；如果是2-3-4树，直接转为4结点。融合出临时4结点后的分裂操作对应红黑树中插入红结点后对双红结点旋转的操作。</p>
<p>对于4结点，先将4结点向上分裂，在找到插入元素所应该在的2结点，将其转为3结点。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>删除元素在3结点中，直接删除。</p>
<p>删除元素在2结点中，直接删除这个结点会破坏树的平衡。对应插入过程中的分裂，删除时可以从兄弟和父结点中借元素。</p>
<ul>
<li><p>兄弟结点是2结点，父结点为3结点：父结点下移一个元素给当前结点，此时当前结点有2个元素，与兄弟结点的2个元素合并成一个临时4结点，再删除元素成为3结点。</p>
</li>
<li><p>兄弟结点是3结点：兄弟结点上移一个元素给父结点，父结点下移一个元素给当前结点，再删除对应元素。</p>
</li>
<li><p>兄弟结点和父结点都是2结点：三者合并成一个临时4结点，再删除元素成为3结点。</p>
</li>
</ul>
<h3 id="通过2-3树理解红黑树的定义"><a href="#通过2-3树理解红黑树的定义" class="headerlink" title="通过2-3树理解红黑树的定义"></a>通过2-3树理解红黑树的定义</h3><ol>
<li><p>结点颜色分为红色和黑色</p>
<p>对应2-3树中的3结点，令其中一个是黑色一个是红色</p>
</li>
<li><p>根结点为黑色</p>
<p>2-3树中的2结点自然是黑结点，因此根2结点是黑色；对于根3结点，定义其中一个元素为黑色根结点(取决于左倾还是右倾)。</p>
</li>
<li><p>叶子结点是黑色（空结点）</p>
<p>实际上是所有叶子结点指向同一个黑色空结点，方便代码实现。</p>
</li>
<li><p>每个结点到任意叶子结点的路径中经过的黑色节点数相同</p>
<p>参考上面的图，所有的红色结点和其父结点在2-3树中是同一个结点，自然不会贡献高度；而2-3树的定义就有结点到任意叶子结点的距离相同。</p>
</li>
<li><p>红色结点不能直接连接</p>
<p>连续红色结点代表2-3-4树中的3结点，在红黑树中是作为左右子结点隔开的。</p>
</li>
</ol>
<h3 id="二叉查找树的调平"><a href="#二叉查找树的调平" class="headerlink" title="二叉查找树的调平"></a>二叉查找树的调平</h3><p>前面介绍二叉查找树的时候提到，查找前驱结点和后继结点是十分重要的功能。<em>待填</em></p>
<h3 id="左倾红黑树的插入删除"><a href="#左倾红黑树的插入删除" class="headerlink" title="左倾红黑树的插入删除"></a>左倾红黑树的插入删除</h3><p><em>待填</em></p>
<h4 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h4><p><em>待填</em></p>
<h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><p><em>待填</em></p>
<h3 id="普通红黑树的插入"><a href="#普通红黑树的插入" class="headerlink" title="普通红黑树的插入"></a>普通红黑树的插入</h3><p><em>代填</em></p>
<h3 id="值得思考的问题"><a href="#值得思考的问题" class="headerlink" title="值得思考的问题"></a>值得思考的问题</h3><h4 id="为什么HashMap底层实现用红黑树而不是AVL树"><a href="#为什么HashMap底层实现用红黑树而不是AVL树" class="headerlink" title="为什么HashMap底层实现用红黑树而不是AVL树"></a>为什么HashMap底层实现用红黑树而不是AVL树</h4><p>严格平衡二叉树：任意结点的左右子树高度差不大于1。因此平衡二叉树不一定是完全二叉树。</p>
<p>最先被发明的 <em>AVL树</em> 是严格的平衡二叉查找树，而后面的平衡查找树并没有严格符合高度差不超过1，只需要大致平衡。</p>
<p>因为维护一个严格平衡的树需要更多的操作，使得维护<strong>近似平衡</strong>的树虽然会增加一些(红黑树中两倍)结点数量产生额外的开销，但相比维护<strong>严格平衡</strong>的树带来的开销还是更小的。</p>
<h4 id="为什么红黑树是近似平衡的"><a href="#为什么红黑树是近似平衡的" class="headerlink" title="为什么红黑树是近似平衡的"></a>为什么红黑树是近似平衡的</h4><p>不失一般性，当一颗红黑树包含m个红结点和n个黑结点，如果我们把这棵树按2-3-4树的形态来看，那么它的高度只跟黑结点有关，即高度等于logn。同时，由于定义了红结点不能直接相连，所以红结点的个数m一定小于n，因此整个树算上红结点的高度一定小于2logn，所以插入删除算法的时间复杂度仍然是O(logn)级别的。</p>
<img src="/2021/02/04/binary-search-tree/RBTree.jpg" class="" title="黑色结点高度">

<h4 id="如果一颗红黑树只有黑色结点会怎样"><a href="#如果一颗红黑树只有黑色结点会怎样" class="headerlink" title="如果一颗红黑树只有黑色结点会怎样"></a>如果一颗红黑树只有黑色结点会怎样</h4><p>根据前面引入的B树与红黑树的关系理解，如果一棵红黑树没有红色结点，也就是说对应B树里的所有结点都是2结点，也就是平衡二叉树。因此一颗只有黑色结点的红黑树就成为了一颗AVL树（严格平衡）。所以串起上文，红色结点就是红黑树<strong>近似平衡</strong>的特性中<strong>不稳定</strong>的那部分(根据上文，最坏情况也可以接受)。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p><em>码好再更新，To be continued…</em></p>
]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>Data Structure</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>并发容器系列</title>
    <url>/2021/02/24/concurrent-collections/</url>
    <content><![CDATA[<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>维护一个被volatile修饰的Object数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><p><code>get()</code>方法普通地读取array：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the array.  Non-private so as to also be accessible</span></span><br><span class="line"><span class="comment"> * from CopyOnWriteArraySet class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p><code>add()</code>方法通过ReentrantLock下在拷贝数组中添加元素，并修改原引用来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 得到旧数组对象</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">// 拷贝并写新数组对象</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);	        </span><br><span class="line">		newElements[len] = e;</span><br><span class="line">		<span class="comment">// 将旧数组引用指向新的数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="值得注意的问题"><a href="#值得注意的问题" class="headerlink" title="值得注意的问题"></a>值得注意的问题</h4><p>虽然array是volatile修饰的，但array是一个引用，其引用对象也就是数组的内容修改是无法保证数据可见性的，所以在<code>add()</code>方法中采用创建新的数组对象，并将array的引用更新的方法，保证写操作的数据可见性。</p>
<p>CopyOnWrite容器只能保证数据的最终一致性(基于volatile与引用更新)，不能保证数据实时一致性，也就是说会发生脏读现象。因为后来的读线程不会等待写线程，后来的写线程也不会等待读线程。</p>
<p>CopyOnWrite的copy特点使其会占用额外的内存，如果对象比较大，可能造成频繁地垃圾回收。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap是HashMap的并发优化版本，起初的并发解决方案是HashTable，就是把大部分方法都用synchronized加锁，使所有的并发操作都互斥从而序列化。在JDK 1.8之前的ConcurrentHashMap使用ReentrantLock对哈希表加了分段锁，使用继承ReentrantLock的segment锁分段锁住哈希桶，如果并发线程处理的不是同一段的数据，就可以非阻塞并发进行。而在1.8版本，不仅将结点长度大于8的哈希桶优化为红黑树结构，还取消了segment锁，转而对每个哈希桶加锁，细化了锁的粒度。也就是说，只有当两个线程操作的位置发生哈希碰撞才会互斥。</p>
<p>并发哈希表中主要的核心操作是 <code>putVal()</code> 和其中的 <code>casTabAt()</code>、<code>helpTransfer()</code>。</p>
<ul>
<li><p><code>casTabAt()</code>主要是在<code>putVal()</code>中用到的，当使用<code>tabAt()</code>得到插入位置的哈希桶结点时，发现没有哈希冲突(结点为null)，就尝试CAS操作替换这个位置的结点，如果成功就直接完成了putVal()操作。</p>
</li>
<li><p>如果没有成功，<code>putVal()</code>在并发HashMap中的不同之处就是判断这个结点的hash值是否为<code>MOVED</code>，如果是，则说明table正在被扩容，这时要参与到多线程<strong>协作</strong>的扩容过程中，即调用<code>helpTransfer()</code>。</p>
</li>
<li><p>在<code>helpTransfer()</code>中主要是判断当前线程加入协作时，扩容是不是已经结束了，并判断协作的线程数是否已经达到限制数了，如果都没有，就修改sizeCtl变量(扩容阶段用于反映协助扩容的线程数)，实际的扩容操作在<code>tansfer()</code>中实现。</p>
</li>
<li><p>在<code>transfer()</code>中，线程根据核心数和桶个数分派到自己要处理的桶个数，从分到的最后一个桶开始：</p>
<ul>
<li>如果这个桶是空的，就插入占位符告诉其他线程现在在扩容，其他线程不会再往这个位置插入数据，而且会参与协作扩容；</li>
<li>如果桶不为空且有占位符，说明有线程已经在处理这个桶了，跳过这个桶；</li>
<li>如果都不是，就可以对这个桶进行迁移了，<strong>先对这个桶上锁</strong>，然后将其拷贝到新的两倍大小的数组nextTable的对应位置。</li>
<li>如果分派的桶迁移任务数量完成了，或者迁移结束了，更新sizeCtl和table。</li>
</ul>
</li>
<li><p>如果不在扩容，而且发生哈希冲突，就<strong>对这个桶上锁</strong>，在同步块中完成与HashMap中一样的put操作。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Multithread &amp; Concurrency</category>
      </categories>
      <tags>
        <tag>ConcurrentHashMap</tag>
        <tag>CopyOnWriteArrayList</tag>
        <tag>Concurrent Collections</tag>
        <tag>Multithread &amp; Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2021/02/14/design-pattern/</url>
    <content><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>模式是你必须在应用程序中自己实现的形式化的最佳实践。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>工厂模式的设计意图是将对象的创建过程封装，通过同一个工厂类或接口来管理对象的创建过程。</p>
<h4 id="简单工厂模式-Simple-Factory-Pattern"><a href="#简单工厂模式-Simple-Factory-Pattern" class="headerlink" title="简单工厂模式(Simple Factory Pattern)"></a>简单工厂模式(Simple Factory Pattern)</h4><p>简单工厂模式也叫静态工厂方法模式，通过定义一个工厂类，来对不同的参数输入返回不同类的实例。在这种模式中，工厂主要就是<strong>负责创建不同实例</strong>的逻辑，而创建出的实例是产品接口的实现类，符合产品接口的要求。</p>
<h4 id="工厂方法模式-Factory-Method-Pattern"><a href="#工厂方法模式-Factory-Method-Pattern" class="headerlink" title="工厂方法模式(Factory Method Pattern)"></a>工厂方法模式(Factory Method Pattern)</h4><p>工厂方法模式中，工厂通过接口给出必须实现的方法，而不负责产品的创建，产品的创建由实现类完成。用户根据自己的需求选择对应的工厂，并调用工厂方法获得产品。在这个过程中，用户不需要指定产品接口下的具体某一种产品类型，可以利用对态性以总产品接口声明产品的引用。</p>
<p>工厂方法模式的好处有：</p>
<ul>
<li>工厂可以返回目标产品的实现类或子类，比如：<strong>文件日志工厂</strong>属于<strong>日志工厂接口</strong>的实现类，文件日志工厂可以创建并返回<strong>日志接口的实现类</strong>——<strong>文件日志</strong>，而用户只需要用日志接口接收这个返回值。</li>
<li>可以添加新的工厂实现类来拓展功能。</li>
</ul>
<a id="more"></a>

<h4 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式(Abstract Factory Pattern)"></a>抽象工厂模式(Abstract Factory Pattern)</h4><p>抽象工厂模式中，工厂接口可以根据需求选择代工厂(子接口)来完成生产工作，而用户只需要使用这个总工厂，不用自己找代工厂。即：工厂通过静态方法帮用户<strong>选择</strong>对应的代工厂，并给用户<strong>返回</strong>代工厂的<strong>实现类</strong>。这样，用户不用关心选哪个代工厂，而是利用多态性，用最上层接口(总工厂)声明引用。</p>
<p>如果工厂还支持不同的产品加工方法，那么所有代工厂可以使用同一套方法名，从而对用户透明，用户仍然不必知道是哪个代工厂。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果说工厂方法是对<strong>产品类型</strong>的透明，那么抽象工厂就是对<strong>子工厂类型</strong>的透明。</p>
<p>工厂或代工厂还可以对创建过的产品进行缓存，当新的需求与缓存的产品对应时直接返回缓存的产品，从而优化内存占用和运行时间。例如Integer的valueOf()方法缓存了+/-128的整形数字包装对象。</p>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器主要是用来完成不同类型对象的转换，就像将显示器的HDMI头转为DP头一样，是为了让原类型(HDMI插头)能在目标位置(显卡的DP槽)使用。</p>
<p>比如将Calleble适配成Runnable用于创建Thread:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Callable&lt;?&gt; callable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnableAdapter</span><span class="params">(Callable&lt;?&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            callable.call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>或比如将某个容器类型的数据转换成另一个容器类型  <code>Arrays.asList()</code>等等。</p>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>通过对原对象包装，产生一个持有原对象的代理对象，我们可以在执行原对象的目标方法时添加额外的逻辑，比如条件判断、在方法执行前添加逻辑、在方法执行后添加逻辑等。这样一来，代码的设计模式就变成：</p>
<ul>
<li><p>A接口：只定义接口；</p>
</li>
<li><p>ABusiness类：A接口的某个业务逻辑；</p>
</li>
<li><p>APermissionProxy类：只实现A接口的权限检查代理。</p>
</li>
</ul>
<p>从而保证了代理的职责单一、泛用，降低耦合。</p>
<p>虚代理：只有当真正需要调用时才创建对象，在这之前只是让调用者持有一个代理对象。</p>
<p>远程代理：负责把方法访问转换成远程调用，然后返回结果。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式要求只生成类的唯一实例，一般是采用eager mode：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Singleton&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>实现思想是设构造方法为private，并初始化唯一静态实例，再用静态方法获取唯一实例。</p>
<p>一般来说这种方法就足够了，但在序列化和反序列化过程中会跳过private构造方法，导致单例模式失效。</p>
<p>代替方案是使用enum类，保证实例的唯一性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字段</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String name = Singleton.INSTANCE.getName();</span></span><br></pre></td></tr></table></figure>


<p>如果单例对象很大，在应用场景中对此很敏感，可以采用延迟创建的方式，即lazy mode：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Singleton &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注意，这里<code>getInstance()</code>方法必须加锁才能保证线程安全以及单例有效性，但加锁后每次获取实例都要获取锁，大大降低了效率。</p>
<p>于是有了双重检验锁，但这种方法也不是线程安全的，因为<code>INSTANCE = new Singleton()</code>不是原子操作，对象的<strong>初始化</strong>和<strong>引用赋值</strong>可能会被重排序，也就是先将引用变量指向对象地址，然后再为地址内设置初始化值。在刚进行了第一步，还没进行第二步的时候，如果有线程处于第一层检验，会判断对象不为null从而返回对象，这时对象的值是未初始化，或者未完全初始化的，因此返回的是错误结果。</p>
<p>给唯一实例加上volatile关键字可以解决这个问题，因为volatile就是解决<strong>指令重排序</strong>和<strong>数据可见性</strong>的，详见另一篇文章。 <em><a href="https://zayeum.com/2021/02/07/volatile/">volatile关键字</a></em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class Singleton &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">final</span> Singleton INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Factory Pattern</tag>
        <tag>Adapter Pattern</tag>
        <tag>Agent Pattern</tag>
        <tag>Singleton Pattern</tag>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA Keymap</title>
    <url>/2021/01/31/idea-keymap/</url>
    <content><![CDATA[<p><em>本文归纳自官方文档与 <a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial/blob/master/keymap-introduce.md">IntelliJ-IDEA-Tutorials</a></em></p>
<p><em>待更新，调整只保留常用实用快捷键。</em></p>
<a id="more"></a>
<h2 id="for-Mac"><a href="#for-Mac" class="headerlink" title="for Mac"></a>for Mac</h2><h4 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>⌥</kbd> + <kbd>↑</kbd> / <kbd>↓</kbd></td>
<td>选中被<strong>更外层/更内层</strong>包围的代码块</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>↑</kbd> / <kbd>↓</kbd></td>
<td>跳转到上一个/下一个方法</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>B</kbd></td>
<td>跳转到定义/使用处 (等同于command+鼠标左键)</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>[</kbd> / <kbd>]</kbd></td>
<td>跳到前一个/后一个位置 (等同于鼠标侧键)</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>H</kbd></td>
<td>显示当前类的继承目录</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd></td>
<td>显示当前方法的层次结构</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>F12</kbd></td>
<td>查看当前文件的成员目录，支持输入关键字查找</td>
</tr>
</tbody></table>
<h4 id="Editing"><a href="#Editing" class="headerlink" title="Editing"></a>Editing</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>⌃</kbd> + <kbd>Space</kbd></td>
<td>基本的代码补全（补全任何类、方法、变量）</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>Shift</kbd> + <kbd>Space</kbd></td>
<td>智能代码补全（过滤器方法列表和变量的预期类型）</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>Shift</kbd> + <kbd>Enter</kbd></td>
<td>自动结束代码，行末自动添加分号</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>P</kbd></td>
<td>显示方法的参数信息</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>J</kbd></td>
<td>显示当前位置的变量、方法的 Documentation 内容</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F1</kbd></td>
<td>查看外部文档</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>光标停留</kbd></td>
<td>显示代码简要信息</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>F1</kbd></td>
<td>在错误或警告处显示具体描述信息</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>N</kbd></td>
<td>生成代码</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>O</kbd></td>
<td>重写父类方法</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>I</kbd></td>
<td>显示代码简要信息</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>T</kbd></td>
<td>生成包围代码</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>/</kbd></td>
<td>注释/取消注释与行注释</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>/</kbd></td>
<td>注释/取消注释与块注释</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>Shift</kbd> + <kbd>Q</kbd></td>
<td>显示上下文信息</td>
</tr>
<tr>
<td><kbd>⌥</kbd> + <kbd>Enter</kbd></td>
<td>显示意向动作和快速修复代码</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>L</kbd></td>
<td>格式化代码</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>⌥</kbd> + <kbd>O</kbd</td>
<td>优化import</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>V</kbd></td>
<td>从缓冲区中选择粘贴</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd></td>
<td>切换大小写</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>Shift</kbd> + <kbd>J</kbd></td>
<td>智能的将代码拼接成一行</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Enter</kbd></td>
<td>智能的拆分拼接的行</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>-</kbd> / <kbd>=</kbd></td>
<td>展开/折叠代码块</td>
</tr>
</tbody></table>
<h4 id="Search-Replace"><a href="#Search-Replace" class="headerlink" title="Search/Replace"></a>Search/Replace</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>⌘</kbd> + <kbd>G</kbd></td>
<td>查找模式下，向下查找</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd></td>
<td>查找模式下，向上查找</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>R</kbd></td>
<td>文件内替换</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>F</kbd></td>
<td>全局查找</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>R</kbd></td>
<td>全局替换</td>
</tr>
</tbody></table>
<h4 id="Run-Debug"><a href="#Run-Debug" class="headerlink" title="Run/Debug"></a>Run/Debug</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>⌃</kbd> + <kbd>⌥</kbd> + <kbd>R</kbd></td>
<td>弹出 Run 的可选择菜单</td>
</tr>
<tr>
<td><kbd>⌃</kbd> + <kbd>⌥</kbd> + <kbd>D</kbd></td>
<td>弹出 Debug 的可选择菜单</td>
</tr>
<tr>
<td><kbd>F7</kbd></td>
<td>步入(step into)</td>
</tr>
<tr>
<td><kbd>F8</kbd></td>
<td>步过(step over)</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F7</kbd></td>
<td>智能步入</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F8</kbd></td>
<td>跳出</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>⌥</kbd> + <kbd>R</kbd></td>
<td>继续运行</td>
</tr>
<tr>
<td><kbd>⌘</kbd> + <kbd>Shift</kbd> + <kbd>F8</kbd></td>
<td>查看所有断点</td>
</tr>
</tbody></table>
<h2 id="for-Windows"><a href="#for-Windows" class="headerlink" title="for Windows"></a>for Windows</h2><h4 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>Ctrl</kbd> + <kbd>F</kbd></td>
<td>在当前文件进行文本查找</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>R</kbd></td>
<td>在当前文件进行文本替换</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>Z</kbd></td>
<td>撤销</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>C</kbd></td>
<td>复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>X</kbd></td>
<td>剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>D</kbd></td>
<td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>Y</kbd></td>
<td>删除光标所在行 或 删除选中的行</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>W</kbd></td>
<td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>E</kbd></td>
<td>显示最近打开的文件记录列表</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>N</kbd></td>
<td>根据输入的类名查找类文件</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>J</kbd></td>
<td>插入自定义动态代码模板</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>P</kbd></td>
<td>方法参数提示显示</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>U</kbd></td>
<td>前往当前光标所在的方法的父类的方法 / 接口定义</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>B</kbd></td>
<td>进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>/</kbd></td>
<td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F1</kbd></td>
<td>在光标所在的错误代码处显示错误信息</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F3</kbd></td>
<td>调转到所选中的词的下一个引用位置</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F4</kbd></td>
<td>关闭当前编辑的文件</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F9</kbd></td>
<td>执行 Make Project 操作</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F11</kbd></td>
<td>选中文件 / 文件夹，使用助记符设定 / 取消书签</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>F12</kbd></td>
<td>弹出当前文件结构层，用来在当前文件中定位</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>Space</kbd></td>
<td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>Delete</kbd></td>
<td>删除光标后面的单词或是中文句</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>BackSpace</kbd></td>
<td>删除光标前面的单词或是中文句</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>1,2,3...9</kbd></td>
<td>定位到对应数值的书签位置</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>左键单击</kbd></td>
<td>在打开的文件标题上，弹出该文件路径</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>光标定位</kbd></td>
<td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>←</kbd></td>
<td>光标跳转到当前单词 / 中文句的左侧开头位置</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>→</kbd></td>
<td>光标跳转到当前单词 / 中文句的右侧开头位置</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>O</kbd></td>
<td>选择可重写的方法</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>I</kbd></td>
<td>选择可继承的方法</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>+</kbd></td>
<td>展开代码</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>-</kbd></td>
<td>折叠代码</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>H</kbd></td>
<td>显示当前类的层次结构</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>T</kbd></td>
<td>版本控制更新项目</td>
</tr>
<tr>
<td><kbd>Ctrl</kbd> + <kbd>K</kbd></td>
<td>版本控制提交项目</td>
</tr>
</tbody></table>
<h4 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>Alt</kbd> + <kbd>`</kbd></td>
<td>显示版本控制常用操作菜单弹出层</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>Q</kbd></td>
<td>弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>F1</kbd></td>
<td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>Enter</kbd></td>
<td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>Insert</kbd></td>
<td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>←/→</kbd></td>
<td>切换当前已打开的窗口中的子视图</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>↑/↓</kbd></td>
<td>当前光标跳转到当前文件的前一个/后一个方法名位置</td>
</tr>
<tr>
<td><kbd>Alt</kbd> + <kbd>1,2,3...9</kbd></td>
<td>打开/关闭对应视图（1是project）</td>
</tr>
</tbody></table>
<h4 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h4><table>
<thead>
<tr>
<th>快捷键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><kbd>Shift</kbd> + <kbd>F2</kbd></td>
<td>跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F3</kbd></td>
<td>在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F7</kbd></td>
<td>在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F8</kbd></td>
<td>在 Debug 模式下，跳出，表现出来的效果跟 F9 一样</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F9</kbd></td>
<td>等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F10</kbd></td>
<td>等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>F11</kbd></td>
<td>弹出书签显示层</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>End</kbd></td>
<td>选中光标到当前行尾位置</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>Home</kbd></td>
<td>选中光标到当前行头位置</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>左键单击</kbd></td>
<td>点击文件名快速关闭文件</td>
</tr>
<tr>
<td><kbd>Shift</kbd> + <kbd>滚轮</kbd></td>
<td>横向滚动文件</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Toolbox</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 快速部署</title>
    <url>/2021/01/23/hexo/</url>
    <content><![CDATA[<p>因为搭建博客的命令步骤都很容易理解，所以本文只是简单的记录过程中用到的命令和配置，可供参考和回查。</p>
<h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo wget https://npm.taobao.org/mirrors/node/latest-v14.x/node-v14.15.4.tar.gz</span><br><span class="line">sudo tar zxvf node-v14.15.4.tar.gz</span><br><span class="line">yum install gcc gcc-c++</span><br><span class="line">mv node-v14.15.4-linux-x64 nodejs</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/nodejs/bin/node /usr/bin/node </span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/nodejs/bin/npm /usr/bin/npm</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/nodejs/bin/npx /usr/bin/npx</span><br><span class="line"><span class="comment"># 换源</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/nodejs/bin/cnpm /usr/bin/cnpm</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo cnpm install -g hexo-cli</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/nodejs/bin/hexo /usr/bin/hexo</span><br></pre></td></tr></table></figure>


<h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 依赖</span></span><br><span class="line">yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc</span><br><span class="line">sudo tar -zxf git-2.21.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> git-2.21.0</span><br><span class="line">sudo make</span><br><span class="line">sudo make install prefix=/usr/<span class="built_in">local</span>/git</span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/git/bin</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"><span class="comment"># 或建立软连接</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/git/bin/git /usr/<span class="built_in">local</span>/bin/</span><br><span class="line"><span class="comment"># 配置身份</span></span><br><span class="line">git config --global user.name <span class="string">&quot;zayeum&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;smilence7@outlook.com&quot;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo hexo init</span><br><span class="line">sudo hexo s  <span class="comment"># start local server</span></span><br><span class="line">sudo npm install hexo-deployer-git --save</span><br><span class="line">sudo vim _config.yml</span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repo: <span class="string">&#x27;https://github.com/Smilence7/Smilence7.github.io&#x27;</span></span><br><span class="line">  branch: <span class="string">&#x27;master&#x27;</span></span><br><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo g  <span class="comment"># generate</span></span><br><span class="line">sudo hexo d  <span class="comment"># deploy</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="多端部署"><a href="#多端部署" class="headerlink" title="多端部署"></a>多端部署</h4><p>主要参考 <a href="https://leooo48.github.io/2017/07/12/hexo-github/">这篇博客</a></p>
<p>从base端上传源文件到github的hexo branch下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line"><span class="comment"># 先删除theme中的.git文件夹</span></span><br><span class="line">sudo git init</span><br><span class="line">sudo git add -A</span><br><span class="line">sudo git commit -m <span class="string">&quot;all blog source files&quot;</span></span><br><span class="line">sudo git branch hexo</span><br><span class="line">sudo git checkout hexo</span><br><span class="line">sudo git remote add origin https://github.com/Smilence7/Smilence7.github.io.git</span><br><span class="line">sudo git push origin hexo -f</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在新环境中安装Git, Nodejs</p>
</li>
<li><p>从github repo中克隆源文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo https://github.com/Smilence7/Smilence7.github.io.git</span><br></pre></td></tr></table></figure></li>
<li><p>安装hexo</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># windows</span></span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog/<span class="built_in">source</span></span><br><span class="line"><span class="comment"># 创建CNAME文件绑定域名</span></span><br><span class="line">vim CNAME</span><br><span class="line">zayeum.com</span><br><span class="line"><span class="comment"># 在域名管理页面中配置DNS解析</span></span><br><span class="line"><span class="comment"># 解析类型为CNAME，ip为Smilence7.github.io</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O 模型</title>
    <url>/2021/02/15/io-models/</url>
    <content><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>应用程序完成IO操作的过程划分为两步：向内核询问对应的文件是否就绪，就绪后从缓冲区拷贝文件到用户态。</p>
<h3 id="五种IO模型"><a href="#五种IO模型" class="headerlink" title="五种IO模型"></a>五种IO模型</h3><h4 id="阻塞-IO"><a href="#阻塞-IO" class="headerlink" title="阻塞 IO"></a>阻塞 IO</h4><p>在这个过程中，如果第一步的调用是阻塞等待的，就是阻塞IO。当用户态询问内核态文件是否就绪时，如果文件未就绪，就一直等待其就绪，才返回对应的文件描述符，再通过该文件描述符取得对应的数据。</p>
<p>如果单线程使用阻塞IO，就会导致后面的IO请求因为前面的IO请求未就绪而全部阻塞等待，系统响应缓慢；因此阻塞IO通常需要多线程支持，每当有一个IO请求，就申请一个新的线程或复用一个空闲线程去阻塞地处理请求。这种方法在任务处理上的效率很高，但线程管理的代价也很高，大量并发请求下会导致系统资源不足。</p>
<h4 id="非阻塞-IO"><a href="#非阻塞-IO" class="headerlink" title="非阻塞 IO"></a>非阻塞 IO</h4><p>相反，询问IO是否就绪时，如果就绪返回文件描述符，否则定时等待其就绪或直接返回-1，这种方法就是非阻塞的IO。</p>
<a id="more"></a>

<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>如果使用单线程一对一地进行非阻塞IO，实际上每次返回-1之后线程能做的事只有再次询问，因此一般会让一个线程管理多个IO请求，一次传递多个文件描述符给内核，提高线程效率，这就是IO多路复用。传递和询问一组文件描述符的系统调用有<code>select/poll/epoll</code>三种 ，内核根据采用哪种系统调用而选择返回就绪的fd或使用回调函数通知线程。</p>
<h4 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h4><p>信号处理IO是一种非阻塞模型，进程用系统调用<code>signaction</code>注册信号处理方法，然后立即返回(非阻塞)，当内核数据就序会递交一个信号给进程的信号处理方法，这时进程再阻塞调用<code>recvfrom</code>拷贝数据到进程中。</p>
<h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>同样是进程系统调用<code>aio_read</code>之后立即返回，但内核不仅完成数据就序工作，还会自动把数据拷贝到进程中，再递交系统调用中指定的信号。它与信号驱动的异步IO的区别在于：信号驱动IO在数据就序时通知，由进程调用数据拷贝操作；异步IO由内核进行数据拷贝，在拷贝完成时通知。</p>
<h4 id="划分方式"><a href="#划分方式" class="headerlink" title="划分方式"></a>划分方式</h4><p>同步、非同步和阻塞、非阻塞很容易混淆，它们的区别很明显，如果把IO分为两个阶段：发起IO请求(内核准备数据报)和执行IO操作(内核内存拷贝至进程内存)。那么阻塞/非阻塞就在于发起IO请求是否被阻塞，前面介绍的阻塞IO和IO复用都是在第一步阻塞，所以是阻塞IO；而同步/非同步在于执行IO操作是否被阻塞，前四种模型在执行IO操作时都在第二步阻塞，所以是同步IO。</p>
<h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>每个进程在打开或新建文件时，内核会在进程的文件列表中新增一个表项，返回一个文件描述符(fd)。这个文件描述符是一个从0开始的非负整数，其实就是新增表项的索引。</p>
<p>和管道、FIFO一样，Socket也是基于文件实现的，通过Socket通信，其实就是通过文件描述符读写文件。创建一个Socket会返回一个文件描述符：</p>
<p><code>int socket(int domain, int type, int protocol)</code></p>
<h4 id="fd-set"><a href="#fd-set" class="headerlink" title="fd_set"></a>fd_set</h4><p>fd_set采用bitmap的形式记录一组文件描述符是否就绪。比如一个长度为1字节的fd_set有8位比特位，可以表示8个文件描述符是否就绪。创建和使用一个fd_set时，可以用到这些API：</p>
<p>int FD_ZERO(int fd, fd_set *fdset);  // 将所有位置0</p>
<p>int FD_CLR(int fd, fd_set *fdset);  // 将某个位置置0</p>
<p>int FD_SET(int fd, fd_set *fdset);  // 将某个位置置1</p>
<p>int FD_ISSET(int fd, fd_set *fdset);  // 检测某一位是否为1</p>
<h4 id="select使用"><a href="#select使用" class="headerlink" title="select使用"></a>select使用</h4><p><code>int select(int nfds, fd_set *restrict readfds, fd_set *restrict writefds, fd_set *restrict errorfds, struct timeval *restrict timeout);</code></p>
<p>select方法传入要询问的fd数量、要询问的读fd集合、要询问的写fd集合和要询问的发生错误的fd集合，以及一个定时阻塞时长，当超过设置的时间后如果还没有就序的fd，就返回-1。如果timeout设置为null，就一直阻塞；如果设置为0，就不阻塞，立即返回。方法的返回值是就绪fd的个数。</p>
<p>使用示例：先声明一个fd_set变量，调用FD_ZERO初始化为0，再用FD_SET把想要询问的fd位置为1，调用select函数，内核将fd_set中未就绪的fd位置为0，并返回就绪fd的个数。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>select的方法调用时需要把fd_set从用户空间拷贝到内核空间，内核需要遍历每一位并设置正确的状态。此外，select能够监听的fd数量受限于内核定义的fd_set大小，在编译内核时就已经被确定，一般是1024。</p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll和select几乎一样，除了对最大监听fd数量进行了改进。poll使用链表存储fd，使复用的线程能管理的fd数量不再受限制。但性能上仍然存在select中的不足。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll对select和poll进行了改进，它使用红黑树来存储和维护fd集合，使用队列存储就绪的fd，而且由内核维护和保存这两个数据结构，同一个fd只需要一次系统调用就能够被内核保存在红黑树中，避免了select中重复拷贝fd_set和低效的遍历方式。</p>
<p>epoll包含三个函数：</p>
<ul>
<li><p><code>int epoll_create(int size);</code></p>
<p>创建epoll实例，这个实例也是一个文件，所以返回它的文件描述符。使用完这个实例后，需要调用close(epfd)来关闭对应的文件，防止资源耗尽。epoll实例负责存储监听的文件描述符(红黑树)，和就绪的文件描述符(链表)。</p>
</li>
<li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</code></p>
<p>epfd代表先前创建的epoll实例，op代表要执行的操作，fd代表操作执行的对象，event代表要监听的事件(可读、可写、发送错误)，函数返回0代表成功、-1代表失败。</p>
<p>op操作包含：</p>
<ul>
<li>EPOLL_CTL_ADD: 添加一个对fd的监听事件event</li>
<li>EPOLL_CTL_MOD: 修改一个fd的监听事件event内容</li>
<li>EPOLL_CTL_DEL: 删除fd的所有监听事件，此时event参数没有作用</li>
</ul>
<p>epoll_ctl能够设置fd的监听状态，并且设置一个回调函数，当发生相应事件，会调用回调函数将fd添加到就绪队列(链表)上。</p>
</li>
<li><p><code>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code></p>
<p>epoll_wait用于询问当前就绪的fd集合，传入epoll实例fd和关注的events，指定event大小，设置超时时间，与select类似，内核会将就绪队列中的fd放入events，并将就绪数量返回给调用者。</p>
</li>
</ul>
<p>总的来说，epoll有四点不同：</p>
<ol>
<li>它使用红黑树维护监听的fd集合，对数量没有限制，且时间复杂度降低为O(logn)</li>
<li>每个新增的fd只有第一次需要注册到红黑树中，不需要每次询问都拷贝一遍</li>
<li>就绪的fd通过回调函数放入就绪队列，wait时是O(1)的(这里是否需要拷贝链表到用户态还不清楚，如果链表在共享内存中则是O(1)复杂度)，不需要轮询所有监听的fd</li>
<li>epoll支持边缘触发，新就绪的fd只会通知一次(第一次被wait时)，之后不会再重复通知，这样不会重复返回已经不需要的fd。</li>
</ol>
<h2 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO, NIO, AIO"></a>BIO, NIO, AIO</h2><p>BIO、NIO、AIO是jdk对阻塞、非阻塞和异步三种IO模型的实现和封装。</p>
<p>BIO是同步阻塞IO(block)，适用于连接数目<strong>少</strong>且固定的架构；服务器采用一个连接对应一个线程的模式，客户端有连接请求时服务器启动一个线程进行处理</p>
<p>NIO是同步非阻塞IO(Non-block)，适用于连接数目<strong>多</strong>但连接时间<strong>较短</strong>的架构，JDK1.4开始支持；服务期采用一个IO请求对应一个线程的模式，客户端发送的连接请求注册到多路复用器上，当轮询到有IO请求时才启动一个线程进行处理</p>
<p>AIO是异步非阻塞IO(Asynchronous)，适用于连接数目<strong>多</strong>且连接持续时间<strong>较长</strong>的架构，JDK7开始支持；服务器采用一个有效IO请求对应一个线程，客户端的IO请求由内核先完成再通知服务器启动线程进行处理</p>
]]></content>
      <categories>
        <category>Operation System</category>
      </categories>
      <tags>
        <tag>I/O models</tag>
        <tag>Operation System</tag>
      </tags>
  </entry>
  <entry>
    <title>Lock 系列</title>
    <url>/2021/02/24/locks/</url>
    <content><![CDATA[<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>在一些业务场景中，读数据的操作次数远大于写数据，这是如果读写操作都使用独占锁，会非常影响业务性能；如果允许读操作并发，写操作互斥，并且用读锁和写锁的一些获取规则来防止读脏数据，类似于数据库中读写锁的思想，就能解放大部分读操作的等待时间，j.u.c包中的ReentrantReadWriteLock(简称读写锁)就是对这样的读写锁的实现。</p>
<p>读写锁是基于Lock实现的一种读写分离的锁，与ReentrantLock相同的是，它们都借助AQS工具类实现独占锁和共享锁，都支持重入，且都能选择公平锁或非公平锁模式。读写锁的特点是读锁与写锁分离，读锁基于共享锁实现，写锁基于独占锁实现，并增加了读写规则：写锁只有在没有线程获取读锁和写锁的情况下获取成功，读锁只能在没有线程获取写锁的情况下获取成功。</p>
<a id="more"></a>



<h3 id="读写锁获取计数"><a href="#读写锁获取计数" class="headerlink" title="读写锁获取计数"></a>读写锁获取计数</h3><p>要实现读锁、写锁被线程持有状态的逻辑，就需要对读锁和写锁被获取次数计数。在源码中，使用32位的int类型变量保存读锁、写锁的状态，其中高16位保存读锁状态，低16位保存写状态，获取状态时通过位运算提取需要的部分(mask取低位，右移取高位)。注意，虽然写锁是独占锁，只能同时被同一个线程获取，但写锁是可重入的，所以每次重入时会对其计数+1。</p>
<h3 id="写锁获取"><a href="#写锁获取" class="headerlink" title="写锁获取"></a>写锁获取</h3><p>Java8源码是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑其实很清晰，首先获取读写锁状态c和写锁状态w：</p>
<ul>
<li>如果 c != 0 且 w == 0，说明有线程获取了读锁，写锁获取失败；</li>
<li>如果 c != 0 且 current != getExclusiveOwnerThread()，说明有其他线程获取了写锁；</li>
<li>如果不是这两种情况，就可以尝试获取写锁了，使用CAS操作更新写锁状态 (c + 1)。</li>
</ul>
<p>这里可以看出，当前线程在获取读锁后，自己也不能获取写锁进行修改。</p>
<h3 id="写锁释放"><a href="#写锁释放" class="headerlink" title="写锁释放"></a>写锁释放</h3><p>写锁释放使用AQS的实现类中的<code>tryRealse()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先计算出新的读写锁状态(-releases)：</p>
<ul>
<li>如果新状态中的写锁状态归0了，就释放写锁，更新状态；</li>
<li>如果新状态中写锁仍不为0，说明是重入，不释放锁，更新状态。</li>
</ul>
<h3 id="读锁获取"><a href="#读锁获取" class="headerlink" title="读锁获取"></a>读锁获取</h3><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">        <span class="keyword">if</span> (r == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑更简单了，前面部分是获取逻辑，后面部分是对线程持有读锁数量的计数(不具体讲解)：</p>
<ul>
<li>如果写锁被非当前线程获取，则读锁获取失败；</li>
<li>否则，使用 CAS操作尝试修改读锁状态。</li>
</ul>
<h3 id="读锁释放"><a href="#读锁释放" class="headerlink" title="读锁释放"></a>读锁释放</h3><p>读锁释放调用AQS实现类中的<code>tryReleaseShared()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样地，if-else部分是对线程持有读锁数量的计数更新，for部分是读锁的释放：计算出新的锁状态，因为读锁不用释放，只需要修改状态计数，所以用CAS操作尝试更新状态。正如官方注释中说的那样，释放读锁对其他读操作没有影响，但可能使其他在等待的写操作能够获取到写锁，所以这个方法返回一个当前锁状态给调用者。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>实际上，ReentrantReadWriteLock已经覆盖了大量ReentrantLock内部的实现，甚至ReentrantLock要更简单一些(因为不分读锁和写锁)。ReentrantLock主要需要关注的就是重入性的实现(锁计数状态)、独占锁和共享锁(对计数状态的逻辑判断不同)、公平锁和非公平锁(获取锁前是否检查阻塞队列)，其中独占锁和共享锁的逻辑是由AQS实现的。</p>
<h3 id="重入性实现"><a href="#重入性实现" class="headerlink" title="重入性实现"></a>重入性实现</h3><p>与读写锁相同，ReentrantLock的核心就是它的锁状态，通过一个整形数值来表示当前锁被获取的次数：</p>
<ul>
<li>如果是独占锁，则锁状态代表重入次数，只有当锁状态为0时才释放锁。</li>
<li>如果是共享锁，锁状态</li>
</ul>
<h3 id="AQS和ReentrantLock的关系"><a href="#AQS和ReentrantLock的关系" class="headerlink" title="AQS和ReentrantLock的关系"></a>AQS和ReentrantLock的关系</h3><p>AQS(AbstractQueuedSynchronizer)是一个抽象类，其中定义了等待队列的双向链表结构，CAS入队、出队方法，锁的所属者记录，以及独占锁和共享锁不同的获取和排队逻辑。ReentrantLock用抽象静态内部类Sync继承了AQS类，用于实现一些通用的同步器方法，再以静态内部类NonfairSync和FairSync对Sync类进一步继承实现。</p>
<h3 id="NonfairSync和FairSync"><a href="#NonfairSync和FairSync" class="headerlink" title="NonfairSync和FairSync"></a>NonfairSync和FairSync</h3><p>公平锁和非公平锁的区别在于锁的获取过程。在公平锁申请中，尝试修改锁状态之前先判断等待队列中有没有在排队的线程，也就是说自己必须先排队。</p>
<h4 id="非公平锁获取"><a href="#非公平锁获取" class="headerlink" title="非公平锁获取"></a>非公平锁获取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="公平锁获取"><a href="#公平锁获取" class="headerlink" title="公平锁获取"></a>公平锁获取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在读写锁中没有提到(但也存在)的是，如果锁获取失败，还要将当前线程放入等待队列，并打断线程。源码中通过<code>lock()</code>方法来包装一层新的逻辑：</p>
<ul>
<li><p>在非公平锁中，<code>lock()</code>方法先尝试用CAS直接修改锁状态(不管锁是什么状态，先试试能不能改)，成功就直接获得锁，失败了就调用父类AQS实现的<code>acquire()</code>方法，这个方法又会先调用NonfiarSync中实现的<code>tryAcquire()</code>方法试试，也就是上面给出的<code>nonfairTryAcquire()</code>方法，如果又不行，调用AQS实现的<code>acquireQueued()</code>方法把线程放入等待队列，并打断线程。<strong>也就是说</strong>，当一个线程尝试获得锁时，会先尝试“插队”，假如正好抢到了锁，就插队成功，没抢到再乖乖去排队。</p>
</li>
<li><p>在公平锁中，<code>lock()</code>直接调用AQS的<code>acquire()</code>方法，使其调用公平锁的<code>tryAcquire()</code>方法，也就是无论如何都遵从公平排队的原则。</p>
</li>
</ul>
<h4 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种锁的释放逻辑是一样的。</p>
<p>ReentrantLock默认在无参情况下默认使用非公平锁模式，当指定构造器参数为true时才使用公平锁。这是因为非公平锁的吞吐量更大，性能更好，不过缺点显然是线程竞争不公平。</p>
<h3 id="与synchronized的比较"><a href="#与synchronized的比较" class="headerlink" title="与synchronized的比较"></a>与synchronized的比较</h3><p>可重入锁和synchronized锁都是阻塞式同步锁，区别在于：</p>
<ul>
<li>synchronized是关键字，隐式地获得和释放锁；ReentrantLock是类，通过实例化对象可以在代码中显式的获得、释放锁。</li>
<li>ReentrantLock可响应中断，更灵活。</li>
<li>synchronized互斥逻辑是由JVM完成的；ReentrantLock互斥逻辑是由API完成的。</li>
<li>ReentrantLock可以支持公平锁。</li>
</ul>
]]></content>
      <categories>
        <category>Multithread &amp; Concurrency</category>
      </categories>
      <tags>
        <tag>Multithread &amp; Concurrency</tag>
        <tag>Locks</tag>
        <tag>ReentrantReadWriteLock</tag>
        <tag>ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 系列</title>
    <url>/2021/02/25/redis/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Redis是基于内存的、单线程的非关系型数据库。</p>
<p>基于内存是指数据库运行在主存空间中，因此读写速度比硬盘数据库快得多，性能瓶颈从CPU转移到了内存和网络上。</p>
<p>单线程是指数据库仅使用一个线程完成IO复用过程，遍历、拷贝就绪的IO文件到线程中，对IO数据进行读/写处理操作。单线程下不存在线程安全问题，避免了线程频繁地上下文切换，单线程实现的系统可维护性高。在6.0版本后，Redis的处理模型划分为IO复用处理、文件分发、就绪事件读取(从内核拷贝到用户线程)、事件处理器(handler)，其中IO复用、文件分发、事件处理仍然由一个主线程完成，而就绪事件读取采用多线程完成。具体来说，主线程完成IO复用得到返回之后，会将就绪的IO事件分发给多个线程，这些线程负责就绪事件的数据拷贝，将数据从内核拷贝到用户进程，所有线程完成拷贝后，再由主线程的handler模块依次处理这些IO事件。因此这里的多线程并不会产生数据的线程安全问题，因为它们只负责将数据从内核缓冲区拿到Redis进程中，实际的数据读写操作仍然是顺序同步的。</p>
<p>非关系型数据库是以各种抽象形式的数据结构保存在实际地址中的数据库，比如定义键值对数据的存储形式，并将其以哈希表形式抽象使用。相比之下，关系型数据库是固定的表形式，其抽象形式是固定的表格字段与数据行。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Redis在底层使用redis对象来包装不同的数据结构，在一个Redis对象中，包含三个字段，分别是对外的数据结构类型，对内的基础数据结构类型，以及指向具体数据结构地址的指针。</p>
<p>对外的数据结构有string、list、hash、set、zset五种，对内数据结构有int，embstr，sds，哈希表，双向链表，压缩列表，整形集合，跳表8种。</p>
<h3 id="对外数据结构"><a href="#对外数据结构" class="headerlink" title="对外数据结构"></a>对外数据结构</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String是字符串，其底层实现分为三种。如果字符串是纯数字，则用int类型存储；如果是较小的字符串，会用embstr编码的SDS存储；如果是大字符串，使用SDS存储。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List是列表。如果列表的元素长度64字节，且列表元素数量小于512，会使用压缩列表ziplist存储；否则使用双向链表linkedlist存储。</p>
<a id="more"></a>

<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>Hash是哈希表。同List的条件使用ziplist；否则使用Hashtable存储。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set是集合。只有整数类型且元素数量小于512的集合使用intset存储；其他集合使用hashtable存储(所有value指向同一对象)。</p>
<h4 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h4><p>Zset也叫Sorted Set，是有序集合。元素长度小于64且个数小于128时使用ziplist实现，否则使用跳表实现。</p>
<h3 id="对内数据结构"><a href="#对内数据结构" class="headerlink" title="对内数据结构"></a>对内数据结构</h3><h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><p>SDS(Simple Dynamic String)，在3.2版本中有5种长度实现，分别是32Bytes的sdshdr5, 256Bytes的sdshdr8, 64KB的sdshdr16, 4GB的sdshdr32和更大的sdshdr64。</p>
<h5 id="sdshdr结构"><a href="#sdshdr结构" class="headerlink" title="sdshdr结构"></a>sdshdr结构</h5><p>在一个sdshdr数据结构中，包含：</p>
<ul>
<li>len: 已使用长度</li>
<li>alloc: 当前分配的字节数量</li>
<li>flag: sdshdr的种类编号(上述5种的编号)</li>
<li>buf: 指向实际数据数组头部的指针</li>
</ul>
<h5 id="空间预分配策略"><a href="#空间预分配策略" class="headerlink" title="空间预分配策略"></a>空间预分配策略</h5><p>如果修改后的长度小于1MB，采取翻倍的扩容策略；如果大于等于1MB，则使用翻倍+1MB的大小作为扩容后的大小。</p>
<h5 id="惰性空间释放策略"><a href="#惰性空间释放策略" class="headerlink" title="惰性空间释放策略"></a>惰性空间释放策略</h5><p>数据减少时，修改sdshdr中各字段，但不立即释放内存空间。</p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList数据结构中，记录链表的元信息：</p>
<ul>
<li>head: 指向头结点</li>
<li>tail: 指向尾结点</li>
<li>len: 链表长度</li>
<li>dup: 用于复制链表节点保存的值</li>
<li>free: 用于释放链表节点所保存的值</li>
<li>match: 用于对比保存值和另一个输入值是否相等</li>
</ul>
<p>而每个ListNode包含prev和next指针，以及结点的值，构成普通的双向链表。</p>
<p>LinkedList可以保存不同类型的值，具有多态特性。</p>
<h4 id="Ziplist"><a href="#Ziplist" class="headerlink" title="Ziplist"></a>Ziplist</h4><p>压缩列表是由连续内存块构成的顺序数据结构，是列表和哈希表在数据量较小时的底层实现，其连续的内存块被划分为：</p>
<ul>
<li>zlbytes: 整个压缩列表占用的字节数，用于内存重分配或计算zlend位置。</li>
<li>zltail: 列表尾结点与起始地址的偏移量，用于计算列表尾的地址。</li>
<li>zllen: 列表包含的结点数量(仅在值小于4字节时有效)。</li>
<li>entry1, entry2, …, entryN: 结点，其中又由前一个结点的长度、结点内容的类型和结点的内容组成。</li>
<li>zlend: 0xFF(8位1)，表示列表末端。</li>
</ul>
<h4 id="Hash-1"><a href="#Hash-1" class="headerlink" title="Hash"></a>Hash</h4><p>同样地，哈希表数据结构dictht中，记录着哈希表的大小size、哈希掩码sizemask、已有结点的数量used和实际哈希表的指针数组table。</p>
<p>table中的每个值都是一个指向dictEntry结构的指针，dictEntry类似于Java的Map.Entry键值对，其中包含key、val和指向下一个结点的指针，因为redis中的哈希表采用拉链法解决哈希冲突。</p>
<p>Redis使用dict结构封装哈希表，其中主要包括两个哈希表数组ht[0]和ht[1]、计算新hashcode的索引rehashidx，这层包装主要用于扩容。在非扩容状态下，ht[0]存放的是真正的哈希表，当装载因子达到阈值后进行渐进式的扩容，这里的渐进式指的是非一次性把数据拷贝到新的哈希表上，因为一般业务中存储的键值对数据量都是很大的，一次扩容会直接导致服务暂停使用，所以采取均摊的扩容思想：创建新的键值对会根据rehashidx被rehash在ht[1]中，而对旧的键值对的查询会触发对应键值对的rehash操作。</p>
<h4 id="Intset"><a href="#Intset" class="headerlink" title="Intset"></a>Intset</h4><p>整形集合的数据结构包含三部分：</p>
<ul>
<li>encoding: 编码方式，类似但不同于SDS中的flag，表示当前实现的整数类型是16位还是32位还是64位。</li>
<li>length: 元素数量。</li>
<li>contents: 指向数组实际存储位置。</li>
</ul>
<p>整形集合如果插入一个比当前encoding类型更长的整数时，需要对整个数组的所有数据进行升级，且只能升级不能降级。</p>
<h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p>跳表zskiplist包含表头结点、表尾结点、结点数量、最高索引层数level；跳表的结点zskiplistNode包含后退指针、分值score、成员对象ele和level数组。</p>
<p>level数组是每个结点在建立时创建的所有层索引组成的数组，每一层有前进指针——指向同层的下一个索引，和跨度——记录当前索引与下个索引的距离。</p>
<p>score是跳表排序的依据，当score相同时按成员对象ele的大小排序。</p>
<p>ele是唯一的，指向SDS对象。</p>
<p>zskiplist的头结点不存储有效结点，是一个dummyhead，有MAXLEVEL=32层，每层的前进指针都指向能够跳达的结点，或者为null。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Algorithm &amp; Data Structure</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Singleton Pattern</title>
    <url>/2021/01/28/singleton-pattern/</url>
    <content><![CDATA[<p>This post references <a href="https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples">JournalDev</a>, and was written in English for personnal practicing.</p>
<h1 id="Singleton-Pattern"><a href="#Singleton-Pattern" class="headerlink" title="Singleton Pattern"></a>Singleton Pattern</h1><p>Singleton pattern restricts the instantiation of a class and ensures that only one instance of the class exists in the Java virtual machine.</p>
<p>To implement a singleton pattern, we should follow three concepts.</p>
<ul>
<li>Private constructor to prevent new instantiation act from other class.</li>
<li>Private static variable of the same class that is the only instance of the class.</li>
<li>Public static method that returns the instance of the class, providing the only way for outer programs to get the instance of the singleton class.</li>
</ul>
<a id="more"></a>

<h2 id="Implemention-practices"><a href="#Implemention-practices" class="headerlink" title="Implemention practices"></a>Implemention practices</h2><h3 id="1-Eager-initialization"><a href="#1-Eager-initialization" class="headerlink" title="1. Eager initialization"></a>1. Eager initialization</h3><p>In eager initialization, the instance of singleton class is created when class is loaded by Java virtual machine. While it is the easiest way to create a singleton class, it has a drawback that instance is created even if it may not be used by any program.</p>
<p>Implemention is as follows.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerInitializedSingleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EagerInitializedSingleton instance = <span class="keyword">new</span> EagerInitializedSingleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerInitializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerInitializedSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Static-block-initialization"><a href="#2-Static-block-initialization" class="headerlink" title="2. Static block initialization"></a>2. Static block initialization</h3><p>Static block initialization is similar to eager initialization, but implement by using static block and exception throwing.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBlockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StaticBlockSingleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticBlockSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> StaticBlockSingleton();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Exception occured in creating singleton instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticBlockSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Lazy-Initialization"><a href="#3-Lazy-Initialization" class="headerlink" title="3. Lazy Initialization"></a>3. Lazy Initialization</h3><p>Lazy initialization implementation only creates instance at the first time accessed.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitializedSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyInitializedSingleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInitializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInitializedSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazyInitializedSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This implemention is not thread-safe. When two threads are inside the if condition at the same time, they will get different instances of the “singleton” class.</p>
<h3 id="4-Thread-Safe-Singleton"><a href="#4-Thread-Safe-Singleton" class="headerlink" title="4. Thread Safe Singleton"></a>4. Thread Safe Singleton</h3><p>To make above program thread-safe, the easiest way is adding <code>synchronized</code> to the method <code>getInstance()</code>. But notice that we only need to create the instance at the first time (when first few thread in the if condition) method is called. </p>
<p>To avoid extra time-consuming, <strong>double checked locking</strong> principle is used. In this approach, synchronized block is used outside the instance initialization code, with two if condition inside and outside the synchronized block respectively.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitializedSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyInitializedSingleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInitializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadSafeSingleton <span class="title">getInstanceUsingDoubleLocking</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (ThreadSafeSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> ThreadSafeSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The double check part is to prevent later threads in first <code>if</code> block (which wait and get the lock) from creating new instances.</p>
<h3 id="5-Bill-Pugh-Singleton-Implementation"><a href="#5-Bill-Pugh-Singleton-Implementation" class="headerlink" title="5. Bill Pugh Singleton Implementation"></a>5. Bill Pugh Singleton Implementation</h3><p>Still, above implemention used to fail in certain scenarios where large amount of threads try to get the instance simultaneously. So Bill Pugh came up with a different approach to create the Singleton class using an <a href="https://www.journaldev.com/996/java-inner-class">inner static helper class</a>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillPughSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BillPughSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BillPughSingleton INSTANCE = <span class="keyword">new</span> BillPughSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BillPughSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingletonHelper is a static nested/inner class, which gets loaded only when someone calls the <em>getInstance</em> method.</p>
<h3 id="6-Enum-Singleton"><a href="#6-Enum-Singleton" class="headerlink" title="6. Enum Singleton"></a>6. Enum Singleton</h3><p>Enum singleton is used to overcome <strong><em>reflection</em></strong> problem (which can destroy singleton pattern we talked above).</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-SerializedSingleton"><a href="#7-SerializedSingleton" class="headerlink" title="7. SerializedSingleton"></a>7. SerializedSingleton</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializedSingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7604766932017737115L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SerializedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHelper</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SerializedSingleton instance = <span class="keyword">new</span> SerializedSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SerializedSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHelper.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The problem with serialized singleton class is that whenever we deserialize it, it will create a new instance of the class.</p>
</blockquote>
<p><strong><em>Mark to update later.</em></strong></p>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>Singleton Pattern</tag>
        <tag>Design Patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>排序系列</title>
    <url>/2021/02/17/sort/</url>
    <content><![CDATA[<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆 / 优先队列保证在O(log n)的复杂度下插入和维护一个有序数据，有两种实现，一种是跳表，一种是二叉堆。</p>
<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>二叉堆(也是优先队列)的特性可以用来维护TopK的数据，也可以用来排序。</p>
<p>建堆的过程是从最后一个非叶子结点开始，对每个结点从上往下堆化，每次堆化时间与结点高度有关，求和后利用错位相减和等比公式可以得到时间复杂度O(n)；</p>
<p>插入操作是把新数据插入到数组末尾，更新size的同时对末尾位置进行一次从下往上的堆化，时间复杂度为O(logn)；</p>
<p>弹出操作是用O(1)的时间复杂度获取堆顶数据，并用数组末尾的数据覆盖堆顶数据，更新size的同时对堆顶进行一次从上往下的堆化，时间复杂度为O(logn)。</p>
<p>如果维护的是变长的堆，在size达到数据长度时进行扩容；</p>
<p>如果维护的是固定长度的堆(主要用于TopK的场景)，需要注意：</p>
<ul>
<li><p>在堆size没到达固定值之前，按size维护堆；</p>
</li>
<li><p>当size达到设定的固定值后：</p>
<ul>
<li>插入操作时，如果插入的数据小于小顶堆(维护TopK大)的堆顶或大于大顶堆(维护TopK小)的堆顶就可以直接忽略，否则只需要用插入元素覆盖堆顶，并对堆顶做从上往下的堆化即可(而不是插入在堆尾)，时间复杂度也是O(logn)；</li>
<li>定长堆一般不涉及删除操作。</li>
</ul>
</li>
</ul>
<p>而堆排序的过程是在建堆后不断将堆顶元素与数组末尾元素交换，从堆顶进行从上往下的堆化，并将size减1，时间复杂度为O(n*logn)。</p>
<a id="more"></a>



<p>模板：</p>
<p>网上看到的一个比较清晰全面的小顶堆模板，使用时可以按需实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// by @CaptainZ</span></span><br><span class="line"><span class="comment">// 出处不详</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用完全二叉树来构建 堆</span></span><br><span class="line"><span class="comment"> * 前置条件 起点为 1</span></span><br><span class="line"><span class="comment"> * 那么 子节点为  i &lt;&lt;1 和 i&lt;&lt;1 + 1</span></span><br><span class="line"><span class="comment"> * 核心方法为</span></span><br><span class="line"><span class="comment"> * shiftdown 交换下沉</span></span><br><span class="line"><span class="comment"> * shiftup 交换上浮</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * build 构建堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinHeap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> queue[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> <span class="keyword">int</span>[initialCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        size = arr.length;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : arr) &#123;</span><br><span class="line">            queue[i++] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = queue[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((i &lt;&lt; <span class="number">1</span>) &lt;= size) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// child!=size 判断当前元素是否包含右节点</span></span><br><span class="line">            <span class="keyword">if</span> (child != size &amp;&amp; queue[child + <span class="number">1</span>] &lt; queue[child]) &#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; queue[child]) &#123;</span><br><span class="line">                queue[i] = queue[child];</span><br><span class="line">                i = child;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = queue[i];</span><br><span class="line">        <span class="keyword">while</span> ((i &gt;&gt; <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; queue[i &gt;&gt; <span class="number">1</span>]) &#123;</span><br><span class="line">                queue[i] = queue[i &gt;&gt; <span class="number">1</span>];</span><br><span class="line">                i &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = queue[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = queue[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        queue[<span class="number">1</span>] = queue[size--];</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == queue.length - <span class="number">1</span>) &#123;</span><br><span class="line">            queue = Arrays.copyOf(queue, size &lt;&lt; <span class="number">1</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        queue[++size] = val;</span><br><span class="line">        shiftUp(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size &gt;&gt; <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            shiftDown(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Heap heap = <span class="keyword">new</span> Heap(arr);</span><br><span class="line">        heap.buildHeap();</span><br><span class="line">        System.out.println(heap.peek());</span><br><span class="line">        heap.push(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">while</span> (heap.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = heap.pop();</span><br><span class="line">            System.out.printf(num + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关练习：</p>
<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">leetcode-215. 数组中第K大元素</a></p>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><p>跳表是一种索引的数据结构，在每隔k个元素建立索引，并建立多级索引的方式优化查询速度，易知其查询复杂度从O(n)降到O(log^k n)。</p>
<p>Redis的zset数据结构底层实现就是使用的跳表。</p>
<p><em>TODO..</em></p>
<h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><p>随机单pivot，从左往右遍历。快排是O(n*logn)算法中唯一不稳定的算法，因为如果一个新访问的值小于pivot，会与循环不变量i位置交换，如果i位置的值本来在一个相等的值前面，交换之后可能就在后面了。</p>
<p>模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作者：liweiwei1419</span></span><br><span class="line"><span class="comment">// 链接：https://leetcode-cn.com/problems/sort-an-array/solution/fu-xi-ji-chu-pai-xu-suan-fa-java-by-liweiwei1419/</span></span><br><span class="line"><span class="comment">// 来源：力扣-leetcode</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速排序 1：基本快速排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列表大小等于或小于该大小，将优先于 quickSort 使用插入排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INSERTION_SORT_THRESHOLD = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 小区间使用插入排序</span></span><br><span class="line">        <span class="keyword">if</span> (right - left &lt;= INSERTION_SORT_THRESHOLD) &#123;</span><br><span class="line">            insertionSort(nums, left, right);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pIndex = partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, pIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, pIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对数组 nums 的子区间 [left, right] 使用插入排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums  给定数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边界，能取到</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边界，能取到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; left &amp;&amp; nums[j - <span class="number">1</span>] &gt; temp) &#123;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> randomIndex = RANDOM.nextInt(right - left + <span class="number">1</span>) + left;</span><br><span class="line">        swap(nums, left, randomIndex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基准值</span></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> lt = left;</span><br><span class="line">        <span class="comment">// 循环不变量：</span></span><br><span class="line">        <span class="comment">// all in [left + 1, lt] &lt; pivot</span></span><br><span class="line">        <span class="comment">// all in [lt + 1, i) &gt;= pivot</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                lt++;</span><br><span class="line">                swap(nums, i, lt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, lt);</span><br><span class="line">        <span class="keyword">return</span> lt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关练习：</p>
<p><a href="https://leetcode-cn.com/problems/sort-colors/">leetcode-75. 颜色分类</a></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序借助了额外空间，实现了稳定排序，所以在对数据稳定性敏感的场景下，一般是代替快速排序的最好方案。</p>
<p>模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// by @liweiwei1419</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">         <span class="comment">// int mid = left + (right - left) / 2;</span></span><br><span class="line">        <span class="comment">// 如果溢出到符号位，无符号右移可以在除以2的时候将符号位补0，得到正确的结果。</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        mergeSort(nums, left, mid, temp);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        <span class="comment">// 如果数组的这个子区间本身有序，无需合并</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mergeOfTwoSortedArray(nums, left, mid, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeOfTwoSortedArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    System.arraycopy(nums, left, temp, left, right + <span class="number">1</span> - left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == mid + <span class="number">1</span>) &#123;</span><br><span class="line">            nums[k] = temp[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == right + <span class="number">1</span>) &#123;</span><br><span class="line">            nums[k] = temp[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[i] &lt;= temp[j]) &#123;</span><br><span class="line">            <span class="comment">// 注意写成 &lt; 就丢失了稳定性（相同元素原来靠前的排序以后依然靠前）</span></span><br><span class="line">            nums[k] = temp[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// temp[i] &gt; temp[j]</span></span><br><span class="line">            nums[k] = temp[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sortArray(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="comment">// 借助辅助数组</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    mergeSort(nums, <span class="number">0</span>, len - <span class="number">1</span>, temp);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相关练习：</p>
<p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">leetcode-剑指offer-51. 数组中的逆序对</a> </p>
<p>在合并有序数组时，能够判断是否是逆序对：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt;= right; k++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == mid + <span class="number">1</span>) &#123;</span><br><span class="line">        nums[k] = temp[b];</span><br><span class="line">        b++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == right + <span class="number">1</span>) &#123;</span><br><span class="line">        nums[k] = temp[a];</span><br><span class="line">        a++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp[a] &lt;= temp[b]) &#123;</span><br><span class="line">        nums[k] = temp[a];</span><br><span class="line">        a++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nums[k] = temp[b];</span><br><span class="line">        b++;</span><br><span class="line">        <span class="comment">// a到mid的数都比b位置的大</span></span><br><span class="line">        cnt += mid - a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在归并过程中，在递归地对子数组排序的同时计算原有的逆序对，因此子数组与子数组归并时，已经分别获得了它们内部的逆序度，并把两个子数组排好序，所以在融合的时候计算是两个数组间的逆序度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftCnt = mergeSort(nums, left, mid, temp);</span><br><span class="line">        <span class="keyword">int</span> rightCnt = mergeSort(nums, mid + <span class="number">1</span>, right , temp);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftCnt + rightCnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> crossCnt = mergeSortedArray(nums, left, mid, right, temp);</span><br><span class="line">        <span class="keyword">return</span> leftCnt + rightCnt + crossCnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">leetcode-315. 计算右侧小于当前元素的个数</a> </p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序的思想是每次选择一个未排序区间内的最小值，与有序区间的末尾交换。其中蕴含了贪心和减治两大思想。实现时，使用一个循环不变量i，定义[0,i)的区间是有序的，这样每次从无序区间里得到最小值，就把它与i位置交换，i右移一个位置维持定义不变。</p>
<p>选择排序的优点是<strong>交换次数</strong>在所有算法中最少，但<strong>比较次数</strong>仍然是n^2级别，渐进复杂度为O(n^2)。</p>
<p>选择排序是O(n^2)算法中唯一<strong>不稳定</strong>的算法，因为i位置的数会被最小数交换，如果这个i位置的数本来在另一个相等的数前面，交换后可能就在后面了。</p>
<p>模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// by @liweiwei1419</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">int</span> minIndex = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">			minIndex = j;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(nums, i, minIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序与选择排序相反：选择排序是遍历无序区间，每次找到的数都可以添加在有序区间的末尾；而插入排序是遍历有序区间，为无序区间中第一个数找到合适的插入位置。实现时，也是维护循环不变量i，维护[0,i)为有序区间。</p>
<p>时间复杂度也是O(n^2)。</p>
<p>模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>, nums[j-<span class="number">1</span>] &gt; temp; j--) &#123;</span><br><span class="line">        <span class="comment">// 所有大于temp的数都后移一个位置</span></span><br><span class="line">        nums[j] = nums[j-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关练习：</p>
<p><a href="https://leetcode-cn.com/problems/insertion-sort-list/">leetcode-147. 对链表进行插入排序</a></p>
<p>对链表排序，需要从左往右找插入位置，可以从dummyHead查找，就不用考虑头结点的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode lastSorted = head;</span><br><span class="line">ListNode cur = head.next;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastSorted.val &lt;= cur.val) &#123;</span><br><span class="line">        lastSorted = lastSorted.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 找到插入位置: prev.next</span></span><br><span class="line">        ListNode prev = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (prev.next.val &lt;= cur.val) &#123;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先把cur后面的接在有序区间末尾，再把cur插入找到的位置</span></span><br><span class="line">        <span class="comment">// 相当于remove(cur); insert(cur);</span></span><br><span class="line">        lastSorted.next = cur.next;</span><br><span class="line">        cur.next = prev.next;</span><br><span class="line">        prev.next = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = lastSorted.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>Algorithm &amp; Data Structure</category>
      </categories>
      <tags>
        <tag>Heap</tag>
        <tag>Quicksort</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 2</title>
    <url>/2021/02/01/spring-boot/</url>
    <content><![CDATA[<h3 id="Web-开发"><a href="#Web-开发" class="headerlink" title="Web 开发"></a>Web 开发</h3><h4 id="1-静态资源访问"><a href="#1-静态资源访问" class="headerlink" title="1. 静态资源访问"></a>1. 静态资源访问</h4><h5 id="1-1-路径"><a href="#1-1-路径" class="headerlink" title="1.1 路径"></a>1.1 路径</h5><p>静态资源路径包括 <code>/static</code>、 <code>/public</code>、 <code>/resources</code> 、<code>/META-INF/resources</code> ，访问 <em>根路径 + 静态资源名</em> 即可访问对应的静态资源，如： /picture123.jpg</p>
<p>其原理是使用静态映射/**，当访问请求找不到对应的Controller，再交给静态资源处理器，如果静态资源处理器也找不到就返回404。</p>
<p>在application.yaml文件中使用<code>  static-path-pattern</code>修改配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">mvc:</span></span><br><span class="line">	<span class="attr">static-path-pattern:</span> <span class="string">/resources/**</span></span><br></pre></td></tr></table></figure>
<p>相应地，<code>static-location: [classpath: /xxx/]</code> 用来重新设置多个静态资源路径</p>
<a id="more"></a>









]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Framework</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized 关键字</title>
    <url>/2021/02/24/synchronized/</url>
    <content><![CDATA[<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>synchronized关键字的设计目的很简单，就是悲观地认为线程间的并发操作会引发线程安全问题，由此设计出在这种场景下使用的同步互斥机制，但由最初的重量级阻塞方案优化为后来的锁升级方案，保证不同的线程竞争规模下的程序执行效率。</p>
<h3 id="synchronized与字节码"><a href="#synchronized与字节码" class="headerlink" title="synchronized与字节码"></a>synchronized与字节码</h3><p>当synchronized关键字修饰方法时，对应的字节码处会有ACC_SYNCHRONIZED标识来隐式使用monitor_enter/monitor_exit；</p>
<p>当修饰代码块时，对应的字节码显式地使用monitor_enter/monitor_exit。</p>
<a id="more"></a>

<h3 id="synchronized-的-happens-before-原则"><a href="#synchronized-的-happens-before-原则" class="headerlink" title="synchronized 的 happens-before 原则"></a>synchronized 的 happens-before 原则</h3><p>对一个monitor的解锁 happens-before 于随后对同一个monitor的加锁，由于happens-before的传递性以及as-if-serial原则，保证了程序运行结果的线程安全型。</p>
<h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>在一些高并发场景中，如果只有少量线程操作会产生线程安全问题，或者只有小部分时间产生线程安全问题，那么使用moniter锁会严重影响程序效率。因此优化了synchronized关键字，使其成为动态的、可升级的锁。</p>
<img src="/2021/02/24/synchronized/markword.png" class="">



<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是synchronized对象的初始锁状态，它在对象头中记录线程ID和epoch，来表示当前锁的偏向线程。</p>
<h5 id="偏向锁的获取"><a href="#偏向锁的获取" class="headerlink" title="偏向锁的获取"></a>偏向锁的获取</h5><p>当一个线程获取一个synchronized对象时，如果其对象头的锁状态为偏向锁，则检查其Thread ID：</p>
<ul>
<li>如果Thread ID是当前线程，则已经获取了锁，开始执行同步代码块；</li>
<li>如果不是，尝试用CAS操作替换Thread ID为当前线程：<ul>
<li>如果成功，获得锁，开始执行同步代码块；</li>
<li>如果失败，进入偏向锁<strong>撤销/升级</strong>过程。</li>
</ul>
</li>
</ul>
<h5 id="偏向锁的撤销和升级"><a href="#偏向锁的撤销和升级" class="headerlink" title="偏向锁的撤销和升级"></a>偏向锁的撤销和升级</h5><p>首先我们需要知道，synchronized锁在初始状态是偏向锁，当发生竞争时，有可能撤销为无锁状态，也可能升级为轻量级锁，选择的依据就是当前发生的竞争是同步(实时)发生的竞争、还是“历史”(已经退出同步块的线程)竞争。偏向锁撤销过程开始的条件是当有线程尝试CAS修改偏向锁Thread ID时修改失败，这时，等待持有锁的线程执行到safepoint时暂停线程，对其进行检查：</p>
<ul>
<li>如果线程已经不存活或者退出了同步块，则把偏向锁撤销为无锁状态，唤醒原线程，而当前线程继续CAS操作修改Thread ID(回到偏向锁的获取阶段)；</li>
<li>如果线程未退出同步代码块，则升级为轻量级锁：<ul>
<li>在原持有锁的线程栈中分配Lock Record空间，把对象头的Mark Word拷贝到Lock Record中，修改对象头Mark Word的前面部分(除了锁标识位)为指向Lock Record的指针，此时原线程获得了轻量级锁，唤醒原线程；</li>
<li>当前线程则开始轻量级锁的<strong>获取</strong>过程。</li>
</ul>
</li>
</ul>
<p>偏向锁和无锁状态其实比较类似，所以锁标识位都为01，之所以要区分是为了重入逻辑简单(如果是偏向锁就判断重入)，偏向锁或者无锁升级为轻量级锁的原则或者说思想很简单：不能让我等待(只要持有锁的线程还在执行同步代码块，当前线程就只能等待)，一旦我要等待，就升级轻量级锁。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>轻量级锁如前提到的，通过在Mark Word中分配指向线程栈中的Lock Record，来表示对象被这个线程占用。而Lock Record就是线程占用对象之前的Mark Word的拷贝，也被称为Displaced Mark Word，用于锁的释放。</p>
<h5 id="轻量级锁的获取"><a href="#轻量级锁的获取" class="headerlink" title="轻量级锁的获取"></a>轻量级锁的获取</h5><p>如果一个线程检测到当前对象的锁状态为轻量级锁，会先把Mark Word拷贝到当前线程栈的Lock Record中，然后尝试CAS操作修改对象的锁指针，使其指向自己的Lock Record：</p>
<ul>
<li>如果成功，获得轻量级锁，开始执行同步代码块；</li>
<li>如果失败，自旋地使用CAS操作尝试修改锁指针，如果次数耗尽，就升级为重量级锁：<ul>
<li>暂停原线程，修改锁状态，修改锁指针为指向monitor的指针，原线程获取重量级锁，唤醒原线程；</li>
<li>当前线程进入阻塞队列。</li>
</ul>
</li>
<li>如果是重入(修改前和修改后相等)，则将Lock Record设为null。</li>
</ul>
<h5 id="轻量级锁的解锁"><a href="#轻量级锁的解锁" class="headerlink" title="轻量级锁的解锁"></a>轻量级锁的解锁</h5><p>轻量级锁的释放就是尝试用CAS操作将线程的Lock Record替换回对象头的Mark Word(重入的释放什么都不用做，也不用替换回去)：</p>
<ul>
<li>如果成功则对象恢复了之前的状态，释放成功；</li>
<li>如果失败，则升级为重量级锁：<ul>
<li>当前线程获得monitor，并释放monitor；</li>
<li>其他线程竞争重量级锁的monitor。</li>
</ul>
</li>
</ul>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁就是原来的synchronized监视器锁，在对象头的Mark Word中锁标识位为10，前面部分为指向monitor的指针。</p>
<p>monitor是由C++代码实现、java代码包装的，在java被包装为一个名为ObjectMonitor的对象，其中包含几个主要字段：</p>
<ul>
<li>recursions: 线程重入次数</li>
<li>object: Monitor对象</li>
<li>owner: 持有者</li>
<li>waitSet: wait状态的线程列表</li>
<li>cxq: 单向列表</li>
<li>entryList: block状态线程列表</li>
</ul>
<p>ObjectMonitor的方法中包含大量的CAS操作(相比膨胀前的各种锁CAS操作次数)，需要大量的内核态和用户态的切换，因此非常耗费资源和时间(比轻量级锁的CPU自旋更加耗资源)。</p>
]]></content>
      <categories>
        <category>Multithread &amp; Concurrency</category>
      </categories>
      <tags>
        <tag>Multithread &amp; Concurrency</tag>
        <tag>synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile 关键字</title>
    <url>/2021/02/07/volatile/</url>
    <content><![CDATA[<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><p>volatile解决的问题：针对变量的轻量级同步解决方案。</p>
<p>由于cpu读写速度与主存之间存在巨大的差异，所以Java的内存模型中，每个cpu的线程把共享变量从主存拷贝到自己cpu内的工作内存，来保证处理速度。这就会产生各线程的工作内存间数据不可见的问题。解决数据可见性，就解决了针对变量级别的同步机制。</p>
<h3 id="缓存可见性与指令重排序"><a href="#缓存可见性与指令重排序" class="headerlink" title="缓存可见性与指令重排序"></a>缓存可见性与指令重排序</h3><p>JVM的内存模型(堆、栈、方法区)实际上是一种抽象概念，其实际内存可能散落在主存、CPU高速缓存和CPU寄存器中，不受JVM本身决定。在线程内存模型中，每个线程都有自己的工作内存，这也是与操作系统内存模型不同的抽象，每个线程的本地内存实际上对应线程执行时从主存中拷贝到cpu cache的内存。在多CPU环境下，不同CPU的线程使用不同的cpu cache，所以存在缓存一致性问题。为了使缓存一致，需要使一个CPU的缓存修改后对其他CPU可见。</p>
<p>操作系统为了优化指令运行过程，会对程序调用的指令重新排序，使其执行结果与顺序执行一致(用户无感知)，但执行顺序可能发生了改变。在多线程并发环境下，指令重排序可能导致最终的执行结果发生错误。</p>
<p>volatile通过插入内存屏障来禁止指令重排序，从而保证缓存的可见性。</p>
<a id="more"></a>



<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>对一个volatile域的写 happens-before 任意<strong>后续</strong>对这个volatile域的任意操作。</p>
<h3 id="原理-amp-过程"><a href="#原理-amp-过程" class="headerlink" title="原理&amp;过程"></a>原理&amp;过程</h3><ol>
<li>对volatile变量的写操作由JVM转为带有Lock前缀的机器指令；</li>
<li>处理器收到带Lock的指令会将缓存写回主存，并通过总线向其他处理器发送电信号；</li>
<li>其他处理器收到信号，把自己的缓存标记为失效；</li>
<li>当处理器读取到失效的缓存，会从主存中重新拉取缓存。</li>
</ol>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>JMM在保证happens-before关系的前提下，尽可能允许编译器和处理器对指令序列重排序。为了实现这一点，做了两件事：</p>
<ol>
<li>创造出<strong>内存屏障</strong>指令，根据读写顺序对应四种指令，分别是LoadLoad, StoreStore, LoadStore, StoreLoad。通过在指令序列中间插入这些屏障指令，来禁止特定类型的处理器重排序；</li>
<li>找到所有不符合happens-before原则的指令序列（下表）。需要注意的是，编译器难以做到为一个程序找到能插入最少屏障次数的重排序方案，所以为了覆盖图中的情况，并且简化逻辑，用4条规则来覆盖这些情况（覆盖范围会多出一点，但保证了规则的简单）：<ul>
<li><strong>volatile写</strong>操作<strong>前</strong>插入StoreStore屏障</li>
<li><strong>volatile写</strong>操作<strong>后</strong>插入StoreLoad屏障</li>
<li><strong>volatile读</strong>操作<strong>后</strong>插入LoadLoad屏障</li>
<li><strong>volatile读</strong>操作<strong>后</strong>插入LoadStore屏障</li>
</ul>
</li>
</ol>
<table>
   <tr>
      <td colspan="1">是否能重排序</td>
      <td colspan="3">第二个操作</td>
   </tr>
   <tr>
      <td>第一个操作</td>
      <td>普通读/写</td>
      <td>volatile读</td>
      <td>volatile写</td>
   </tr>
   <tr>
      <td>普通读/写</td>
      <td></td>
      <td></td>
      <td>x</td>
   </tr>
   <tr>
      <td>volatile读</td>
      <td>x</td>
      <td>x</td>
      <td>x</td>
   </tr>
   <tr>
      <td>volatile写</td>
      <td></td>
      <td>x</td>
      <td>x</td>
   </tr>
</table>


<h3 id="原子性、有序性、可见性"><a href="#原子性、有序性、可见性" class="headerlink" title="原子性、有序性、可见性"></a>原子性、有序性、可见性</h3><p>由volatile的原理和实现中我们可以看出，volatile关键词可以禁止会引起错误结果的指令重排序，并保证数据的写入是对所有线程可见的，因此volatile具有有序性和可见性，但是volatile不能保证原子性。</p>
<p>最经典的例子是volatile变量的自增运算，包括读、计算新值、写三个操作。在这个例子中，最让我困惑的是既然happens-before原则中保证了对volatile变量的写happens-before对它的任意操作，这样其他的读操作不是应该禁止被排到这个写操作的前面，也就不会导致错误吗？</p>
<p>实际上这里是对重排序陷入了误解，首先happens-before的定义中是这样写的：</p>
<blockquote>
<p><em>A write to a volatile field (§8.3.1.4) happens-before every subsequent read of that field.</em></p>
</blockquote>
<p>也就是说，本身线程顺序如果是：线程A的最后一步write -&gt; 线程B的第一步read，那么happens-before保证编译器和处理器不会把线程B的read重排序到线程A的write前。但是，如果原本的程序顺序就是线程B的read发生在线程A的write前，就没办法了：线程A和B都对原值加1，它们先后写入内存并刷新到工作内存，最后原值少加了一次1。因此有序性和可见性并不能帮助它获得原子性，这也解释了为什么volatile的原子操作能够保证线程安全：有序性保证一个线程先完成，可见性保证先完成的线程刷新主存，又因为是原子操作，所以完成后就结束了，不具有后效性。</p>
<style>
  table th,
  table td {
    text-align: center !important;
  }
</style>]]></content>
      <categories>
        <category>Multithread &amp; Concurrency</category>
      </categories>
      <tags>
        <tag>Multithread &amp; Concurrency</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Wordpress Docker部署</title>
    <url>/2021/01/23/wordpress/</url>
    <content><![CDATA[<h4 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install docker-ce</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>


<h4 id="安装-docker-compose"><a href="#安装-docker-compose" class="headerlink" title="安装 docker-compose"></a>安装 docker-compose</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown -R nz /usr/<span class="built_in">local</span>/bin</span><br><span class="line">sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo ln -s /usr/<span class="built_in">local</span>/bin/docker-compose /usr/bin/docker-compose <span class="comment">#把它放入PATH中，这样才能sudo</span></span><br></pre></td></tr></table></figure>


<h4 id="卸载-docker"><a href="#卸载-docker" class="headerlink" title="卸载 docker"></a>卸载 docker</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum list installed|grep docker</span><br><span class="line">yum -y remove</span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>


<h4 id="卸载-docker-compose"><a href="#卸载-docker-compose" class="headerlink" title="卸载 docker-compose"></a>卸载 docker-compose</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo rm /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure>


<h4 id="docker-国内镜像"><a href="#docker-国内镜像" class="headerlink" title="docker 国内镜像"></a>docker 国内镜像</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>


<h4 id="修改docker内的mysql表ip地址"><a href="#修改docker内的mysql表ip地址" class="headerlink" title="修改docker内的mysql表ip地址"></a>修改docker内的mysql表ip地址</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it my_wordpress_db_1 bash</span><br><span class="line">mysql -u wordpress -p</span><br><span class="line">Enter password: wordpress</span><br><span class="line">show databases;</span><br><span class="line">USE wordpress</span><br><span class="line">select * from wp_options limit 2;</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> UPDATE wp_options SET option_value=<span class="string">&quot;zayeum.com&quot;</span> WHERE option_name=<span class="string">&quot;siteurl&quot;</span>;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> UPDATE wp_options SET option_value=<span class="string">&quot;zayeum.com&quot;</span> WHERE option_name=<span class="string">&quot;home&quot;</span>;</span></span><br><span class="line">update wp_options set option_value=&#x27;http://www.zayeum.com:80&#x27; where option_name in (&#x27;siteurl&#x27;,&#x27;home&#x27;);</span><br><span class="line">update wp_options set option_value=&#x27;localhost:9977&#x27; where option_name in (&#x27;siteurl&#x27;,&#x27;home&#x27;);</span><br></pre></td></tr></table></figure>


<h4 id="Docker-服务管理"><a href="#Docker-服务管理" class="headerlink" title="Docker 服务管理"></a>Docker 服务管理</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl restart  dockers</span><br><span class="line">sudo systemctl stop docker</span><br><span class="line">sudo service docker restart</span><br><span class="line">sudo service docker stop</span><br><span class="line">sudo systemctl daemon-reload  <span class="comment"># 重启守护进程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start firewalld</span><br><span class="line"></span><br><span class="line">sudo firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line">sudo firewall-cmd  --reload</span><br><span class="line">sudo firewall-cmd --zone=public --list-ports</span><br></pre></td></tr></table></figure>


<h4 id="Docker-容器管理"><a href="#Docker-容器管理" class="headerlink" title="Docker 容器管理"></a>Docker 容器管理</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker stop $(docker ps -aq)</span><br><span class="line">sudo docker container prune</span><br><span class="line">sudo docker image prune</span><br><span class="line">sudo docker-compose down</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>Wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础</title>
    <url>/2021/01/28/java-basics/</url>
    <content><![CDATA[<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>括号</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td>正负号、非、反、自增自减</td>
<td>从右向左</td>
</tr>
<tr>
<td>3</td>
<td>*  /  %</td>
<td>从左到右</td>
</tr>
<tr>
<td>4</td>
<td>+(加)  -(减)</td>
<td>从左到右</td>
</tr>
<tr>
<td>5</td>
<td>位移符号</td>
<td>从左到右</td>
</tr>
<tr>
<td>6</td>
<td>&lt; &lt;= &gt; &gt;= instanceof</td>
<td>从左到右</td>
</tr>
<tr>
<td>7</td>
<td>== !=</td>
<td>从左到右</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>9</td>
<td>^ (异或)</td>
<td>从左到右</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>从左到右</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>从左到右</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>14</td>
<td>=  +=  -=  *=  /=  %=  &amp;=  |=  ^=  ~=  &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td>
<td>从右向左</td>
</tr>
</tbody></table>
<a id="more"></a>

<h3 id="右移-gt-gt-gt-gt-gt"><a href="#右移-gt-gt-gt-gt-gt" class="headerlink" title="右移 &gt;&gt;/&gt;&gt;&gt;"></a>右移 &gt;&gt;/&gt;&gt;&gt;</h3><ul>
<li>&gt;&gt; 是带符号右移，符号位被移走后用原来的符号填充，等同于把一个值除以2，所以也叫算术右移；</li>
<li>&gt;&gt;&gt; 是无符号右移，符号位被移走后用0填充，并不考虑其中的算术含义，也叫逻辑右移。</li>
</ul>
<h3 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>​        多个方法可以有相同的名字和不同的参数，这种特征叫做<strong>重载</strong>。编译器通过各方法给出的参数与调用时填入的参数类型进行匹配来挑选出合适的方法，这个过程叫做<strong>重载解析</strong>(overloading resolution)。</p>
<p>​        方法的<strong>签名</strong>(signature)包括方法名和参数类型，而不包括返回值类型。</p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><ol>
<li><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
</li>
<li><p>抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>
</li>
<li><p>构造方法无法被重写</p>
</li>
<li><p>如果方法的返回类型是void和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。</p>
</li>
</ol>
<h3 id="面向对象编程三大特性"><a href="#面向对象编程三大特性" class="headerlink" title="面向对象编程三大特性"></a>面向对象编程三大特性</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><em>封装</em> 把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><em>继承</em> 是使用已存在的类的定义作为基础建立新类的技术，使用继承我们能够非常方便地复用以前的代码。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p><em>多态</em> 可以通过继承和接口两种方式实现</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>被static修饰的变量是类变量，在被JVM加载时跟随class信息放入栈空间，可以被修改，但所有实例都会共享同一份值。</p>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h4><p>final关键词表示一个常量，它的值在初始化之后就不能再修改。</p>
<p>被final修饰的静态变量只能在<strong>声明时</strong>或<strong>静态初始化块</strong>内初始化；</p>
<p>被final修饰的非静态变量还可以在<strong>构造器</strong>中初始化；</p>
<p>被final修饰的局部变量可以在生命周期内的任意时候初始化。</p>
<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><p>final修饰的方法不能被子类重写</p>
<p>final修饰的方法可以被重载</p>
<h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h4><p>final修饰的类不能被子类继承，如果使用private和final修饰final类的成员变量，且只提供getter方法，那么这个类就是不变类。</p>
<h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><p>Java中的参数变量是按值传递(called by value)的，通俗的说，不管参数是<strong>基础数据类型</strong>还是<strong>对象引用</strong>，方法接收的参数 <em>永远</em> 是参数值的副本。</p>
<p>也就是说，如果我们在方法内修改参数的值，那么作为局部变量的副本参数在方法完成后就被丢弃了，并不会影响方法外原参数的值。不管是修改基础数据类型参数，还是修改对象引用参数，都只是作用在副本上；</p>
<p>但是，如果要修改引用的对象内的属性，是可以生效的：因为 <strong>对象引用的副本</strong> 与 <strong>原对象引用</strong> 指向的是同一个对象，我们是根据这个引用找到对象并修改对象的值，并没有试图修改<strong>原对象引用</strong>的值。</p>
<p>举一个例子：如果a是person对象的引用，方法接收的参数是a的副本b，那么a和b都引用的是person对象。此时我们无法通过让b引用别的对象（通过修改b的值），来让a引用别的对象（来修改a的值）；但我们能通过b修改person对象的属性，因为不管对b的引用操作还是对a的引用操作，最终都是对person操作。</p>
<h3 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h3><p>一个很容易忽视的细节是，局部变量必须初始化才能使用，而类中的字段如果不初始化值，会自动初始化为默认值(0, false, null)。例如在Java8的HashMap源码中无参构造器就没有为threshold变量初始化，但其在后续的逻辑中以0生效。</p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>如果一个类没有写任何构造器，就会有一个隐式的无参构造器，将所有实例变量设置为默认值；</p>
<p>如果写了有参构造器，但没有无参构造器，在调用无参构造器时就会产生错误。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>嵌套类(nested class)分为静态和非静态两种，分别称为静态嵌套类(static nested class)和内部类(Inner class)。</p>
<h4 id="1-成员内部类"><a href="#1-成员内部类" class="headerlink" title="1. 成员内部类"></a>1. 成员内部类</h4><p>在一个类内定义另一个内，内部的这个类就叫成员内部类，相对地，外层的类叫外部类。</p>
<ul>
<li><p>成员内部类可以访问外部类的<strong>所有</strong>成员属性和方法（包括private和static成员），因为编译后的字节码为内部类构造器传入了指向外部类对象的引用（指针）。</p>
</li>
<li><p>当成员内部类和外部类有同名的成员变量或方法时，默认调用的是内部类的成员，如果要调用外部类的同名成员，需要使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.xxxVariable</span><br><span class="line">外部类.<span class="keyword">this</span>.xxxMethod</span><br></pre></td></tr></table></figure></li>
<li><p>而外部类访问内部类的成员时，需要先创建外部类的对象，再通过外部类对象创建内部类对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类类名.内部类类名 xxx = <span class="keyword">new</span> 外部类类名.内部类类名()</span><br></pre></td></tr></table></figure></li>
<li><p>要在其他地方创建一个内部类的对象，则需要先创建外部类对象，通过外部类的方法获得其内部类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner inner = outter.getInner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;</span><br><span class="line">        String common = <span class="string">&quot;outter&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> Outter.<span class="function">Inner <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            String common = <span class="string">&quot;inner&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(Outter.<span class="keyword">this</span>.common);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="2-静态内部类"><a href="#2-静态内部类" class="headerlink" title="2. 静态内部类"></a>2. 静态内部类</h4><p>静态内部类 (static nested class) 就是静态的成员内部类 (Inner class)，与之不同的是静态内部类不需要依赖与外部类，相应地，静态内部类只能访问外部类的静态成员（因为非静态成员依附于具体的对象）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span></span>&#123;</span><br><span class="line">        String common = <span class="string">&quot;outter&quot;</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            String common = <span class="string">&quot;inner&quot;</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3. 局部内部类"></a>3. 局部内部类</h4><p>定义在一个方法或作用于里面的类，相当于一个局部变量，不能有权限修饰符，仅限于方法或作用域内部访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4. 匿名内部类"></a>4. 匿名内部类</h4><p>匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>匿名内部类/局部内部类只能访问局部final变量。因为内部类和外部类的生命周期可能不同，编译器会为内部类传入变量的拷贝值，同时，为了防止数据不一致，必须使用final修饰来防止内部类改变这个值。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="产生条件"><a href="#产生条件" class="headerlink" title="产生条件"></a>产生条件</h4><p>互斥：一个资源只能被一个进程/线程使用。</p>
<p>请求与保持：一个进程/线程因请求资源而阻塞时，不会释放之前获得的资源。</p>
<p>不剥夺：进程已获得的资源不可被强行剥夺。</p>
<p>循环等待：死锁中的线程头尾相接形成循环等待的局面。</p>
<h4 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h4><p>使用jstack 可以查看线程快照，如果发生死锁，会将等待资源信息和死锁提示显示在对应线程的信息中。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li>固定上锁顺序：按锁对象的hashcode顺序进行上锁，这样所有线程都会遵循同一个顺序申请锁，避免“循环等待”条件。</li>
<li>开放调用：修改锁范围，从锁方法改为锁代码块</li>
<li>定时锁：超时则放弃，打破“请求与保持”条件。tryLock()</li>
</ol>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常都是派生于Throwable类的类实例，其中分为Error和Exception。Error产生于Java运行时系统的内部错误和资源耗尽错误，Exception分为运行时异常(Runtime Exception)和其他异常(如IO异常)。Error可能产生于任何代码中，程序员无法准确判断代码是否会产生Error，因为还取决于硬件等条件；运行时异常，比如数组越界、访问空指针、错误的强制类型转换，应该在编程时主动避免，而不是在代码中抛出异常或处理异常。Java语言规范将Error和Runtime Exception归为非检查型异常，其他的异常为检查型异常。基于前面描述的理由，非检查型异常不应当在代码中检查抛出，而应该主动避免或者根本无法预测；而检查型异常，比如文件不存在等异常，应该在程序方法中注明可能抛出，并在合适的位置捕获和处理。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">线程池原理及在美团业务中的实践</a></p>
<p>线程池负责统一管理线程的创建/关闭以及任务的执行，其内部构建了一个生产者消费者模型，使用一个阻塞队列来缓冲用户提交的任务，根据线程池的设计需求来决定何时从阻塞队列的队首取出任务，分配给线程执行。</p>
<h4 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h4><p>线程池有5种状态：</p>
<ul>
<li>RUNNING：正常运行状态，通过阻塞队列、核心线程数、最大线程数来管理线程和任务</li>
<li>SHUTDOWN：不再接收新的任务，会继续处理正在运行的和阻塞队列中的任务</li>
<li>STOP：不再接收新任务，放弃阻塞队列的任务，并且中断正在处理的任务</li>
<li>TIDYING：关闭前的状态，此时没有执行的任务，有效线程数为0</li>
<li>TERMINATED：terminated方法执行后的状态，表示已经关闭</li>
</ul>
<p>在线程池的生命周期中，运行中的线程池被调用shutdown()会进入SHUTDOWN状态，被调用shutdownNow()会进入STOP状态；</p>
<p>SHUTDOWN状态时，如果所有任务都执行完成(包括阻塞队列中的)，且工作线程数为0时，会进入TIDYING状态；</p>
<p>STOP状态时，工作线程数为0时进入TYDYING状态；</p>
<p>TYDYING状态通过调用terminated方法进入TERMINATED状态。</p>
<h4 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h4><p>ArrayBlockingQueue是基于数组的有界阻塞队列</p>
<p>LinkedBlockingQueue是基于链表的有界(Integer.MAX_VALUE)阻塞队列</p>
<p>PriorityBlockingQueue是基于优先级排序的无界队列，默认自然序排序，可以实现compareTo()</p>
<p>DelayQueue是基于PriorityBlockingQueue的无界队列，可以指定多久才从队列中获取当前元素，从而延时执行任务</p>
<p>SynchronousQueue是不存储元素的阻塞队列，每一个put操作必须等待take操作才能添加元素</p>
<p>LinkedTransferQueue是基于链表的无界阻塞队列，比LinkedTransferQueue多了transfer和tryTransfer方法</p>
<p>LinkedBlockingDeque是基于链表的双向阻塞队列</p>
<h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><p>在线程池中，Worker类基于AQS类实现了不可重入的独占锁，每个worker对象持有一个线程对象和runnable对象，代表对应的线程和执行的任务</p>
<h4 id="线程池的配置"><a href="#线程池的配置" class="headerlink" title="线程池的配置"></a>线程池的配置</h4><p>CPU密集型的任务应该配置少量线程，如NCPU+1；IO密集型任务需要等待IO操作，所以应该配置尽可能多的线程，如NCPU*2。</p>
<p>如果核心线程数设置过少，而实际业务的流量很大，会出现大量拒绝服务的情况，触发接口降级。</p>
<p>如果队列容量设置过大，则会导致大量任务阻塞在队列中，最大线程数失效，而下游服务的大量调用因为超时而失败。</p>
<p>线程池提供了一系列set方法，使其可以在运行时动态地更改线程池参数，而线程池能够根据新的参数进行相应的调整。</p>
<h2 id="Java-源码"><a href="#Java-源码" class="headerlink" title="Java 源码"></a>Java 源码</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>我们知道HashMap通过对key计算哈希值来高效存取映射关系，当遇到哈希冲突，对应位置的结点会以链表的形式向下扩展。这里具体聊一下Java 8中，HashMap的实现逻辑。</p>
<p>首先，在调用构造函数时，如果没有指定初始大小和装载因子，会使用默认的装载因子0.75、初始阈值0、初始大小16。其中<strong>阈值</strong>的含义是当装填的因子超过该值时就扩容。注意：构造函数只是设定了参数值，并没有创建数组。</p>
<p>当调用<code>put()</code>方法时，实际上执行的是<code>putVal()</code>方法，<code>put()</code>方法帮我们隐藏了<code>onlyIfAbsent</code>和<code>evict</code>参数。前者为true表示遇到相同键值不进行覆盖，默认为false；后者为false表示table在创造模式(creation mode)，默认为true。</p>
<p>在<code>putVal()</code>方法中，首先判断table（hashmap数据结构的变量名）是否为null，如果为null会先通过<code>resize()</code>方法创建一个初始table。</p>
<p><code>resize()</code>方法用于扩容和初始化，具体来说，是根据table.length和threshold两个参数判断：</p>
<ul>
<li>如果table.length == 0，说明哈希表还没有创建，此时分两种情况：<ul>
<li>threshold &gt; 0：把容量设置成threshold的大小；</li>
<li>threshold == 0：把容量设置成默认的16，threshold设置成装载因子*16；</li>
</ul>
</li>
<li>如果table.length &gt; 0，说明是需要扩容，也分两种情况：<ul>
<li>容量已经超过最大容量的阈值，不能再扩容了，只能把threshold设置成MAX_VALUE，继续使用剩下的空间；</li>
<li>容量还没超过最大值，将容量和threshold都扩大一倍。</li>
</ul>
</li>
</ul>
<p>定好新的参数后，创建一个新的数组，把旧数组的数据拷贝到新数组上。</p>
<p>接着，通过对key的哈希值hash取table.length的模来定位：</p>
<ul>
<li>如果这个位置是空的，在这个位置创建一个键值对结点；</li>
<li>否则存在三种情况：<ul>
<li>哈希值相等，key值也相等，说明是存在相同的键，应该覆盖；</li>
<li>数组的这个位置存储的不是Node&lt;K, V&gt;对象，而是TreeNode&lt;K, V&gt;对象，使用<code>putTreeVal()</code>方法来插入值；</li>
<li>否则，说明发生了哈希冲突（碰撞），应该把值加在该位置链表的末尾。插入之后，如果链表长度超过了<strong>树化</strong>的阈值，则将链表Node转为树TreeNode。</li>
</ul>
</li>
</ul>
<p>这其中有几点需要解释：</p>
<ol>
<li>HashMap的底层实现中，如果一个位置的链表长度超过阈值(8)，就会转为树结构（树化）；</li>
<li>链表结构是自定义的Node&lt;K, V&gt;类，实现自Map.Entry&lt;K, V&gt;接口；树结构是自定义的TreeNode&lt;K, V&gt;类，继承自LinkedHashMap.Entry&lt;K, V&gt;类，而LinkedHashMap的Entry类实际上就是继承自HashMap本身的Node类；简单地说，它们的关系是：<ul>
<li>Map.Entry&lt;K, V&gt;接口  &lt;=  HashMap.Node&lt;K, V&gt;类  &lt;=  LinkedHashMap.Node&lt;K, V&gt;类  &lt;=  HashMap.TreeNode&lt;K, V&gt;类</li>
</ul>
</li>
</ol>
<h4 id="树化逻辑"><a href="#树化逻辑" class="headerlink" title="树化逻辑"></a>树化逻辑</h4><p><em>待更新</em></p>
<h5 id="为什么HashMap的size必须是2的幂次方"><a href="#为什么HashMap的size必须是2的幂次方" class="headerlink" title="为什么HashMap的size必须是2的幂次方"></a>为什么HashMap的size必须是2的幂次方</h5><p>哈希函数计算出的hashcode是32位长度的int值，需要用模运算映射到对应的哈希数组中，如果数组长度为2的整数幂，则可以通过size-1作为掩码，使用(size-1)&amp;hash来实现模运算，速度比%运算符更快。</p>
<h5 id="为什么要先比较hashcode，再比较equals，为什么需要两个比较过程"><a href="#为什么要先比较hashcode，再比较equals，为什么需要两个比较过程" class="headerlink" title="为什么要先比较hashcode，再比较equals，为什么需要两个比较过程"></a>为什么要先比较hashcode，再比较equals，为什么需要两个比较过程</h5><p>hashcode设计出来用于快速比较两个对象是否相同，因为相同对象的hashcode一定相等，所以如果两个对象的hashcode不同，对象一定不相等。基于此，可以在执行equals判断方法之前先执行更快的hashcode比较，因为hashcode是32位整形数字，相比自定义的字段比较规则更快，可以排除掉非hash冲突的情况。如果hashcode相等，再进一步比较equals，确认是否哈希冲突。</p>
<h5 id="HashMap为什么会出现链表成环"><a href="#HashMap为什么会出现链表成环" class="headerlink" title="HashMap为什么会出现链表成环"></a>HashMap为什么会出现链表成环</h5><p>因为HashMap的扩容迁移方法中，对哈希桶中链表的拷贝是采用头插法，迁移过后元素的顺序会倒置。而其中有一条语句是临时保存当前结点的下一个结点，如果一个线程保存了头结点的下个结点，此时被打断，而另一个线程完成了此链表的迁移，结点间的连接顺序被更改，这时第一个线程恢复执行就会使链表成环。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java VM 系列</title>
    <url>/2021/02/16/jvm/</url>
    <content><![CDATA[<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><em><a href="https://www.cnblogs.com/wuzhenzhao/p/12346515.html">吴振照的博客</a></em></p>
<p>由Java VM管理的内存区域叫运行时数据区(Runtime Data Area)，这个数据区被划分为几个逻辑区域，包括方法区、堆、虚拟机栈、程序计数器、本地方法栈。</p>
<p>其中方法区和堆是线程共享区域，虚拟机栈、程序计数器、本地方法栈是为线程存储运行时数据的独占区域，每个线程都有一份。</p>
<img src="/2021/02/16/jvm/runtime_data_area.png" class="" title="运行时数据区">

<a id="more"></a>

<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区在JVM启动时创建，是堆的一部分，但为了与存放对象的堆区分，被取名为Non-Heap。方法区中存放<strong>运行时常量池</strong>、静态变量、类信息、即时编译器编译后的代码。方法区的内存不需要连续，在JDK 6、7中，方法区是永久代Perm Space，有JVM要求的固定大小上限；在JDK 8中，方法区改为元区域Metaspace，由JVM使用直接内存，仅被实际内存大小约束。JVM提供参数修改方法区的初始、最大、最小大小。如果方法区内存溢出，会产生错误信息OutOfMemoryError: Metaspace。</p>
<blockquote>
<p><strong>运行时常量池</strong></p>
</blockquote>
<p>运行时常量池(Runtime Constant Pool)中包含编译时已知的<strong>字面量</strong>和运行时解析的<strong>方法</strong>、<strong>字段引用</strong>。</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是JVM内存中最大的一块，也不需要是连续的，堆内存用于存放Java对象实例和数组。因为对象的使用寿命一般较短，因此堆是垃圾回收发生的主要区域。如果堆内存溢出，会产生错误信息OutOfMemoryError: Heap Space。</p>
<h4 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h4><p>堆内存结构是以优化垃圾回收为目的设计的，具体结构见「垃圾回收机制」章节。</p>
<h4 id="对象内存结构"><a href="#对象内存结构" class="headerlink" title="对象内存结构"></a>对象内存结构</h4><p>根据前文对JVM内存结构的介绍我们可以想到，一个静态引用是从<strong>方法区</strong>指向堆对象的引用，而一个普通引用是从<strong>栈帧</strong>指向堆对象的引用。那么对象的内部结构是怎样的呢？对象是怎么和它属于的类连接的呢？</p>
<p>在其它语言实现中，很多会用到句柄，一个句柄分别指向对应的对象和类，引用变量只需要指向句柄即可间接连接到对象和类；而在HotSpot中是采用直接操控指针的方式实现的，每个对象内存中直接存放了指向所属类的指针。</p>
<p>在一个对象中，有对象头、实例数据和填充数据三个逻辑部分。</p>
<h5 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h5><p>保存与对象整体相关的信息：</p>
<ul>
<li>Mark Word: 用于保存hashcode、年龄(用于GC)、锁状态(用于分段锁)等信息，8 byte;</li>
<li>Class Pointer: 指向方法区中的对应类数据，8 byte;</li>
<li>Length: 数组长度，是数组对象特有的部分，4 byte。</li>
</ul>
<h5 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h5><p>保存对象的成员变量：</p>
<ul>
<li>boolean / byte: 1byte;</li>
<li>short / char: 2 byte;</li>
<li>int / float: 4 byte;</li>
<li>long / double: 8 byte;</li>
<li>reference: 8byte.</li>
</ul>
<h5 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h5><p>将对象的大小填充到8byte的整数倍。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器(Program Count Register)用于记录程序运行的进度，具体地说，用于保存当前正在执行的VM字节码指令的地址。每个线程都有一个程序计数器，通过它，线程能够在拿到cpu时间片时直接定位到该执行的指令。如果执行的是Native方法，则当前值为Undefined。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈是线程在方法调用时使用的底层存储空间，线程将调用方法所要用的数据存放在一起压入栈中，称作一个栈帧。方法的调用开始和完成就对应了一个栈帧的压入和弹出。每个栈帧中包含四个部分：</p>
<ul>
<li><p>局部变量表：存放方法参数和局部变量，注意，使用这些变量需要先将它们压入操作数栈中。</p>
</li>
<li><p>操作数栈：存储当前使用的操作数。</p>
</li>
<li><p>动态链接：指向<strong>运行时常量池</strong>中该栈帧对应方法的引用，支持方法中的动态链接</p>
</li>
<li><p>方法出口：方法返回的地址。</p>
</li>
</ul>
<h3 id="本地方式栈"><a href="#本地方式栈" class="headerlink" title="本地方式栈"></a>本地方式栈</h3><p>与虚拟机栈类似，只是本地方法栈专用于本地方法的执行。</p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p><em><a href="https://www.cnblogs.com/wuzhenzhao/p/12346516.html">吴振照的博客</a></em></p>
<p>Java文件在编译时经过词法分析器、tokens流、语法分析器、语法树、语义分析器、注解抽象语法树、字节码生成器这一系列操作转换成字节码，保存在.class文件中。类文件在运行时被加载到虚拟机，其中包括加载、链接(验证、准备、解析)、初始化这三个阶段。</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><h4 id="加载过程"><a href="#加载过程" class="headerlink" title="加载过程"></a>加载过程</h4><ul>
<li>通过类的全限定名获取.class字节码文件</li>
<li>将字节码中的静态存储结构转化为方法区的运行时数据结构</li>
<li>在Java堆中生成代表这个类的java.lang.Class对象，作为这些静态数据的访问入口</li>
</ul>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>加载由类加载器ClassLoader完成，类加载器从上到下有Bootstrap, Extension, System, Custom四种，Bootstrap加载核心类库，Extension加载扩展类，System加载类路径下的类，而Custom是用户自定义的类加载器。加载类时采用双亲委派机制。</p>
<h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>某个具体的类加载器收到加载请求时，会先从上往下检查是否被某个类加载器加载过，如果没有加载过，再从下往上递归地让父类加载器完成，最终由最上层能够加载的父类加载器执行加载，这样做可以避免重复加载，同时考虑了安全因素(如果类在核心类库中被加载过了，就不会被自定义的同名类替换)。</p>
<h3 id="链接-link"><a href="#链接-link" class="headerlink" title="链接(link)"></a>链接(link)</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保字节码中的信息符合虚拟机要求，包括文件格式验证、原数据验证、字节码验证、符号引用验证；</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>给类变量(类静态变量)分配内存和设置初始化值(final静态变量在编译期被赋值保存在方法区的运行时常量池)。</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>把常量池中的符号引用替换为直接引用，如果引用指向未被加载的类或类成员，会先加载这个类。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>执行由编译器收集好的类的初始化器(类变量赋值语句和静态代码块)，进行初始化。</p>
<p>在运行时，JVM根据语句执行顺序对<strong>类对象</strong>进行初始化，当运行时发生以下情况时触发初始化：</p>
<ul>
<li>遇到new, getstatic, putstatic, invokestatic四条字节码指令时，即：实例化对象时、读取或设置非final的静态字段时、调用静态方法时，如果类还没有初始化，先触发类的初始化；</li>
<li>调用java.lang.reflect包时，如果类还没有初始化，先触发类的初始化；</li>
<li>初始化一个类时，如果父类还没有初始化，先触发<strong>父类</strong>的初始化；</li>
<li>虚拟机启动时，先初始化main方法所在的类(主类)；</li>
<li>JDK1.7 方法句柄对应的类没有初始化，先触发初始化。</li>
</ul>
<h3 id="特殊：字符串的初始化"><a href="#特殊：字符串的初始化" class="headerlink" title="特殊：字符串的初始化"></a>特殊：字符串的初始化</h3><p>运行时常量池：在方法区中，保存类加载过程的字面量</p>
<p>字符串常量池：全局存在，保存对字符串对象的唯一引用</p>
<p>字符串对象在初始化和赋值给引用时，会先查找<strong>字符串常量池</strong>中是否已经存在相同内容的引用。字符串常量池通过维护一个HashSet&lt;String&gt;来保存所有全局共享的字符串对象，相同的字符串都会使用字符串常量池中的同一个引用。在类加载的解析阶段，JVM把字符串的引用添加到字符串常量池，但HotSpot VM的实现是采用懒加载的方式，仅当一个字符串引用第一次被执行<strong>ldc</strong>指令时，才会加载到字符串常量池。ldc的功能是将int、float或String型常量值从运行时常量池拷贝到操作数栈的栈顶，懒加载就是仅当遇到ldc指令时才实际创建字符串对象、把引用添加到字符串常量池。也就是说，在加载类时，字面量会进入<strong>当前类的运行时常量池</strong>，而不会进入<strong>全局的字符串常量池</strong>。在ldc过程中，如果字面量(Literal, 也就是”xxx”)的引用已经存在于字符串常量池，就直接使用对应的引用，否则才创建新的对象和添加引用到字符串常量池；如果使用 <code>&quot;xxx&quot;+&quot;xxx&quot;</code> 的方式，会采用stringbuffer的<code>append()</code>方式，并以<code>toString()</code>产生一个新的字符串，因为这个新字符串<strong>是在操作数栈中产生的</strong>，没有用到ldc指令，所以不会在字符串常量池中添加引用。而String对象的<code>intern()</code>方法会检查常量池是否有这个字符串对象的引用，如果没有就保存一份到常量池中，最后不管有没有都会返回它的引用。</p>
<h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>当一些对象不在被任何对象引用引用，JVM的垃圾回收机制(Garbage Collector)会帮我们释放对象占用的内存。那么GC应该怎么判断对象是否需要回收呢？有两种思想，一种是引用计数，一种是根搜索。</p>
<h3 id="引用计数算法-Reference-Counting-GC"><a href="#引用计数算法-Reference-Counting-GC" class="headerlink" title="引用计数算法(Reference Counting GC)"></a>引用计数算法(Reference Counting GC)</h3><p>每一个对象存储一个计数变量，每当有一个地方引用它就加1，每当有一个引用失效就减1。由于一个对象在创建后必须被引用，否则就再也不能被引用，所以当计数值归0时，就说明不再会有任何引用能够引用到它。</p>
<p>这种算法的特点是简单，可以与正常程序并发进行，但检查不出对象间的循环引用，早期的JVM曾用过这种方法。</p>
<h3 id="根搜索算法-Tracing-GC"><a href="#根搜索算法-Tracing-GC" class="headerlink" title="根搜索算法(Tracing GC)"></a>根搜索算法(Tracing GC)</h3><p>如果把对象的引用变量关系看作一张有向图，只要定义一些一直存在的结点为根结点(GC Roots)，从根节点开始搜索，能搜索到的结点就是仍在使用中的对象。Tracing GC的实现可以使用广度优先算法，算法的思想是将结点分为白、灰、黑三种颜色：白色代表还没搜索到的结点；灰色代表正在搜索的结点，也就是说这个对象仍有引用没有遍历完，将其放入搜索队列；黑色代表已经搜索过的结点，放入集合。具体实现方法是，申请一段连续地址作为队列，从根集合出发进行广度优先搜索，在搜索的过程中，只扫描没有标记过的对象，先标记这些对象，再将其放入队尾。</p>
<p>在tracing GC中包含GC Roots、Stop The World的概念，基于根搜索的标记思想又衍生出不同的回收方案。</p>
<h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>GC Roots包括：</p>
<ul>
<li>虚拟机栈中引用的对象，即栈帧中的局部变量表中的引用对象；</li>
<li>方法区中的常量引用的对象；</li>
<li>方法区中的类静态属性引用的对象；</li>
<li>本地方法栈中JNI的引用对象；</li>
<li>活跃线程。</li>
</ul>
<h4 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h4><p>由于程序在运行过程中，对象的引用关系是动态变化的，所以要进行Tracing和marking，必须暂停所有应用线程。JVM会让所有线程运行到安全点(safepoint)，并触发一次Stop The World(STW)。暂停的时间取决于存活对象的多少。</p>
<h4 id="内存回收方法"><a href="#内存回收方法" class="headerlink" title="内存回收方法"></a>内存回收方法</h4><p>在根搜索标记阶段完成后，就需要真正地回收内存了，在这一步可以采用不同的方法。</p>
<h5 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h5><p>标记阶段结束后，直接回收所有没被标记的对象，这种方法的好处就是在引用计数法的效果上弥补了循环引用问题的不足，而比起其他tracing算法，它不需要移动对象；缺点是需要用一个表来维护所有没被标记的对象，而且回收后会产生内存碎片。</p>
<h5 id="标记整理-Compacting-GC"><a href="#标记整理-Compacting-GC" class="headerlink" title="标记整理(Compacting GC)"></a>标记整理(Compacting GC)</h5><p>标记阶段结束后，将所有的标记对象向内存地址的一边移动，相当于“整理”内存。这样就不会有内存碎片，新对象的创建地址只需要用一个指针指示。缺点是整理耗费的时间长。</p>
<h5 id="标记复制-Copying-GC"><a href="#标记复制-Copying-GC" class="headerlink" title="标记复制(Copying GC)"></a>标记复制(Copying GC)</h5><p>Copying的思想是把内存分成大小相等的两块，每次只使用其中一块。每当需要垃圾回收时，通过tracing标记所有存活的对象，把它们拷贝到另外一块内存中。这种方法的好处是标记和复制可以同时进行，而且复制操作中目标地址是连续的，原地址也不需要备份，实现更高效，也不会产生内存碎片；缺点就是需要两倍大小的内存空间。</p>
<p>Copying GC是HotSpot GC中负责新生代垃圾回收的算法主要采用的方法，因为新生代中大多数对象的生命周期都很短，每次标记只有少量对象能存活，因此需要复制的对象就少，算法效率更高。</p>
<h5 id="Adaptive-GC"><a href="#Adaptive-GC" class="headerlink" title="Adaptive GC"></a>Adaptive GC</h5><p>这种思想是根据当前情况选择合适的GC算法去处理。分代其实也有一点Adaptive GC思想，只是分代并不是动态选择，而是划分好了不同的情况，并规定每种情况用哪种GC算法。</p>
<h3 id="Cheney算法——Minor-GC的起源"><a href="#Cheney算法——Minor-GC的起源" class="headerlink" title="Cheney算法——Minor GC的起源"></a>Cheney算法——Minor GC的起源</h3><p><em><a href="https://hllvm-group.iteye.com/group/topic/39376#post-257329">R大的文章</a></em></p>
<p>Minor GC与其对应在serial GC中的实现类DefNewGeneration使用的就是Cheney算法的变种，Cheney是一种经典的copying算法，它的实现思想就是上文介绍的标记复制方法，具体来说，有以下几个重点：</p>
<ol>
<li>使用一块连续的地址空间，划分成from-space和to-space。</li>
<li>从GC Roots中逐个扫描指向堆的引用，每扫描到一个对象，就把它从from-space拷贝到to-space，并在原对象里记录forwarding pointer，用于标识这个对象被移动到的新位置。并且，每通过<strong>引用</strong>扫描到一个引用对象、拷贝这个对象后，就将这个引用<strong>修正</strong>为指向拷贝后的新对象。</li>
<li>扫描到一个对象时，通过是否有forwarding pointer来判断对象是否被扫描过。所以forwarding pointer既有转发、更新引用的作用，也有标记(mark)作用。</li>
<li>to-space区域用一个指针(scanned)指示已经完成扫描的对象位置，另一个指针(top)指示新来的对象应该放到哪里，逻辑上地址是由低到高。由于一个对象可能包含多个引用，每扫描到一个引用，都需要将引用对象拷贝到to-space的对应位置，但对象本身并没有扫描完成，所以to-space成为了一个隐式的队列结构，bottom~scanned区域是完成扫描的对象，scanned~top区域是已经扫描到但没扫描完的对象，top~end是未分配的空间。</li>
</ol>
<h3 id="堆内存划分"><a href="#堆内存划分" class="headerlink" title="堆内存划分"></a>堆内存划分</h3><p>JVM研究人员发现，对象的生命周期各不相同，其中大部分对象的生命周期都很短，根据年龄划分对象和对象存放区域，能够有效地利用copying算法的优势，从而提高整个GC体系的效率。因此堆内存在HotSpot虚拟机中，以优化垃圾回收算法为目的，划分为新生代(Young Generation)、年老代(Old Generation)和永久代(Permanent Generation)。其中新生代又被划分为Eden区和Survivor区，Survivor区又被分为survivor0和survivor1两半，对应copying算法中的from-space和to-space。新生代中 Eden : S0 : S1 = 8 : 1 : 1。</p>
<img src="/2021/02/16/jvm/heap_area.png" class="" title="堆内存结构">

<p>一般情况下，新创建的对象会被分配到eden区，而大对象会被直接分配到old区。</p>
<p>常说的Minor GC，是负责整个young区的垃圾回收器的俗称。当eden区被放满，就会对eden区进行一次minor GC，把eden和from-space中存活的对象复制到to-space，并且年龄+1，年龄到达阈值的对象会被移到old区。to-space总是在结束前和from-space互换，保证只有from-space有对象。当to-space在一次GC过程中被填满了，minor GC就会把所有存活对象放入old区。</p>
<p>Old区空间比较大，且在这里的对象都已经很老了比较长(从统计学上看，对象的生命周期要么很短，要么偏长)，所以old区进行GC的频率远小于young区，负责old区的GC俗称为Major GC。又因为只有CMS具有单独处理old区的GC，其他垃圾处理器在处理old时都会先触发一次Minor GC，或者像G1直接收集整个堆，所以很多时候也把Major GC称为Full GC，Full GC指收集整个堆的GC模式。</p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><em><a href="https://www.jianshu.com/p/5261a62e4d29">简欲明心的文章</a><em>、</em><a href="https://www.zhihu.com/question/41922036/answer/144566789">Ted Mosby的回答</a><em>、</em><a href="https://blog.csdn.net/renfufei/article/details/54885190">JVM的GC器</a></em></p>
<p>垃圾回收器通过设计、组合和优化不同分代使用的算法产生，是指整个垃圾回收模型。这里归纳几种GC的特点。</p>
<p>Serial GC =  Serial Young GC + Serial Old GC (Full GC)s</p>
<p>Parallel GC = Parallel Young GC + (非并行) PS MarkSweep GC (Full GC) / (并行) Parallel Old GC (Full GC)</p>
<p>CMS = ParNew GC(Young GC)  + CMS GC(Old GC) + Full GC for CMS(备用)</p>
<p>G1 GC = Young GC + mixed GC(Young + part of Old) + Full GC for G1 GC(备用)</p>
<h4 id="各种GC模型的特点"><a href="#各种GC模型的特点" class="headerlink" title="各种GC模型的特点"></a>各种GC模型的特点</h4><ul>
<li>所有的Minor GC都采用copying思想；</li>
<li>所有的Full GC都采用compacting思想；</li>
<li>CMS GC(Old GC)采用mark-sweep思想(concurrent mark sweep)；</li>
<li>CMS追求最短STW时间；</li>
<li>G1 GC能够根据用户希望的STW时间制定回收计划，设计目标是取代CMS。</li>
</ul>
<h4 id="各种GC子模型的触发条件"><a href="#各种GC子模型的触发条件" class="headerlink" title="各种GC子模型的触发条件"></a>各种GC子模型的触发条件</h4><ul>
<li>所有Young GC触发条件都是Eden区满了；</li>
<li>Serial Old GC 和Parallel Old GC(并行和非并行)的触发条件是在Young GC执行前预测old会满；</li>
<li>CMS GC的initial marking触发条件是old使用比例超过阈值；</li>
<li>G1 GC的initial marking触发条件是整堆使用比例超过阈值；</li>
<li>Full GC for CMS和Full GC for G1 GC的触发条件是前面的Old GC没效果。</li>
</ul>
<h3 id="值得注意的问题"><a href="#值得注意的问题" class="headerlink" title="值得注意的问题"></a>值得注意的问题</h3><h4 id="为什么要分代"><a href="#为什么要分代" class="headerlink" title="为什么要分代"></a>为什么要分代</h4><p>对于Serial GC来说，GC过程中需要stop the world，所以缩短一次GC的耗时是一件重要的事，而分代作为一种partition的思路，基于对象“朝生暮死”的特性，让新对象在新生代创建，并且频繁收集新生代中的垃圾，而新生代的大小通常也只占堆中的一小部分，所以能够降低STW时间。</p>
<p>而对于<strong>并发</strong>GC来说，GC是一场和应用拼速度的游戏：应用在创建对象和引用，而GC在后面收集失效的对象和引用。在这种情形下，分代缩短GC的处理时间，就能提高GC的速度，避免或者降低GC应付不了应用不断产生的垃圾、造成STW并等待GC收集的情况。</p>
<h4 id="为什么Young-Generation中要分为Eden和Survivor区"><a href="#为什么Young-Generation中要分为Eden和Survivor区" class="headerlink" title="为什么Young Generation中要分为Eden和Survivor区"></a>为什么Young Generation中要分为Eden和Survivor区</h4><p>如果没有年龄机制，每次Young区满了就要把存活对象放入old区，这样old区更快被填满，发生Full GC的频率增大，效率慢。设置Survivor区和年龄晋升机制就是为了让young区更频繁的触发具有高效率的Minor GC，减少Full GC频率。</p>
<h4 id="为什么Survivor区分为两块"><a href="#为什么Survivor区分为两块" class="headerlink" title="为什么Survivor区分为两块"></a>为什么Survivor区分为两块</h4><p>显然，是为了使用Copying GC的思想，得到它的优点：高效地同时去碎片化。</p>
<h4 id="设置forwarding-pointer和更新引用"><a href="#设置forwarding-pointer和更新引用" class="headerlink" title="设置forwarding pointer和更新引用"></a>设置forwarding pointer和更新引用</h4><p><em><a href="https://www.zhihu.com/question/42181722/answer/145085437">Ted Mosby的回答</a></em></p>
<p>Copying GC策略中复制对象后，原对象的对象头改为指向新对象地址的指针forwarding pointer。</p>
<h5 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h5><p>Young GC类算法中，GC roots包含原定义的GC roots加上old-&gt;young的引用，从这些roots出发，trace每一条路径，如果遇到young-&gt;old的引用，则停止这条路径的搜索；</p>
<p>当第一次遇到一个对象，会将其copy或者promote，并在这个原对象的markword中存放forwarding pointer；如果这个对象还被其他<strong>引用</strong>指向，下一次tracing到这个对象时，会根据其存放的forwarding pointer更新这些<strong>引用</strong>。</p>
<p>这类算法包括Serial Young GC（DefNew）、Parallel Young GC、ParNew，以及G1 GC的Young GC &amp; Mixed GC。</p>
<h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>Full GC类算法中，先扫描一遍整个堆，找到所有的live objects，计算它们将要去往的新地址，先通过这些地址更改所有live objects的引用，使它们指向正确的新地址，再把live objects复制到对应的新地址上。</p>
<p>这类算法包括Serial Old GC、PS MarkSweep GC、Parallel Old GC、Full GC for CMS和Full GC for G1 GC。</p>
<h5 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h5><p>CMS算法的老年代GC采用标记-清除法，当ParNew GC的mark-copy结束后，再trace一遍指向老年代的引用，对扫描到的对象进行remark。</p>
<h4 id="待读"><a href="#待读" class="headerlink" title="待读"></a>待读</h4><p><a href="https://www.zhihu.com/question/53613423/answer/135743258">RednaxelaFX的回答</a></p>
<h3 id="JVM的关闭"><a href="#JVM的关闭" class="headerlink" title="JVM的关闭"></a>JVM的关闭</h3><p>JVM的关闭分为正常关闭、异常关闭和强制关闭三种。其中，有四种正常关闭的方法：</p>
<ol>
<li>所有非守护线程执行结束</li>
<li>程序中调用System.exit(0)</li>
<li>终端使用ctrl+c发送SIGINT信号</li>
<li>linux命令kill -15发送SIGTERM信号</li>
</ol>
<p>两种异常关闭的情况：</p>
<ol>
<li>RuntimeException发生</li>
<li>OOM</li>
</ol>
<p>强制关闭分为3种情况：</p>
<ol>
<li>linux命令kill -9发送SIGKILL信号</li>
<li>程序调用Runtime.halt()</li>
<li>断电、宕机等物理情况使系统关机</li>
</ol>
<p>在JVM非强制关闭的情况下，会在关闭前调用已注册的shutdown hooks，实现用户自定义的资源释放过程。钩子本质上是一个线程，因此在注册多个钩子时会并发执行，所以可能产生死锁问题，因此建议在同一个钩子中执行操作。</p>
<p>而在强制关闭的情况下不会执行钩子方法和finalizer方法。</p>
<h3 id="JDK命令"><a href="#JDK命令" class="headerlink" title="JDK命令"></a>JDK命令</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>jps：查看所有虚拟机执行主类名称和进程的本地虚拟机唯一ID(LVMID)</p>
<p>jps -q: 只输出进程的本地虚拟机唯一ID</p>
<p>jps -l: 输出主类的全名或jar包路径</p>
<p>jps -v: 输出进程启动时JVM参数</p>
<p>jps -m: 输出传给main()函数的参数</p>
<h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><p>Jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</p>
<p>jstat用于监视虚拟机的运行状态信息</p>
<h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>jinfo vmid 输出对应ID的虚拟机的全部参数</p>
<p>jinfo -flag name vmid 输出对应 ID的虚拟机的对应名称的参数值</p>
<p>jinfo -flag name [+|-]name vmid 开启或关闭对应ID的虚拟机的对应名称的参数值</p>
<h4 id="Jstack"><a href="#Jstack" class="headerlink" title="Jstack"></a>Jstack</h4><p>jstack生成虚拟机当前时刻的线程快照</p>
<h3 id="OOM问题排查"><a href="#OOM问题排查" class="headerlink" title="OOM问题排查"></a>OOM问题排查</h3><p>内存溢出问题会发生在堆内存区域(Java heap space)或元数据区(MetaSpace)。</p>
<p>堆内存溢出产生的原因可能是内存泄漏或超出了预期的流量/数据量峰值。内存泄漏是指使用完的对象仍存在强引用，垃圾回收器无法对其占用的资源进行回收释放，导致可用内存不够。内存泄漏发生的情况之一是使用对象作为HashMap的键，当对象不再使用时，没有及时释放HashMap对其的引用，导致键值对不会被回收。</p>
<p>通过设置JVM参数导出dump文件到指定目录：</p>
<p><code>-XX:+HeapDumpOnOutOfMemoryError -XX: HeapDumpPath=oom.hprof</code></p>
<p>使用MAT工具分析生成的文件，用Leak Suspects Reports功能可以查看怀疑的对象和堆栈信息，从堆栈信息可以追溯到发生OOM的代码段。</p>
<p>方法区(MetaSpace)内存溢出是有太多或者太大的类被加载到方法区，可以尝试使用G1 GC回收方法区垃圾，或者排查程序是否加载了不合理的类。</p>
<p><code>OOM Error: Unable to create new native thread</code> 发生在操作系统拒绝向JVM提供更多的线程，因为创建的线程数已经超过上限。</p>
<p><code>OOMError: Out of swap space?</code> 发生在操作系统配置的交换空间不足或系统的另一个进程消耗所有的内存资源时，或者是用户使用了JVM的native heap memory，但没有正确地释放。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GC</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统基础</title>
    <url>/2021/03/22/os/</url>
    <content><![CDATA[<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>传统的fork()过程会为子进程申请一个PCB结构体，拥有新的进程标识符，将父进程的PCB中存储的正文(代码)、数据、上下文(寄存器、程序计数器)拷贝到子进程的PCB中。fork()方法返回一个pid，这个方法会向父进程返回子进程的pid，向子进程本身返回0。注意，fork之后父子进程的执行次序是不确定的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// child process</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// parent process  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Copy-on-Write"><a href="#Copy-on-Write" class="headerlink" title="Copy on Write"></a>Copy on Write</h4><p>但实际上，linux中并不会在fork子进程时立即拷贝父进程的数据，而是在为子进程分配PCB后，将其中的正文、数据、上下文表项指向父进程的对应地址，也就是共用同一份内容，仅当父进程或子进程的这些内容需要更改时，才将父进程的内容拷贝到子进程的PCB中，这就是copy on write方法，本质上是一种lazy思想，可以加速fork()过程，延迟或避免拷贝过程。</p>
<p>值得注意的是，拷贝的结果是发动修改的一方会将原物理地址的内容拷贝到一个新的地址中，作为自己PCB的内容地址，并进行修改；而另一方仍然使用原来的物理地址。</p>
<h4 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h4><p>vfork也用来创建进程，但它是专门用于快速创建一个进程，并调用exec()刷新内存的。与fork相比，它创建出的子进程共享父进程的地址空间，并且在子进程调用exec()之前一直共享(即使父/子进程修改了内容也不会拷贝)；此外，vfork保证子进程先运行，只有在调用exec()或exit()之后，会向父进程发送信号让父进程被唤醒。</p>
<h3 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h3><h4 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道(Pipe)"></a>管道(Pipe)</h4><p>半双工。只能用于有亲缘关系的进程间通信，因为必须由父进程打开一个管道文件，通过fork()产生子进程和共享的管道文件。</p>
<p><code>int pipe(int pipefd[2]);</code> 可以产生一个管道文件，并且由pipefd[0]存储读方式打开的描述符，pipefd[1]存储写方式打开的描述符。</p>
<p>fork()之后，子进程也拥有同一组文件描述符，这时父子进程可以通过相应的文件描述符实现双向通信，但同一时间只能使用一种方向，所以是半双工的。</p>
<h4 id="有名管道-FIFO-Named-Pipe"><a href="#有名管道-FIFO-Named-Pipe" class="headerlink" title="有名管道(FIFO / Named Pipe)"></a>有名管道(FIFO / Named Pipe)</h4><p>半双工，读写的两端如果只有一端存在，会<strong>阻塞等待</strong>。可以用于任意两个进程之间的通信。</p>
<p>FIFO的本质也是文件，但这个文件在系统中存在名字。通过保证进程的同步读/写来通信，使用字符串命名FIFO，通过名字创建、读/写对应的FIFO。</p>
<h5 id="创建FIFO"><a href="#创建FIFO" class="headerlink" title="创建FIFO"></a>创建FIFO</h5><p><code>int mkfifo(const char *pathname, mode_t mode);</code> </p>
<p>其中pathname是FIFO的名字，mode是定义文件权限的参数。创建出的文件类型最前面有一个p标识。</p>
<h5 id="打开-读写FIFO"><a href="#打开-读写FIFO" class="headerlink" title="打开/读写FIFO"></a>打开/读写FIFO</h5><p>FIFO也是以文件的形式存在的，创建之后使用open()方式读打开/写打开，返回文件描述符。读写FIFO也是同理，read() / write()。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>服务端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO1 <span class="meta-string">&quot;/tmp/fifo.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO2 <span class="meta-string">&quot;/tmp/fifo.2&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> readfd, writefd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建两个管道</span></span><br><span class="line">    <span class="keyword">if</span> ((mkfifo(FIFO1, <span class="number">0777</span>) &lt; <span class="number">0</span>) &amp;&amp; (errno != EEXIST))</span><br><span class="line">        Perror(<span class="string">&quot;can&#x27;t create FIFO1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((mkfifo(FIFO2, <span class="number">0777</span>) &lt; <span class="number">0</span>) &amp;&amp; (errno != EEXIST)) &#123;</span><br><span class="line">        <span class="comment">// 进程结束后自动删除第一个管道</span></span><br><span class="line">        unlink(FIFO1); </span><br><span class="line">        Perror(<span class="string">&quot;can&#x27;t create FIFO2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读打开第二个，写打开第一个</span></span><br><span class="line">    readfd = open(FIFO2, O_RDONLY, <span class="number">0</span>);</span><br><span class="line">    writefd = open(FIFO1, O_WRONLY, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程结束后自动删除</span></span><br><span class="line">    unlink(FIFO1);</span><br><span class="line">    unlink(FIFO2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用管道</span></span><br><span class="line">    server(readfd, writefd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO1 <span class="meta-string">&quot;/tmp/fifo.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIFO2 <span class="meta-string">&quot;/tmp/fifo.2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="keyword">int</span> readfd, writefd;</span><br><span class="line">    <span class="keyword">if</span> ((mkfifo(FIFO1, <span class="number">0777</span>) &lt; <span class="number">0</span>) &amp;&amp; (errno != EEXIST))</span><br><span class="line">        Perror(<span class="string">&quot;can&#x27;t create FIFO1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((mkfifo(FIFO2, <span class="number">0777</span>) &lt; <span class="number">0</span>) &amp;&amp; (errno != EEXIST)) &#123;</span><br><span class="line">        unlink(FIFO1);</span><br><span class="line">        Perror(<span class="string">&quot;can&#x27;t create FIFO2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反过来</span></span><br><span class="line">    writefd = open(FIFO2, O_WRONLY);</span><br><span class="line">    readfd = open(FIFO1, O_RDONLY);</span><br><span class="line">    <span class="comment">// 使用管道</span></span><br><span class="line">    client(readfd, writefd);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>msgget用于创建或者打开一个消息队列，msgsnd用于向队尾写数据，msgrcv用于从队首读数据。消息队列不一定是严格的先进先出，还可以按照消息的类型字段读取消息。</p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>多个进程直接读写共享的内存块来实现通信，是最快的进程通信方法。共享内存本质上是共享一段<strong>物理地址</strong>，而Linux万物皆文件，所以创建共享内存时，系统会创建一个文件，这个文件对应一段物理地址，并且可以被所有进程读写。</p>
<p>申请/获取共享内存时，shmget会<strong>[(创建+初始化) or 获得]**一个</strong>共享内存区<strong>，同时在特殊shm文件系统(其存储介质是RAM内存)中</strong>[(创建+初始化) or 打开]<strong>一个同名</strong>文件**，返回这个文件的描述符。</p>
<p><code>int shmget(key_t key, size_t size, int shmflg)</code></p>
<p>shmflg参数有三种选择：0表示取共享内存标识符，如果不存在就返回错误代码(ENOENT)；IPC_CREAT表示如果没找到key就创建一个新的返回，如果找到了就返回这个标识符；IPC_CREAT|IPC_EXCL表示如果没找到就创建返回，如果找到了返回错误代码(EEXIST)。</p>
<p><code>shmat()</code> 传入文件描述符，系统会通过<code>mmap()</code>调用将对应的文件映射到当前进程的虚拟空间中，而其他进程也能够映射这个文件，实现多进程的虚拟空间指向同一段物理空间，这样就能够使用文件读写的方式来写共享内存了。</p>
<p><code>void *shmat(int shmid, const void *shmaddr, int shmflg)</code></p>
<p>共享内存需要严格控制同步来保证并发安全性，比如结合信号量/互斥量使用。</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p>普通的IPC方式是基于磁盘系统的文件进行的，而且需要调用read/write来读写文件，它们的数据传递方式是：</p>
<ul>
<li>写：用户空间 -&gt; 内核空间 -&gt; 磁盘文件</li>
<li>读：磁盘文件 -&gt; 内核空间 -&gt; 用户空间</li>
</ul>
<p>读、写都需要两次拷贝，因此一次通信就需要四次拷贝。</p>
<p>共享内存的文件是基于内存的，而且mmap建立了虚拟地址和磁盘上物理地址的直接映射，所以在没有发生缺页异常时，可以直接在内存中读写文件，因此它的数据传递方式是：</p>
<ul>
<li>写：shm文件 -&gt; 用户空间</li>
<li>读：用户空间 -&gt; shm文件</li>
</ul>
<p>当发生缺页中断时，只需要<strong>一次</strong>将缺失的页加载到内存中的过程。这个过程会首先检查swap cache中有没有所需的页面，如果没有再调用nopage函数加载缺失页。</p>
<p>所以平均情况下，完成一次通信只需要两次拷贝。</p>
<h4 id="信号量、互斥量"><a href="#信号量、互斥量" class="headerlink" title="信号量、互斥量"></a>信号量、互斥量</h4><p>信号量和互斥量是操作系统中的两种<strong>同步</strong>机制。</p>
<p>信号量和互斥量本质上是计数器，通过一个数字来协调多线程/多进程之间的并发操作。信号量计数器的数值代表资源的数量，使用该资源的线程将信号量减1，释放资源或生产资源的线程将信号量加1，这样能够限制资源的使用，比如建立生产者消费者模型。</p>
<p>互斥量是特殊的信号量，计数器只允许为1或0，也就是说资源只允许同时被一个线程使用，达到互斥锁的效果。</p>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>信号是操作系统中的一种<strong>异步</strong>机制(还有epoll)。操作系统定义了64种信号，每个进程的表项中都有一个64位的信号位，以及一张对应信号处理函数的表。当内核需要将信号传递给进程时，就修改这个进程的信号位对应信号为1。进程每次从内核态返回用户态时，都会检查信号位，并执行相应的信号处理函数。常见的信号有以下几种：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">含义</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIGKILL</td>
<td align="center">强制杀死进程</td>
<td align="center">不能被忽略/捕获</td>
</tr>
<tr>
<td align="center">SIGTERM</td>
<td align="center">kill 不带参数时对应的信号，终止进程</td>
<td align="center">能被忽略/捕获</td>
</tr>
<tr>
<td align="center">SIGINT</td>
<td align="center">Ctrl+C对应的信号，终止进程</td>
<td align="center">能被忽略/捕获</td>
</tr>
<tr>
<td align="center">SIGSTOP</td>
<td align="center">暂停进程执行</td>
<td align="center">不能被忽略/捕获</td>
</tr>
<tr>
<td align="center">SIGCONT</td>
<td align="center">恢复暂停的进程执行</td>
<td align="center">不能被忽略/捕获</td>
</tr>
<tr>
<td align="center">SIGPIPE</td>
<td align="center">向没有读进程的管道写数据产生的信号</td>
<td align="center">默认处理是关掉进程，高可用服务器一般捕获处理这个信号</td>
</tr>
<tr>
<td align="center">SIGIO</td>
<td align="center">信号驱动IO对应的信号</td>
<td align="center">能被忽略/捕获</td>
</tr>
<tr>
<td align="center">SIGBUS</td>
<td align="center">访问的地址无文件内容对应</td>
<td align="center">能被忽略/捕获</td>
</tr>
<tr>
<td align="center">SIGSEGV</td>
<td align="center">访问的地址是内存映射区外，不属于该进程</td>
<td align="center">能被忽略/捕获</td>
</tr>
</tbody></table>
<h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill命令实际上是一个<strong>程序</strong>，根据后面的参数给对应的进程发送一个<strong>信号</strong>，比如-9对应<code>SIGKILL</code>，用于强制结束进程；-15对应<code>SIGTERM</code>(默认参数)；而键盘按下<code>Control+C</code>会发送一个<code>SIGINT</code>(interrupt signal)。每次操作系统<strong>调度进程</strong>时，会通过<code>do_signal</code>函数检查其task_struct中存储信号的位置有没有需要被处理的信号，和<code>handle_signal</code>进行具体的处理。</p>
<h5 id="kill-9-杀不死进程可能的原因"><a href="#kill-9-杀不死进程可能的原因" class="headerlink" title="kill -9 杀不死进程可能的原因"></a>kill -9 杀不死进程可能的原因</h5><ol>
<li>进程是僵尸进程，虽然释放了资源，但父进程没有wait()</li>
<li>进程处于内核态，且在等待锁资源</li>
</ol>
<h3 id="僵尸进程-孤儿进程"><a href="#僵尸进程-孤儿进程" class="headerlink" title="僵尸进程/孤儿进程"></a>僵尸进程/孤儿进程</h3><p>当一个子进程因终止而退出时，系统进程表为其保留退出状态信息，需要父进程调用wait()或waitpid()方法来收集这些信息，子进程才会真正被删除；如果父进程没有调用这些方法，子进程会一直占用系统资源，被称为僵尸进程(zombie)。</p>
<p>当一个父进程先于其子进程终止退出，就没有人为子进程“善后”了，此时子进程成为孤儿进程(orphan)，由init进程接管。而init进程会循环地对子进程调用wait()，为子进程处理退出时的善后工作。</p>
<p>孤儿进程不会产生不良影响，而僵尸进程会占用系统资源。如果僵尸进程过多，需要找到大量产生僵尸进程的父进程，通过kill命令终止其运行，从而让僵尸进程变成孤儿进程，被init进程接管并wait()释放。</p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>协程切换：只切换程序计数器和寄存器(CPU上下文切换)，完全在用户态进行，所以不需要用户态和内核态的切换。</p>
<p>进程切换：CPU上下文切换，切换特权模式(由内核态负责切换)，切换整个task_struct数据结构中保存的内容，包括存储的各种地址(堆栈地址、指令计数器、页表地址)，也就是切换了堆栈、页表、指令计数器等资源。</p>
<p>线程切换：CPU上下文切换，切换特权模式，切换线程栈和寄存器。线程就是轻量级的线程，只是同一父进程fork出的轻量级线程可以共享同一份虚拟地址空间。</p>
<h4 id="CPU上下文切换"><a href="#CPU上下文切换" class="headerlink" title="CPU上下文切换"></a>CPU上下文切换</h4><p>CPU上下文包括程序计数器和寄存器，CPU执行任何指令都需要依赖这两者。在切换时需要把上一个<strong>任务</strong>的上下文保存在<strong>事先开辟的内核空间task_struct中</strong>，在任务重新调度时再加载进来。</p>
<p>任务分为线程上下文切换、进程上下文切换、中断上下文切换。</p>
<h4 id="虚拟空间地址"><a href="#虚拟空间地址" class="headerlink" title="虚拟空间地址"></a>虚拟空间地址</h4><p>虚拟地址到物理地址通过地址空间映射完成，这种映射关系被保存在<strong>页表</strong>中。</p>
<p>如果是进程上下文切换，切换虚拟地址空间需要切换页表和，那么快表会失效。页表切换后，原先的快表也就失效了，导致cache命中率降低，程序运行效率会降低。</p>
<p>快表：快表(TLB)是一种特殊的cache，用于保存常用的地址映射，加速页表查找。</p>
<h4 id="进程内存空间"><a href="#进程内存空间" class="headerlink" title="进程内存空间"></a>进程内存空间</h4><p>在进程被分配的虚拟内存空间中，包含代码段、数据段、bss段、栈和堆五个部分。代码段保存只读的程序执行码，数据段存放已初始化的静态变量和全局变量，bss段存放未初始化的静态变量和全局变量，栈中包含一段内核栈用于内核态调用，堆是由程序员分配的内存空间。堆是由地位向高位分配的，栈是由高位向低位分配的。</p>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>操作系统中的守护进程是运行在后台的、独立于控制终端、周期性执行某种任务或等待某些事件发生的进程，这些进程不能直接和用户交互，不受用户登录/注销的影响，一直在运行。</p>
<p>通过<code>ps axj</code>可以看到所有用户的(a)、包括有控制终端和无控制终端的(x)、与作业控制相关的(j)进程，结果中TPGID栏为-1的都是守护进程(无控制终端)。</p>
<h4 id="实现一个守护进程"><a href="#实现一个守护进程" class="headerlink" title="实现一个守护进程"></a>实现一个守护进程</h4><ul>
<li>调用umask(0)将文件模式创建屏蔽字设置为0，让fork出的子进程更加灵活</li>
<li>调用fork创建子进程，并退出父进程(exit)，让子进程成为孤儿进程，保证子进程不是一个进程组的组长进程。</li>
<li>调用setsid创建一个新会话，使该进程成为新会话的首进程，并成为进程组的组长进程(所以要先fork)，并使该进程失去控制终端。</li>
<li>为防止守护进程重新打开控制终端，再次fork子进程、退出父进程，因为子进程不是会话组长，不能重新打开控制终端。</li>
<li>将当前工作目录改为根目录</li>
<li>关闭不需要的文件描述符</li>
</ul>
<h3 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h3><p>Java线程调度的策略取决于JVM的实现以及运行的操作系统。</p>
<p>在windows上，Java线程被一对一地绑定到win32线程，win32线程再一对一地绑定到内核级线程。Java6的实现是将线程的10个优先级被映射为Win32的5个线程优先级，windows分为6个进程优先级和6个线程优先级，由两者决定了线程的最终优先级(1~36级)。</p>
<p>在linux上，java线程也是被一对一映射到内核级线程上，JVM将线程的10个优先级映射为linux的线程nice值(谦让值)，nice值越高就越有可能把cpu让给别的线程用。</p>
<p>hotspot除了将线程按优先级映射到操作系统原生线程之外，不做任何干扰线程调度的事，全部交由操作系统处理。</p>
<h3 id="操作系统线程调度"><a href="#操作系统线程调度" class="headerlink" title="操作系统线程调度"></a>操作系统线程调度</h3><p>操作系统对CPU时间分配的基本单位应该是线程，线程是执行任务的最小单位。如果调度时前后的线程不属于一个进程，就会触发进程上下文切换；否则只需要线程上下文切换，而具体的调度方法有以下几种。</p>
<h4 id="优先服务算法"><a href="#优先服务算法" class="headerlink" title="优先服务算法"></a>优先服务算法</h4><p>先来先服务：按进入队列的时间顺序分配CPU使用权.</p>
<p>短作业优先：每次选出估计运行时间最短的线程分配CPU使用权.</p>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>调度是总是选择优先级最高的进程，对紧迫型任务有利。</p>
<p>非抢占式优先权：当一个最高优先权的线程拿到CPU使用权后，就一直执行直到完成，或因其他原因让出使用权。</p>
<p>抢占式优先权：当一个最高优先权进程拿到CPU使用权后，如果有更高优先级的线程出现，会立即将使用权分配给新的最高优先级线程。常用于实时系统。</p>
<h4 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h4><p>就绪进程按时间顺序排成队列，CPU轮流分配时间片给队列中的进程。</p>
<h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p>设置多个不同级别的队列，每级队列的时间片逐级递增，新的就绪进程首先进入1级队列，当在1级队列中分到的时间片执行完还没有完成就进入2级队列，在2级队列会分到比1级队列多一倍的时间片，以此类推。</p>
<h3 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h3><h4 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h4><p>每个进程拥有一个结构体task_struct(指向mm_struct)，即进程描述符PCB。每个进程创建时拥有一段虚拟内存地址，通过页表映射到实际的物理地址。32位系统使用32位总线产生2^32bit=4GB的地址空间，64位系统并没有使用64位总线，而是受限于操作系统，最大256G内存。</p>
<h4 id="分页和页表"><a href="#分页和页表" class="headerlink" title="分页和页表"></a>分页和页表</h4><p>如果对每个地址建立到物理地址的映射，在32位的情况下就需要32GB的空间存放映射表(32位虚拟地址-&gt;32位虚拟地址)。因此操作系统引入了页的概念，将物理内存以4K为单位划分为页，这样建立的映射表就只有8MB。</p>
<a id="more"></a>

<p>页表(地址映射表)保存在CR3控制寄存器中，进程切换时，内核会切换上下文，其中就包括的寄存器，上一个进程的寄存器会被保存回task_struct，下一个寄存器从task_struct被拷贝到寄存器中。</p>
<p>task_struct中的pgd项指向PGD(page global directory)表，PGD表指向PMD(page middle directory)表，PMD表指向页表(page index)，再通过偏移量(offset)获得最终的物理地址，构成多级页表模式。</p>
<h4 id="段页式管理机制"><a href="#段页式管理机制" class="headerlink" title="段页式管理机制"></a>段页式管理机制</h4><p>短夜管理机制是分段式管理和分页式管理的组合，分页如上文所述，是物理上的管理方式，而分段式逻辑上的管理方式。</p>
<h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><p>每个CPU核中都有一个内存控制单元(MMU)，它负责将虚拟地址转为物理地址。MMU拿到CPU传来的逻辑地址，首先由分段单元转换为线性地址，再由分页单元转换为物理地址。分页单元通过页表高速缓存(TLB)和页表查询单元(table walk unit)完成这一系列工作。页表高速缓存存储了页表中的部分映射，如果高速缓存命中，则直接得到物理地址；否则通过页表查询物理地址并更新缓存。如果查出的页面不在内存中，则发生缺页中断，会从磁盘中加载到内存(页面置换)。</p>
<p>多级页表节约了很多内存，因为一个进程占用的地址通常是远小于最大值的(32位是4GB)，页表分级后，如果一级页表是空的，就不需要分配二级页表。</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断信号由外部设备发起，被中断控制器捕捉并将相应的信号发送给CPU。例如网卡设备收到网络数据包，会向IO APIC(高级可编程中断控制器)发送中断信号，IO APIC发给本地APIC，本地APIC发送给CPU；CPU根据情况判断是否需要处理中断，如果处理就保存上下文，并切换到中断上下文中。</p>
<p>信号由用户态处理，而中断由内核态处理。</p>
]]></content>
      <tags>
        <tag>Operation System</tag>
        <tag>Interview</tag>
        <tag>Computer Basics</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2021/01/31/computer-network/</url>
    <content><![CDATA[<h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p><em>&#42;本节内容参考中英文维基百科</em>。</p>
<h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>OSI Model是Open System Interconnection Model的缩写，顾名思义，OSI模型是一种为规范不同设备内部结构和技术的通信过程而产生的模型。</p>
<p>引入了服务、接口、协议、分层的概念，实际的模型结构包含七层：</p>
<img src="/2021/01/31/computer-network/OSI.png" class="" title="OSI模型">

<a id="more"></a>

<h3 id="逐层概览"><a href="#逐层概览" class="headerlink" title="逐层概览"></a>逐层概览</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul>
<li>提供为应用软件设计的<strong>接口</strong>，以设置与另一应用软件之间的通信。</li>
<li>HTTP, HTTPS, FTP, SSH, SMTP, POP3, IMAP4</li>
</ul>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><ul>
<li>把数据转换为网络服务通用格式，包括字符编码、数据压缩、编码/解码。</li>
</ul>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><ul>
<li>负责在数据传输中维护计算机网络中两台计算机之间的通信连接和数据交换。</li>
<li>SMTP, DNS</li>
</ul>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ul>
<li>接收数据流并将其分成<strong>数据段</strong>，把传输表头（TH）加至数据段。传输表头包含了所使用的协议等发送信息。</li>
<li>数据段使网络传输能够多路复用</li>
<li>TCP, UDP</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>决定数据的路径选择和转寄，将网络表头（NH）加至<strong>数据包</strong>，以形成分组。网络表头包含了网络资料。</li>
<li>管理多结点的网络，包括寻址、路由等。</li>
<li>IP, ICMP, ARP, RARP, AKP, UUCP</li>
</ul>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ul>
<li><p>负责物理层连接的两个结点的<strong>数据帧</strong>传输。</p>
</li>
<li><p>当表头和表尾被加至数据包时，会形成<strong>数据帧</strong>（Data Frame）。数据链表头（DLH）是包含了物理地址和错误侦测及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。</p>
</li>
<li><p>以太网、无线局域网（Wi-Fi）和通用分组无线服务（GPRS）等。</p>
</li>
</ul>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul>
<li>提供两个网络媒体实际连接的所有物理介质。</li>
<li>包括针脚、电压、线缆规范、集线器、中继器、网卡、主机接口卡等。</li>
<li>IEEE 802.1A</li>
</ul>
<p>OSI模型并不是一个协议，而是一个制定协议时参考的框架模型。</p>
<h2 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h2><p><em>&#42;本节内容参考中英文维基百科、<a href="https://www.cnblogs.com/onepixel/p/7092302.html">一像素的博客</a>  以及 <a href="https://zhuanlan.zhihu.com/p/59066874">杰杰的文章</a> 。</em></p>
<h3 id="模型结构-1"><a href="#模型结构-1" class="headerlink" title="模型结构"></a>模型结构</h3><p>个人理解：TCP/IP是指Transmission Control Protocol和Internet Protocol， 而我们常说的TCP/IP实际上是一组协议栈(protocol stack)，国外一般称为DoD模型。</p>
<p>基本框架：</p>
<img src="/2021/01/31/computer-network/TCPIP.jpg" class="" title="TCP&#x2F;IP协议栈">

<p>这种模型参考了OSI模型的设计，将7层精简成4层。</p>
<h3 id="逐层概览-1"><a href="#逐层概览-1" class="headerlink" title="逐层概览"></a>逐层概览</h3><h4 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h4><ul>
<li>对应OSI中的应用层、表示层、会话层</li>
<li>应用层定义数据格式，并按照对应的格式解析数据</li>
</ul>
<h4 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h4><ul>
<li><p>对应OSI中的传输层</p>
</li>
<li><p>传输层定义了端口，同一台主机上的每个应用程序都要指定唯一端口号，让主机能确定是哪个应用程序要接收这个包。</p>
</li>
<li><p><strong>UDP协议</strong>，要求在传输数据中加上端口号：</p>
<ul>
<li>首部<strong>8字节</strong>，包括源端口和目标端口；</li>
<li>数据最大65527个字节；</li>
</ul>
</li>
<li><p><strong>TCP协议</strong>解决UDP协议可靠性差的问题，因为UDP协议没有确认机制，无法确定对方是否收到数据；而TCP协议是面向连接的、可靠的、基于字节流的通信协议：</p>
<ul>
<li><p>三次握手建立连接，四次挥手关闭连接</p>
</li>
<li><p>TCP数据包和UDP数据包一样，只是长度没有限制，但通常不会超过下一层（网络层）数据包的长度，确保不会再被分割；</p>
</li>
<li><p>TCP比UDP传输速度慢，消耗资源多，但更可靠。</p>
</li>
</ul>
</li>
</ul>
<h4 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h4><ul>
<li>对应OSI中的网络层；</li>
<li>引入<strong>IP协议</strong>(Internet Protocol)指定一套IP地址，用来判断主机所属的网络和在网络内的地址：<ul>
<li>IP地址有IPv4和IPv6两个版本，其中IPv4是32位地址，分为四部分，每部分用0~255的十进制数字表示；IPv6有128位地址；</li>
<li>以C类地址为例：<ul>
<li>IP地址前三部分（24位）表示网络地址，第四部分（8位）表示主机地址；</li>
<li>子网掩码前三部分为255（24位都为1），第四部分为0（8位都为0）；</li>
<li>把子网掩码和IP地址按位与就能得到网络地址；</li>
</ul>
</li>
<li>通过比较两个网络地址就能判断两台主机是否在同一个子网。</li>
</ul>
</li>
<li>引入<strong>ARP协议</strong>(Address Resolution Protocol)根据IP地址获取MAC地址：<ul>
<li>ARP获取到目标IP地址，如果在缓存中找不到对应的MAC地址，就发起一个数据包来<strong>请求</strong>目标IP对应的MAC地址，并等待接收返回消息；</li>
<li>这个请求数据包与普通数据包一样在链路层包装为数据帧（见下段），通过以太网协议<strong>广播</strong>到子网内的所有主机；</li>
<li>主机收到请求，比对首部的IP地址，如果匹配就发回自己的MAC地址，否则丢弃数据包；</li>
<li>ARP发送方接收到发回的MAC地址，存入缓存中。</li>
</ul>
</li>
<li>引入<strong>路由协议</strong>，因为ARP只能提供<strong>子网内</strong>的MAC地址解析。<ul>
<li>先通过IP协议判断两台主机是否在同一个子网中：<ul>
<li>如果在，则直接使用ARP协议查询MAC地址；</li>
<li>否则，把ARP数据包转发给子网的网关进行路由（网关可以连接到其他子网的网关）。</li>
</ul>
</li>
<li>经过多次路由转发，最后到达目标IP所在的子网，子网内再用ARP广播形式发送，并以相同的方式发回源IP地址。</li>
</ul>
</li>
<li>在网络层包装的数据包叫<strong>IP数据包</strong>，因为它主要包含IP地址信息。IP数据包包含：<ul>
<li><strong>20字节</strong>的首部，主要包含目标IP地址和源IP地址；</li>
<li>65515字节的数据。</li>
</ul>
</li>
</ul>
<h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><ul>
<li>对应OSI中的数据链路层、物理层；</li>
<li>将0、1电信号分组，按分组顺序依次发送；</li>
<li>以太网协议：规定一个分组为一个<strong>数据帧</strong>，并以MAC地址作为网卡间通信的唯一身份标识包含：<ul>
<li>14字节的<strong>首部</strong>，包含目标MAC地址，源MAC地址和帧类型；</li>
<li>46~1500字节的<strong>数据</strong>；</li>
<li>4字节的<strong>尾部</strong>，包含校验序列。</li>
</ul>
</li>
<li>以太网采用<strong>广播</strong>形式把数据帧发送给所有<strong>子网内</strong>的主机，每台主机比对目标MAC地址，当匹配时就保留，否则丢弃。</li>
</ul>
<h4 id="ARP拓展知识"><a href="#ARP拓展知识" class="headerlink" title="ARP拓展知识"></a>ARP拓展知识</h4><p>ARP请求包在通信时也需要经过链路层包装成数据帧，但又不知道目标MAC地址，怎么办呢？</p>
<p>以太网数据帧首部用<strong>帧类型</strong>来区分ARP请求包和IP数据包，ARP请求包的帧类型为0x0806，而IP数据包的帧类型为0x0800；而ARP请求包内的目标MAC地址值为FF-FF-FF-FF-FF-FF。</p>
<img src="/2021/01/31/computer-network/ARP.png" class="" title="ARP数据包封装在以太网帧的格式">

<ul>
<li><p>硬件类型，表示要知道目标网卡的硬件类型，其中，值为1表示以太网地址；</p>
</li>
<li><p>协议类型，0x0800表示IP协议，其他还可能是ICMP/IGMP协议等；</p>
</li>
<li><p>硬件地址长度，指出该报文中硬件地址的长度，对于以太网硬件类型，它的值为6；</p>
</li>
<li><p>协议地址长度，如果是ARP协议、IP协议等，该值为4；</p>
</li>
<li><p>op字段，用于记录ARP操作的类型，分别是：</p>
<ul>
<li>ARP请求，其值为1。</li>
<li>ARP应答，其值为2。</li>
<li>RARP请求，其值为3。</li>
<li>RARP应答，其值为4。</li>
</ul>
<p>其中RARP是逆地址解析协议，已经基本被淘汰。</p>
</li>
</ul>
<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><h4 id="Request-报文"><a href="#Request-报文" class="headerlink" title="Request 报文"></a>Request 报文</h4><p>状态行、请求头、消息主体：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line">  </span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure>
<p>其中method有四种：GET, POST, PUT, DELETE, 分别是对资源的查增改删；还有HEAD, OPTION, TRACE等方法。</p>
<p>URI：统一资源标识符(identifier)</p>
<p>URL：统一资源定位符(locator)</p>
<p>URN：统一资源名称(name)</p>
<p>URL和URN都是URI。</p>
<h5 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h5><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/books/?sex=man&amp;name=Professional</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Connection: Keep-Alive \r\n</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在headers中包括但不限于以下参数：</p>
<ul>
<li>User-Agent：用户代理，例如wget也是一种用户代理</li>
<li>Accept-Encoding：接受的编码类型</li>
<li>Accept-Language：接受的语言</li>
<li>Cookie: 标识客户端身份</li>
<li>Host：访问哪个虚拟机</li>
<li>If-Modified-Since：如果在规定时间之后没更新，就返回304告知我可以使用缓存，否则返回我请求的资源。</li>
<li>Authorization：认证信息</li>
<li>Connection：Keep-Alive在1.0需要手动开启，1.1默认开启。Closed在1.1中手动禁用keep-alive。</li>
</ul>
<h5 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)</span><br><span class="line">Gecko/20050225 Firefox/1.0.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 40</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line"></span><br><span class="line">sex=man&amp;name=Professional</span><br></pre></td></tr></table></figure>
<p>GET请求的长度受到特定浏览器及服务器的限制，POST请求理论上没有大小限制，服务器处于安全因素考虑会有一定的限制。</p>
<p>GET方法没有携带数据，POST方法携带Body。</p>
<p>POST的content-type 可以是 <code>application/x-www-form-urlencoded</code> 或<code>multipart/form-data</code>。前者如<code>sex=man&amp;name=Professional</code>，后者是指定一个boundary，消息主体通过*<code>--boundary</code><em>分隔不同字段，并以</em><code>--boundary--</code>*结束。还有新的content-type，如<code>application/json</code>, <code>text/xml</code>,  <code>application/x-protobuf</code>。</p>
<h4 id="Response-报文"><a href="#Response-报文" class="headerlink" title="Response 报文"></a>Response 报文</h4><p>状态行、响应头、响应正文（对应Request），如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"></span><br><span class="line">Server:Apache Tomcat/5.0.12  </span><br><span class="line">Date:Mon,6Oct2003 13:23:42 GMT</span><br><span class="line">Content-Length:112</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...</span><br></pre></td></tr></table></figure>
<p>状态码包括但不限于：</p>
<ul>
<li><code>200 OK</code> 客户端请求成功</li>
<li><code>301 Moved Permanently</code> 请求永久重定向</li>
<li><code>302 Moved Temporarily</code> 请求临时重定向</li>
<li><code>304 Not Modified</code> 文件未修改，可以直接使用缓存的文件</li>
<li><code>400 Bad Request</code> 由于客户端请求有语法错误，不能被服务器所理解</li>
<li><code>401 Unauthorized</code> 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用</li>
<li><code>403 Forbidden</code> 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</li>
<li><code>404 Not Found</code> 请求的资源不存在，例如，输入了错误的URL</li>
<li><code>405 Method Not Allowed</code> 方法错误</li>
<li><code>500 Internal Server Error</code> 服务器发生不可预期的错误，导致无法完成客户端的请求</li>
<li><code>502 Bad Gateway</code> 作为网关或代理的服务器尝试执行请求时，从上游服务器接收到无效的响应</li>
<li><code>503 Service Unavailable</code> 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常</li>
</ul>
<p>headers包括但不限于：</p>
<ul>
<li>Connection：同request</li>
<li>Content-Encoding：压缩格式，如gzip</li>
<li>Content-Type：如MIME类型，使用的字符集等</li>
<li>Date：相应日期</li>
<li>Server：使用的服务器</li>
<li>Transfer-Encoding：传输方式，只有chunked一种可选项，见下文</li>
</ul>
<p>body包含返回的文件，如xx.html, xx.php</p>
<h4 id="Keep-alive"><a href="#Keep-alive" class="headerlink" title="Keep-alive"></a>Keep-alive</h4><p>HTTP1.0中，默认采取完成“请求-应答”后关闭连接的方式，也就是HTTP协议的无连接特点。而Keep-Alive模式不会立刻关闭连接，避免了重新建立连接。如果客户端浏览器支持Keep-Alive，就在请求头中设置字段 <code>Connection: Keep-Alive</code>，如果服务器也支持这种模式，会在相应头中也设置同样的字段，这样Keep-Alive模式就开启了。</p>
<p>HTTP1.1中，默认采取Keep-Alive模式，如果设置字段 <code>Connection: close</code>才关闭。而目前大多数浏览器都是用HTTP1.1协议，这种情况下能否开启Keep-Alive模式取决于服务器的设置。</p>
<p>Keep-Alive的作用是保持下层的TCP连接，并且要求设置一个<strong>超时阈值</strong>和<strong>最大接受请求次数的阈值</strong>，达到阈值会断开连接。</p>
<p>需要注意的是，Keep-Alive只允许保持连接，但HTTP仍然是无状态的，也就是说不同的请求-响应内容仍然是<strong>独立、互不影响</strong>的。此外，程序不应该依赖它的保持连接特性，因为连接会因为各种原因断开。</p>
<h4 id="chunked-传输"><a href="#chunked-传输" class="headerlink" title="chunked 传输"></a>chunked 传输</h4><p>如果在HTTP消息头部设置字段<code>Transfer-Encoding: chunked</code>，则表示消息分块传输。</p>
<p>每一个非空块都由<code>块字节数 + CRLF + 数据</code>组成，最后一块是空块，由<code>0+CRLF</code>组成，表示本次传输数据结束。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">25</span><br><span class="line">This is the data in the first chunk</span><br><span class="line"></span><br><span class="line">1A</span><br><span class="line">and this is the second one</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>优点：使用chunked传输可以边生成内容边发送。</p>
<p>缺点：chunked 传输的接收方事先不知道全部数据的长度，所以无法实现进度追踪。</p>
<h4 id="HTTP劫持-内容劫持"><a href="#HTTP劫持-内容劫持" class="headerlink" title="HTTP劫持 (内容劫持)"></a>HTTP劫持 (内容劫持)</h4><p>采用http协议的TCP数据包在传输时会经过网关，网关（如ISP）通过篡改服务器发回的数据包中响应报文的内容，抢先回复客户端，使真正的响应数据包被丢弃，自己篡改的数据包被接受，从而达到目的（修改的内容）。</p>
<p>其中修改内容的方式可以是插入静态脚本，插入html content，或使用Iframe植入内容。</p>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>HTTPS协议是HTTP over SSL的缩写，也就是在SSL协议之上的HTTP协议。HTTP是第一个使用SSL协议保障安全的应用层协议，邮件系统也能支持SSL协议，如：SMTP，POP3、IMAP。在SSLv3之后有了TLS1.1, TLS1.2, TLS1.3。</p>
<p>对SSL协议和TLS协议的总结见本文对应章节。</p>
<h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h4><p>在HTTP1.1中，存在这些问题：</p>
<ul>
<li>线头阻塞：一个TCP连接中只能排队发送请求，并且主流浏览器都禁用了请求并发的管线化技术，并发请求必须建立多个TCP连接。</li>
<li>头部冗余：HTTP1.1的数据报首部采用<strong>未压缩</strong>的<strong>文本</strong>格式，多个请求会带有重复的cookie、user-agent等信息。</li>
<li>连接只能由客户端主动开启</li>
</ul>
<p>HTTP2.0极大地优化了性能：</p>
<ul>
<li>二进制分帧层：把请求/响应报文的格式改为headers和data组成的两个数据帧，并且采用二进制编码和传输。</li>
<li>多路复用：一个TCP连接中可以有多个流(stream)，消息以帧为单位(一个或多个帧)在流中传输，接收之后再进行重组。流控制负责限制数据的数量，即使不限制，浏览器也无法处理无限多的请求。</li>
<li>头部压缩：把常见的头部名称以映射表的形式压缩成短的序号，由客户端和服务器共同维护一份静态映射表和一份动态添加的映射表，使用静态huffman编码对首部进行编码。</li>
<li>服务器端推送：服务器能够根据前面的客户端请求分析依赖的其他资源，并主动推送到客户端的缓存。服务器会先发送PUSH_PROMISE来通知客户端，客户端可以选择RST_STREAM来拒绝推送。</li>
</ul>
<h3 id="邮件协议"><a href="#邮件协议" class="headerlink" title="邮件协议"></a>邮件协议</h3><h4 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h4><p>SMTP用于客户端向服务器<strong>发送</strong>邮件以及服务器之间<strong>发送</strong>邮件。SMTP客户端向SMTP服务器建立TCP连接来传输数据，如果发件人和收件人的邮箱属于同域，那么SMTP服务器收到邮件只需要转发给本地的POP3服务器即可；如果是不同域，则由SMTP服务器查询DNS，发送给对应域的SMTP服务器。</p>
<h4 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h4><p>POP3负责从服务器接收邮件。每次与服务器连接后，会从服务器下载未读邮件到本地客户端，然后远程服务器会删除这些邮件。POP3存在多终端使用时，只有第一个终端能下载到新邮件的问题。</p>
<h4 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h4><p>IMAP也是负责接收邮件的协议，但它支持与服务器的双向连接。使用IMAP可以在本地客户端将邮件分放在文件夹中，并且分放信息会存在远程服务器上；下载邮件后，服务器不会删除邮件，因此可以多端使用。</p>
<p>* 不同的协议、使用或不使用安全协议(SSL/TLS)都会使用不同的默认端口。</p>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h4><p>http报文中使用的URL是由一段域名和路径组成的，域名相当于唯一ip对外使用的代号，一个ip可以映射多个域名，用于不同的虚拟服务器。域名主要由DNS服务器负责解析，客户端(主要是浏览器)解析域名的完整流程是逐级尝试：</p>
<ul>
<li>浏览器查找自己的DNS缓存。这种缓存一般时效短，容量小。</li>
<li>浏览器查找操作系统的DNS缓存。</li>
<li>从hosts文件中查找。</li>
<li>发起DNS系统调用，向最近的DNS服务器(一般是Local DNS)发起域名解析请求。使用UDP协议向DNS服务器的53端口发起请求。<ul>
<li>DNS服务器查找本地缓存，如果有就发回给客户端。</li>
<li>如果没有，代浏览器发送迭代(或者递归)DNS请求。以迭代为例：<ul>
<li>向根域服务器发起DNS请求，查找域名的顶级域服务器(.com, .tk)IP。</li>
<li>向顶级域服务器发起DNS请求，查找域名(<code>www.xxx.com</code>)服务器的IP。</li>
<li>向域名服务器发起DNS请求，查找目标域名的IP。</li>
<li>DNS服务器获得IP，保存在本地缓存中，并发回给浏览器。</li>
</ul>
</li>
</ul>
</li>
<li>浏览器获得IP，保存在内部缓存中，继续下一步操作。</li>
</ul>
<h4 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h4><p>通过攻击域名解析服务器、修改服务器中某些域名的解析结果，使所有向其发出该域名解析请求的客户端拿到的都是被篡改的ip地址。</p>
<p>或者伪装成域名解析器，做成钓鱼服务器，当接受到域名解析请求，就像客户端返回冒充的ip地址。</p>
<p>解决方法：修改自己的DNS配置为未被劫持的服务器。</p>
<h4 id="DNS污染"><a href="#DNS污染" class="headerlink" title="DNS污染"></a>DNS污染</h4><p>由于通常的域名查询没有任何认证机制，而且域名查询通常基于无连接不可靠的UDP协议，查询者只能接受最先到达的格式正确结果，并丢弃之后的结果，所以通过监听UDP的53端口进行IDS入侵检测，当发现目标域名，就制作伪装的返回包发给请求方，使其得到错误的ip地址，这就是DNS缓存污染，也叫DNS缓存投毒。</p>
<p>解决方法：修改hosts文件，自己配置正确的ip。</p>
<h2 id="中间层——安全协议"><a href="#中间层——安全协议" class="headerlink" title="中间层——安全协议"></a>中间层——安全协议</h2><h3 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h3><p><em><a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">曹世宏的博客</a></em></p>
<p>SSL协议建立在TCP协议和应用层协议之间，它实现在应用层，用于保障传输层TCP协议的安全。整个SSL协议体系包含两层：下层(下接TCP层)是SSL记录(record)协议层，上层(上接应用层)是SSL握手协议层。</p>
<p>上层协议包括SSL握手协议(SSL HandShake Protocol)、SSL密码参数修改协议(SSL Change Cipher Spec Protocol)和SSL告警协议(SSL Alert Protocol)。其中握手协议负责实际数据传输开始前的身份验证、协商加密算法、交换加密密钥等。而下层负责给上层协议提供压缩解压、加密解密、计算和校验MAC等功能。</p>
<p>SSL会话分为握手阶段和数据传输阶段两个阶段。</p>
<h4 id="握手阶段"><a href="#握手阶段" class="headerlink" title="握手阶段"></a>握手阶段</h4><p>握手阶段包含以下几个步骤：</p>
<ul>
<li><p>客户端向服务端发送client hello，其中主要有：</p>
<ul>
<li>客户端支持的协议版本，按优先级列出；</li>
<li>随机数client_random；</li>
<li>session id，用于会话恢复；</li>
<li>客户端已知的加密套件列表；</li>
<li>压缩方法(存在漏洞，在TLS1.3开始禁止)；</li>
<li>Extension，包括服务器名称、支持的签名算法、session ticket(用于会话恢复)等；</li>
</ul>
</li>
<li><p>服务器收到信息回复server hello：</p>
<ul>
<li>服务器选择的协议版本，即客户端支持的最高协议版本；</li>
<li>随机数server_random；</li>
<li>加密套件，选择客户端支持的一个加密套件；</li>
<li>session id，用于会话恢复；</li>
<li>压缩算法；</li>
<li>Extension；</li>
</ul>
</li>
<li><p>服务器发送一系列包给客户端，其中包括：</p>
<ul>
<li><p>发送证书，其中包含公钥；</p>
</li>
<li><p>服务器根据选择的密钥交换方法发送所需的参数：</p>
<ul>
<li>如果采用RSA密钥交换，就没有这一步；</li>
<li>如果采用DH密钥交换，发送服务器的DH参数(被签名保护)；</li>
</ul>
</li>
<li><p>发送Certificate request（如果是双向认证）；</p>
</li>
<li><p>发送server hello done，表示自己的信息已发送完毕。</p>
</li>
</ul>
</li>
<li><p>客户端回复一系列包给服务器，其中包括：</p>
<ul>
<li><p>发送证书 (可选) ；</p>
</li>
<li><p>客户端根据选择的密钥交换方法发送所需的参数：</p>
<ul>
<li><p>如果采用RSA密钥交换，就生成一个新的随机数pre-master secret，用收到的[证书中的公钥]加密这个pre-master发给服务器；</p>
<p><strong>*</strong> 前两个随机数是明文，这个随机数是公钥加密，理论上这个公钥加密还是有可能被破解；</p>
</li>
<li><p>如果采用DH密钥交换，就发送客户端的DH参数(被签名保护)；</p>
<p><strong>*</strong> 双方都拿到了对方的DH参数，组合起来就能算出同一个pre-master secret，避免了对它的传输。</p>
</li>
</ul>
</li>
<li><p>发送Certificate verify (可选)，如果前面发了证书，这里才需要跟一条verify，包含对所有握手消息的HMAC值用master secret签名；</p>
</li>
</ul>
<p>(此时，双方通过三个随机数和选定的加密套件生成了最终的会话密钥)</p>
</li>
<li><p>客户端发送密码更改通知(Change Cipher Spec)，表示准备好使用协商好的加密套件进行通信了；</p>
</li>
<li><p>客户端使用HMAC算法计算前面发送的所有内容的hash值，并用会话密钥加密，供服务器校验，同时表示客户端握手阶段结束了；</p>
</li>
<li><p>服务器用会话密钥解密hash值，同时自己也计算出一个hash值，比较验证数据和密钥的正确性；</p>
</li>
<li><p>服务器发送Change Cipher Spec；</p>
</li>
<li><p>服务器发送自己加密的hash值，供客户端校验，同时表示服务器握手阶段也结束了。</p>
</li>
</ul>
<p>至此，双方终于建立了安全连接，并拥有了共同的会话密钥。</p>
<h4 id="数据传输阶段"><a href="#数据传输阶段" class="headerlink" title="数据传输阶段"></a>数据传输阶段</h4><p>在数据传输阶段，双方使用会话密钥加密、解密明文，同时还对明文计算<strong>检验和</strong>(hash值)，也叫消息认证码(Message Authentication Code, MAC)，或哈希消息验证码(HMAC)，使攻击者无法在篡改明文的同时保证HMAC不变。</p>
<h4 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h4><p>当一次会话断开之后，为了避免重新生成密钥，减少重新建立连接的代价，有几种恢复会话的方法。</p>
<p>一种是session id，即对每个会话绑定一个session id，服务器会保存session id到session secret的映射，收到客户端发来的session id就能找到对应会话已经产生的密钥了，重新建立会话就不用再交换参数生成新的密钥了。这种方式服务器需要保存映射，非常占用存储资源。</p>
<p>另一种是session ticket。服务器将双方协商的密钥等通信信息加密为session ticket附在extension中并发给客户端，由客户端保存。当需要会话恢复时，服务器能够对session ticket进行解密，从而获得会话密钥，重新建立会话连接。</p>
<p>类似于http协议中的session(服务器保存)和cookie(客户端保存)。</p>
<p>详细的会话恢复通信过程见参考博客。</p>
<h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><p>非对称加密英文是public-key cryptography，即公钥加密。服务器生成一对密钥，加密和解密使用不同的密钥，因此称为非对称密钥。非对称密钥可以用来加密、解密信息，也可以制作数字签名。两者的区别是应用场景不同，前者是所有客户端都可以加密，而解密只能是服务器；后者是所有人都可以解密，而加密者是唯一的。非对称加密算法有RSA、DSA等。</p>
<h5 id="加密解密"><a href="#加密解密" class="headerlink" title="加密解密"></a>加密解密</h5><p>以RSA加密算法为例，服务器生成一对公钥和私钥，自己保留私钥，并把公钥发送给客户端，客户端发送的报文都用这个公钥加密，这样就只有服务器的唯一私钥可以解密，防止其他人获取报文中的信息。</p>
<h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>因为公钥是可以被他人截取到的，所以为了防止服务器发出的报文被他人替换成假报文发给客户端，可以使用数字签名。首先将要发送的报文用hash算法生成摘要，再将摘要用私钥加密，作为数字签名，在发送报文时加上数字签名。这样，客户端能够：</p>
<ul>
<li>收到报文后可以用公钥解密数字签名部分，得到hash摘要信息。</li>
<li>计算明文报文部分的hash摘要，和解密出的摘要对比，如果相同就说明报文没有被篡改。</li>
</ul>
<h5 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h5><p>数字签名解决了发回的报文被他人修改冒充的问题，那么如果有人在最开始，服务器向客户端发送公钥的阶段就冒充呢？如果有人截取到服务器发出的公钥信息，并向客户端发自己的公钥，那么客户端加密的所有报文都能被这个人截取并且解密，不仅如此，冒充者还能用私钥生成数字签名，破解上述的防护措施。</p>
<p>数字证书(Certificate Authority, CA)就是解决这个问题的。被认证的权威机构用自己的私钥加密真实服务器的公钥，产生数字证书发给客户端，客户端再用CA的公钥解密获得真实服务器的公钥，这个过程也就是对”服务器公钥”的加密解密。这样，权威机构加密的真实公钥就不怕被替换了。</p>
<p>问题来了，CA机构颁发的数字证书不怕被他人伪造吗？实际上这里还有证书的分级，根证书是预装在操作系统里的，从根证书开始每一级保证下一级证书的可信度，到CA机构的证书，构成一条信用链，因此只要上级证书可信，当前证书就可信。</p>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密算法中，加密和解密都是用同一个密钥，因此称为对称密钥。使用对称密钥的优势是加/解密速度快，适合于对大数据量进行加密。密钥越长越难破解，加解密速度越慢，反之同理。但问题在于，加解密钥相同就意味着要把这个密钥发送给目标客户端时，他人只要截取了这个密钥，就既能加密也能解密了。通常为保证安全性，采用<strong>非对称密钥</strong>加密<strong>对称密钥</strong>，这样密钥能够安全送到客户端手上，并且之后的通信就可以使用对称密钥快速加解密了。对称加密算法有DES、AES等。</p>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>当客户端要向服务器发送请求，首先需要通过三次握手协议建立TCP连接：</p>
<ul>
<li>客户端告诉服务器将要开始发送数据，并告知将要使用的同步位和序列号(SYN = 1,  seq = x)；</li>
<li>服务器发回自己将要使用的同步位和序列号(SYN = 1, seq = y)，以及对客户端的确认信号(ACK = x + 1)；</li>
<li>客户端发回确认信号(ACK = y + 1)，表示双方的连接是稳定的，并将开始发送数据。</li>
</ul>


<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当客户端和服务器完成了通信，需要关闭连接时，采用四次挥手协议：</p>
<p>如果是客户端向服务器提出关闭连接（反之同理），</p>
<ul>
<li><p>客户端发送FIN报文，表示自己这边的数据已经发完了，进入FIN_WAI_1状态；</p>
</li>
<li><p>服务器收到FIN报文，发回ACK报文，作为收到FIN报文的确认，进入CLOSE_WAIT状态；</p>
<ul>
<li>客户端收到ACK报文，进入FIN_WAIT_2状态，继续接收服务器的数据；</li>
</ul>
</li>
<li><p>服务器的数据也发完了，向客户端发送FIN报文；</p>
</li>
<li><p>客户端收到FIN报文也向服务器返回一个ACK报文，通知对方准备可以关闭连接了，自己进入TIME_WAIT状态；</p>
<ul>
<li><p>服务器收到ACK报文，关闭连接；</p>
</li>
<li><p>客户端TIME_WAIT时间用完，关闭连接。</p>
</li>
</ul>
</li>
</ul>




<h4 id="CLOSE-WAIT-和-TIME-WAIT"><a href="#CLOSE-WAIT-和-TIME-WAIT" class="headerlink" title="CLOSE_WAIT 和 TIME_WAIT"></a>CLOSE_WAIT 和 TIME_WAIT</h4><p>在TCP的四次挥手中，接收端收到发送端的FIN报文、回复ACK之后，就会进入CLOSE_WAIT状态，此时发送端收到ACK进入FIN_WAIT_2状态。这时，在这两个状态中，接收端仍有数据没发完或正要发完，而发送端在等待接收端发完并发来FIN报文。</p>
<p>当接收端准备好关闭连接后，向发送端发送FIN报文，此时接收端进入LAST_ACK状态，等待最后一个ACK；发送端等来FIN报文，回复最后一个ACK，就进入TIME_WAIT状态，在TIME_WAIT状态等待2个MSL (Maximum Segment Lifetime) ，才关闭连接；而接收方收到最后一个ACK就随即关闭连接。</p>
<p>主动关闭连接的一端只所以需要在TIME_WAIT状态等2个MSL时间，主要是防止发生几种情况：</p>
<ol>
<li>自己的ACK在传输过程中丢失了，被动关闭的一方没有收到ACK，一直处于LAST_ACK状态。这时，主动方认为连接已经关闭，而被动方认为连接还没关闭，主动方如果需要再次开启连接，会被被动方拒绝，因为端口复用+端口号被占用。</li>
<li>如果双方正常地立即关闭了连接，而又因为需求重新建立了连接，且端口还是原来的端口，这时上个连接中丢失的数据包(网络拥堵等原因)最终姗姗来迟传输到了对方主机，序列号也正好是新连接进行到的序列号，就会被错误接收，而真正的数据包被丢弃。</li>
</ol>
<p>因此，等待一段时间是有效的解决方法。而2个MSL时间确保ACK丢失后，被关闭方重发的FIN能够赶在关闭方关闭连接之前发到。MSL的值在RFC中建议为2分钟，在实际工程实现中多为30秒。</p>
<h4 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h4><h5 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h5><p>前文介绍过TCP协议建立连接的三次握手，其中第一步是客户端向服务器发送SYN，服务器回复SYN+ACK，并等待客户端的ACK。在服务器等待客户端的第三次握手时，TCP连接处于半开连接(half-open connect)状态，服务器将这种连接存储在一个半连接队列里，当收到客户端的第三次握手ACK，就将对应的半连接从队列里移到连接队列。</p>
<p>SYN攻击属于DoS攻击的一种，DoS(Denial of Service)攻击意为拒绝服务攻击，就是利用三次握手的缺陷，不断向服务器发送SYN包(第一次握手)，而又不答复ACK包(第三次握手)，使服务器的半开连接堆满了半连接队列，这时正常用户发送到服务器的连接建立请求包就会被丢弃。此外，服务器维护大量的半连接耗费大量的资源和存储空间，可能造成系统瘫痪，且大量的数据传输可能引起网络拥堵。</p>
<p>普通的SYN攻击使用同一个真实IP伪造大量的SYN包发给服务器。显然这种攻击很容易被服务器识别，只需要在防火墙中禁止掉相应IP的访问就能防御攻击。攻击者还可以伪造大量不同的IP来混淆防御者的视线，或指使不同的真实ip发起DoS攻击，从而构成分布式DoS攻击，也就是DDoS(Distributed DoS)攻击。</p>
<h5 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h5><ol>
<li><p>扩大半连接容量</p>
<p>对于服务器来说，可以通过提高半连接队列容量，但会导致服务器维护半连接的负担比原先更大。</p>
</li>
<li><p>缩短超时阈值</p>
<p>服务器还可以减少半连接的超时阈值，但需要根据实际情况设置阈值，如果设置过小，会影响正常的通讯吞吐量。</p>
</li>
<li><p>SYN代理</p>
<p>设置一台SYN代理，代替服务器完成握手过程，将被攻击的风险转移到代理服务器上，从而保护目标服务器。</p>
</li>
<li><p>SYN Cookies</p>
<p>当半连接队列满了之后，服务器继续接收客户端的SYN包，但此时服务器发回的数据包中的初始SYN按照SYN Cookies算法生成，当客户端收到SYN+ACK后，返回的ACK应该是收到的SYN+1，这是服务器收到ACK减去1，再与发去的SYN cookie比对，如果符合就从cookies中解码出相应的信息，用来重构SYN连接条目。</p>
</li>
</ol>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>如果数据传输时每次发送一个数据包都需要等待ACK才发送下一个，显然会浪费大量的时间用于等待ACK，而在对方能容纳的范围内尽量地连续发送数据能够最大地提升通信效率。在TCP中，接收方向发送方告知自己能接收的窗口大小，而发送方就按照窗口大小连续地发送数据，每当收到一个累计ACK后，就将窗口相应地往右滑动，将已确认的数据包从左边移出窗口，将新的等待发送的数据从右边加入窗口，这就是TCP的滑动窗口方法。</p>
<p>从上面的流程中，我们应该知道，在发送窗口内的数据是按顺序依次发送的，所以窗口内的数据一定有两种状态：<strong>已经发出但还没收到确认的</strong>和<strong>未发出但能够发出</strong>的。</p>
<p>让我们分别从发送方和接收方的视角来看：</p>
<p>对于接收方来说，数据缓存分为三块：已确认未使用，未确认 (因为累计确认机制) ，空余区域。因此，接收方可以根据空余区域的大小向发送方提出发送窗口。</p>
<p>对于发送方来说，上层应用要发送的数据分为四种 (按时间顺序) ：已发送已收到确认，已发送未收到确认，未发送可发送，未发送不可发送。其中的第二和第三部分就是滑动窗口覆盖的部分，发送方根据接收方提出的窗口大小发送数据，当收到一组确认，就把窗口对应地移动。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>滑动窗口机制避免了发送方和接收方的拥塞，而本节要介绍的拥塞控制解决的是网络中的拥塞。根据控制条件不同，产生了不同的拥塞控制算法：基于丢包(Reno)、基于时延(Vegas)、基于容量(Google BBR)、基于学习(Renny)。</p>
<h5 id="Reno"><a href="#Reno" class="headerlink" title="Reno"></a>Reno</h5><p>快重传：当接收方收到时序报文段时立即重复发出确认，而发送方收到三次重复确认后要立即重传缺失报文段。</p>
<p>慢启动：发送窗口的大小从1开始，每次增大一倍(*2)，当达到<strong>慢启动阈值</strong>，进入拥塞避免阶段；或者收到三次重复确认，触发<strong>快恢复</strong>。</p>
<p>拥塞避免：发送窗口的大小每次加1，直到收到三次重复确认，触发<strong>快恢复</strong>。</p>
<p>快恢复：当发生快重传，说明网络状况不良，应该减小发送窗口，因此将<strong>慢启动阈值</strong>减半，并在新的阈值处直接进入拥塞避免阶段。</p>
<h5 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h5><p>通过瓶颈带宽和最大时延的延迟评估当前链路的状况、调整发送窗口的大小。</p>
<h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><h5 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h5><p>每个数据包都包含首部和数据的检验和，接收端会检查检验和，如果错误就丢弃该数据包，并根据重传策略做出反应（不确认或者重复确认）。</p>
<h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>在超时重传方法中，通过计时器和超时阈值来判断数据包是否需要重新发送。这个判断标准如果选择一个固定的经验值，则会因为不同场景网络状况不同而产生糟糕的效果。因此使用实际网路的往返时间(Round Trip Time, RTT) 来辅助判断。</p>
<p>经典的RTT计算方法是平滑RTT(SRTT)，每次对历史SRTT值和最新的RTT值计算加权平均，并更新SRTT。而重传阈值(Retransmission Time Out, RTO)将SRTT乘以一个参数后限制上下限得到。</p>
<p>现在的标准方法是计算rttvar，将rttvar和RTT的误差(|RTT-SRTT|)加权得到。而RTO = SRTT + 4 * rttvar。</p>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>即拥塞控制Reno中的快重传机制，详见上文。</p>
<h5 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h5><p>选择确认(Selective Acknowledgement, SACK)方法在快速重传的基础上实现，当收到乱序报文段，就返回最近收到的乱序包的左右边界。</p>
<h5 id="DSACK"><a href="#DSACK" class="headerlink" title="DSACK"></a>DSACK</h5><p>重复选择确认(Duplicated SACK)</p>
<h4 id="keepalive"><a href="#keepalive" class="headerlink" title="keepalive"></a>keepalive</h4><p><em>待填</em></p>
<h3 id="值得注意的问题"><a href="#值得注意的问题" class="headerlink" title="值得注意的问题"></a>值得注意的问题</h3><h4 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h4><p>建立分层的模型能够让不同的功能相互分离，各司其职，彼此通过简单的接口连接，让复杂系统在设计和迭代时更加清晰易用，且更容易拓展新的技术/协议/功能。</p>
<h4 id="为什么连接的时候是三次握手，关闭的时候却是四次握手"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手</h4><p>因为建立连接时，当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。</p>
<p>但是关闭连接时，当服务器收到FIN报文时，先回复ACK报文。等到服务器所有的数据都发送完了，才发送FIN报文。因为两个报文不能一起发送。故需要四步握手。</p>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p>TCP为了建立可靠的连接，引入了一系列策略，比如握手协议、流量控制、拥塞控制、确认/重传机制，这些都是需要牺牲时间来完成的。</p>
<p>而UDP不面向连接，所以不用握手；不关注对方是否收到，所以不需要确认和重传。</p>
<p>因此，TCP适合要求可靠连接、对准确性要求较高而对效率要求较低的场景，比如文件传输、接收邮件等；UDP适合对效率要求高，对准确性要求较低的场景，比如实时聊天(包括文字、语音、视频聊天)、广播通信。</p>
<h4 id="一次HTTP请求的完整过程"><a href="#一次HTTP请求的完整过程" class="headerlink" title="一次HTTP请求的完整过程"></a>一次HTTP请求的完整过程</h4><p>当浏览器向服务器发起一次http请求(如GET请求)，会经过以下过程：</p>
<ol>
<li>解析域名，获得真正的ip地址。</li>
<li>建立TCP连接，完成三次握手。</li>
<li>发出请求报文。</li>
<li>服务器返回响应报文。</li>
<li>浏览器解析html代码，开启多线程请求其中的静态资源，其中有两点：<ul>
<li>如果是keep-alive，就不用再建立新的连接</li>
<li>如果本地有同名资源，就在GET请求中加入If-Modifed-Since字段，如果没有更新就是用本地缓存。</li>
</ul>
</li>
<li>整合代码解析结果和资源，渲染网页。</li>
</ol>
<p><em>To be continued..</em></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Computer Basics</tag>
        <tag>Network</tag>
        <tag>Protocol</tag>
      </tags>
  </entry>
</search>
